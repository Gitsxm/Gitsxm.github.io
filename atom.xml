<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MggBlog</title>
  
  <subtitle>MggBlog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mggblog.ink/"/>
  <updated>2020-02-21T02:37:26.484Z</updated>
  <id>http://www.mggblog.ink/</id>
  
  <author>
    <name>Mgg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十九）—— main() 方法</title>
    <link href="http://www.mggblog.ink/2020/02/21/javabase29-main/"/>
    <id>http://www.mggblog.ink/2020/02/21/javabase29-main/</id>
    <published>2020-02-21T01:45:43.000Z</published>
    <updated>2020-02-21T02:37:26.484Z</updated>
    
    <content type="html"><![CDATA[<p><em>Java中，mian 方法是所有程序的入口，与其他方法有很大的不同，从开始到现在 main 方法已经用过很多次了，但是从来没有详细说明过 main 方法的特点，本篇内容来补充这个知识点。</em></p><a id="more"></a><hr><h2 id="Java-main-方法"><a href="#Java-main-方法" class="headerlink" title="Java main() 方法"></a>Java main() 方法</h2><p>main 方法有只有一种写法，格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 main 方法代码发现：</p><ul><li>main 方法是公有的；</li><li>main 方法是静态方法；（在当前类的 main 里调用其他方法，那这个方法也必须是 static 修饰）</li><li>main 方法没有返回值；</li><li>main 方法的参数是字符串数组。（用来接收执行 Java 程序的命令行参数。命令行参数作为字符串，按照顺序依次对应字符串数组中的元素。）</li></ul><p>一定要注意，main 方法的定义中只有参数名 args 是可以改变的，其他都是固定格式，不能添不能少。但是我们约定参数名和java规范中的名字一样，所以 args 也是不能改的。</p><p>注意因为 static 修饰，main 方法里调用的所有方法必是静态方法，否者无法调用，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">dogJump();</span><br><span class="line">catJump();<span class="comment">//Cannot make a static reference to the non-static method catJump() from the type Test</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dogJump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Dog jump!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catJump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Cat jump!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个类，下面通过 Windows 命令行工具，查看 main 方法里参数的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = args.length; <span class="comment">// 获取参数数量</span></span><br><span class="line">System.out.println(<span class="string">"一共有 "</span> + n + <span class="string">" 个参数"</span>);</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 判断参数个数是否大于0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">System.out.println(args[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行过程：<br><img src="/2020/02/21/javabase29-main/m.png" alt="通过控制台输入参数"></p><p>可以发现 main 方法可以通过控制台传递字符串参数。</p><p>一个程序只能有一个 main 方法，通常做测试用，比如写了几个类，需要一个入口来测试类中方法是否正确。我们称为单元测试，单元测试在开发中非常重要。</p><p>后面会遇到 Junit ，一个专门用来做单元测试的工具，到时候再详细介绍用法。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Java中，mian 方法是所有程序的入口，与其他方法有很大的不同，从开始到现在 main 方法已经用过很多次了，但是从来没有详细说明过 main 方法的特点，本篇内容来补充这个知识点。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十八）——类中常见关键字（访问权限、static、final）</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase28-lgjz/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase28-lgjz/</id>
    <published>2020-02-20T11:49:51.000Z</published>
    <updated>2020-02-21T02:27:38.571Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇把类中常用的关键字单独拿出来说说，<strong>内容包含：访问权限控制关键字 private、friendly、protected、public，静态关键字 static，完结器 final 关键字</strong></em></p><a id="more"></a><hr><h2 id="一、访问权限控制修饰符（private、friendly、protected、public）"><a href="#一、访问权限控制修饰符（private、friendly、protected、public）" class="headerlink" title="一、访问权限控制修饰符（private、friendly、protected、public）"></a>一、访问权限控制修饰符（private、friendly、protected、public）</h2><p>前面提到，类是对对象的封装，既然是封装，那出发点肯定是不想让箱子外部随机接触箱内，所以设置访问权限，想让你看的给你看，不想的外部怎么都访看不见。</p><ol><li><p>类修饰符：public，default（不用写出来）<br>这四个关键字并不是随处都能用，其中 public 只能用在类声明中，在类声明中，除了使用 public 还可以什么都不写，不写的话权限默认为 default ，两者的不同为：<strong>public 声明的类可以被其他包调用，default（不加修饰符） 权限的类只能在包内使用</strong>。</p></li><li><p>成员变量与成员方法修饰符（private、friendly、protected、public）</p></li></ol><p>四种修饰符权限差异：</p><table><thead><tr><th>访问范围</th><th>private</th><th>friendly(默认)</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类</td><td>可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>同一包中的其他类</td><td>不可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的子类</td><td>不可访问</td><td>不可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的非子类</td><td>不可访问</td><td>不可访问</td><td>不可访问</td><td>可访问</td></tr></tbody></table><p>简短叙述一下（权限大小也按1.2.3.4.排，越往下越大）：</p><ol><li><p>private<br>用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用。</p></li><li><p>friendly<br>如果一个类没有访问控制符，说明它具有默认的访问控制特性。这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，即使其他包中有该类的子类。这种访问特性又称为包访问性（package private）。</p></li><li><p>protected<br>用保护访问控制符 protected 修饰的类成员可以被三种类所访问：该类自身、与它在同一个包中的其他类以及在其他包中的该类的子类。使用 protected 修饰符的主要作用，是允许其他包中它的子类来访问父类的特定属性和方法，否则可以使用默认访问控制符。</p></li><li><p>public<br>当一个类被声明为 public 时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用 import 语句引入 public 类，就可以访问和引用这个类。</p></li></ol><blockquote><p>每个程序的主类必须是 public 。</p></blockquote><p>在讲类的时候里面有提到 private 与 public的用法，其他两个用法实在很少用到，做项目不可能吧权限细分的那么清楚，找很多麻烦。</p><h2 id="二、static-关键字（加一个静态导入的知识）"><a href="#二、static-关键字（加一个静态导入的知识）" class="headerlink" title="二、static 关键字（加一个静态导入的知识）"></a>二、static 关键字（加一个静态导入的知识）</h2><p>类中的属性和方法概括为类成员，带有 static 关键字修饰的称为：静态成员，静态成员为类所有，不依赖与任何对象，只要类被加载，就可以被访问。</p><p>前面有用到了 static 修饰的属性和方法，调用语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.方法/属性;</span><br></pre></td></tr></table></figure><p>再举个例子加深印象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">"kangkang"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: run   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 男孩跑步 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">" is running！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 男孩跳 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">" is jumpping！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//创建两个 boy 对象</span></span><br><span class="line">Boy boy1 = <span class="keyword">new</span> Boy();</span><br><span class="line">Boy boy2 = <span class="keyword">new</span> Boy();</span><br><span class="line">System.out.println(<span class="string">"静态变量 name 值："</span>+Boy.name);</span><br><span class="line">boy1.jump();</span><br><span class="line">boy2.jump();</span><br><span class="line"><span class="comment">// 在这里改变静态变量值</span></span><br><span class="line">Boy.name = <span class="string">"jhon"</span>;</span><br><span class="line">System.out.println(<span class="string">"------静态变量值改变--------"</span>);</span><br><span class="line">System.out.println(<span class="string">"静态变量 name 值："</span>+Boy.name);</span><br><span class="line">boy1.jump();</span><br><span class="line">boy2.jump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/20/javabase28-lgjz/s.png" alt="静态成员不依赖对象"></p><p>我们发现，静态变量值改变时，使用它的每一个对象也会作出相应改变，如果是普通成员变量的话，不同对象的值是没有干扰的。</p><p>静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。</p><p>如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。</p><blockquote><p>除了静态方法静态变量，类中还可以有静态代码块，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticCode</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Boy.i); <span class="comment">//结果为 11</span></span><br></pre></td></tr></table></figure><p>在直接使用时，i 已经自加过了，提高了代码效率？我实在不知道有什么用。</p></blockquote><blockquote><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>在 JDK 1.5 之后增加了一种静态导入的语法，用于导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法。如果一个类中的方法全部是使用 static 声明的静态方法，则在导入时就可以直接使用 import static 的方式导入。</p><p>静态导入使用 import static 语句，静态导入也有两种语法，分别用于导入指定类的单个静态成员变量、方法和全部静态成员变量、方法，其中导入指定类的单个静态成员变量、方法的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.ClassName.fieldName|methodName;</span><br></pre></td></tr></table></figure><p>上面语法导入 package.ClassName 类中名为 fieldName 的静态成员变量或者名为 methodName 的静态方法。例如，可以使用import static java.lang.System.out;语句来导入 java.lang.System 类的 out 静态成员变量。</p><p>导入指定类的全部静态成员变量、方法的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.ClassName.*;</span><br></pre></td></tr></table></figure><p>上面语法中的星号只能代表静态成员变量或方法名。</p><p><strong>说那么多，其实只需与普通 import 对比下就行了，一句话： import 和 import static 的作用，使用 import 可以省略写包名，而使用 import static 可以省略类名。</strong><br>而且在开发过程中，没什么机会让你手动导入。除了遇到大佬自己写的工具类。</p></blockquote><h2 id="三、final-关键字"><a href="#三、final-关键字" class="headerlink" title="三、final 关键字"></a>三、final 关键字</h2><p>final 的意义就是无法再改变，声明为多少就是多少。</p><p>final 有如下限制作用：</p><ul><li><p>如果 final 用在了变量前面，变量就变为常量，无法在改变，</p></li><li><p>如果 final 加在方法前面，表明方法无法被重写，重写的意思就是方法名和参数一样，方法体不一样。</p></li><li><p>如果 final 加在了类前，表明类无法被继承。</p></li></ul><p>但是在使用时应该注意一下几点：</p><ol><li>在变量中，如果使用 final ，成为常量，可以不赋值，但是在使用前必须先赋值，赋值之后就无法改变了。</li><li>对基本类型变量来说是其值不可变，而对对象引用类型变量来说其引用不可再变。</li><li>在开发中我们约定，如果使用 final 定义常量，常量的名字使用全大写字符，如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP = <span class="string">"192.168.1.1"</span>;</span><br></pre></td></tr></table></figure></li><li>如果 final 修饰了类，就不需要在类方法前加 final 操作没有意义。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本篇把类中常用的关键字单独拿出来说说，&lt;strong&gt;内容包含：访问权限控制关键字 private、friendly、protected、public，静态关键字 static，完结器 final 关键字&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十七）——注释</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase27-doc/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase27-doc/</id>
    <published>2020-02-20T07:24:38.000Z</published>
    <updated>2020-02-21T01:14:44.977Z</updated>
    
    <content type="html"><![CDATA[<p><em>学过了类的各种东西，现在说一个很简单但是很重要的东西，就是注释——javadoc，简单是因为只需要按几下按键就出来了，重要是因为，有注释会给予看程序的其他人极大的方便，其他人不用去猜你写这个类做啥用，这个方法干嘛用。大大提高了程序的可读性，维护起来容易多了。</em></p><a id="more"></a><hr><p>虽然从事开发工作时间不长，但是从我敲第一行代码开始就养成写注释的习惯了，几乎每个方法和类都会写注释，毕竟写个注释用不了几秒。也有遇到大佬不写注释的，类也不写，方法也不写，用到时都要去猜去试，浪费不少时间，大概这就是大佬把，哈哈哈。下面演示一下在 Eclipse 下如何快速生成注释。</p><p>生成注释前必须要先做配置，默认的注释过于简单，配置流程如下：<br><img src="/2020/02/20/javabase27-doc/s1.png" alt="步骤1"><br><img src="/2020/02/20/javabase27-doc/s2.png" alt="步骤2"><br><img src="/2020/02/20/javabase27-doc/s3.png" alt="步骤3"><br><img src="/2020/02/20/javabase27-doc/s4.png" alt="步骤4"><br><img src="/2020/02/20/javabase27-doc/s5.png" alt="步骤5"></p><p>我把我的配置写出来，我就配置了三个，你也可以去百度搜“eclipse 注释模板”挑选自己喜欢的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Files 文件</span></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * All rights Reserved, Designed By www.mggblog.ink</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>:  $&#123;file_name&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> $&#123;package_name&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:Description  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: mgg     </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:   $&#123;date&#125; $&#123;time&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Types   类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: $&#123;type_name&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;todo&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $&#123;user&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> $&#123;date&#125;  </span></span><br><span class="line"><span class="comment"> * $&#123;tags&#125;  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods  方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: $&#123;enclosing_method&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;todo&#125; </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: $&#123;user&#125;  </span></span><br><span class="line"><span class="comment"> * $&#123;tags&#125;        </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>下面说如何用，上图：<br><img src="/2020/02/20/javabase27-doc/demo.gif" alt="/**+回车"></p><p>然后编辑 Description ,描述作用。方法上生成注释的操作也是一样的，不举例了。</p><p>最后效果</p><p><img src="/2020/02/20/javabase27-doc/sl.png" alt="注释示例"></p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>一定要养成写注释的好习惯啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;学过了类的各种东西，现在说一个很简单但是很重要的东西，就是注释——javadoc，简单是因为只需要按几下按键就出来了，重要是因为，有注释会给予看程序的其他人极大的方便，其他人不用去猜你写这个类做啥用，这个方法干嘛用。大大提高了程序的可读性，维护起来容易多了。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十六）——创建对象（显式、隐式）</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase26-newobj/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase26-newobj/</id>
    <published>2020-02-20T03:09:14.000Z</published>
    <updated>2020-02-21T01:14:43.609Z</updated>
    
    <content type="html"><![CDATA[<p><em>把对象创建的过程称为类的实例化，如果类没有实例化，无论是类属性还是方法都无法使用（除了 static 修饰的），本篇内容学习如何创建对象，<strong>主要内容有：三种显式、一种隐式创建方法</strong></em></p><a id="more"></a><hr><h2 id="一、显式创建对象"><a href="#一、显式创建对象" class="headerlink" title="一、显式创建对象"></a>一、显式创建对象</h2><p>显式创建对象有四种：new 、java.lang.Class 类方法创建、对象 clone 方法、 java.io.ObjectlnputStream 对象的 readObject() 方法。</p><h3 id="1-new-关键字创建对象"><a href="#1-new-关键字创建对象" class="headerlink" title="1.new 关键字创建对象"></a>1.new 关键字创建对象</h3><p>这个是最常用的方式，前面也多次使用，这里不再多叙述，new 的语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型 对象名 = <span class="keyword">new</span> 类型();</span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line">String str = <span class="keyword">new</span> String();</span><br><span class="line"><span class="comment">// 有时候用不着对象名 ——匿名对象</span></span><br><span class="line">System.out.print(<span class="keyword">new</span> String(<span class="string">"This is kangkang!!"</span>));</span><br></pre></td></tr></table></figure><blockquote><p><strong>匿名对象</strong><br>没有明确给出对象名，普通对象需要同时在栈和堆中开辟空间，匿名对象只占用堆空间，而且匿名对象时一次性的，如果当前方法里值与需要用到一次对象，可以采用这种写法，通常作为参数使用。</p></blockquote><h3 id="2-使用-newlnstance-方法"><a href="#2-使用-newlnstance-方法" class="headerlink" title="2.使用 newlnstance() 方法"></a>2.使用 newlnstance() 方法</h3><p>借助了 java.lang.Class 类提供的 newInstance 方法，首先创建 Class 对象（注意区分 Class 与 class，Class是一个具体的类，class 是类的概念，一个关键字），Class 对象无法通过 new 新建，需要借助静态方法 .forName 完成对象创建。Class 类功能很强大，支持了 java 中很重要的 “反射机制” ，反射机制后面单独讲。</p><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class</span></span><br><span class="line">Class 类对象名称 = Class.forName(要实例化的类全称);</span><br><span class="line">类名 对象名 = (类名)Class类对象名称.newInstance();</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// forname 中参数 一定是类的完整路径，要带包名</span></span><br><span class="line">Class cls = Class.forName(<span class="string">"demo_class.Student"</span>);</span><br><span class="line">Student stu = (Student) cls.newInstance();</span><br><span class="line">stu.study();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到了昨天建的 Student 类，要提醒的是，使用 forName 时，参数是类的完整路径，一定要带包名。</p><blockquote><p>提到包名就要说说包命名规范，通常为 com.公司.项目.[package]…. 这个 com 是 company 的缩写，说明是公司项目，那个人项目呢？</p><p>包命名有如下规范：</p><ol><li>个人的项目命名：</li></ol><ul><li>indi ： 个体项目（individual），指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。 包名为“indi.发起者名.项目名.模块名……”</li><li>onem ： 单人项目（one-man），推荐用indi，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。 包名为“onem.发起者名.项目名.模块名……”</li><li>pers ： 个人项目（personal），指个人发起，独自完成，可分享的项目，copyright主要属于个人。 包名为“pers.个人名.项目名.模块名.……”</li><li>priv ： 私有项目（private），指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。 包名为“priv.个人名.项目名.模块名.……”</li></ul><ol start="2"><li>团体的项目命名:</li></ol><ul><li>team： 团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有。 包名为“team.团队名.项目名.模块名.……”</li><li>com ： 公司项目，copyright由项目发起的公司所有。 包名为“com.公司名.项目名.模块名.……”</li></ul><p>比如上面的测试类所处的包正确的包名为：pers.mgg.demo.test </p></blockquote><p>Student 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do homework"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现接口后 重写 clone方法  右击→ Source → Override/Implement Methods</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/2020/02/20/javabase26-newobj/gi.png" alt="使用 newInstance 创建 Student 对象"></p><h3 id="3-使用-clone-方法"><a href="#3-使用-clone-方法" class="headerlink" title="3.使用 clone() 方法"></a>3.使用 clone() 方法</h3><p>该方法很少用，使用该方法创建对象时，要实例化的类必须继承 java.lang.Cloneable 接口。 调用对象的 clone() 方法创建对象的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名对象名 = (类名)已创建好的类对象名.clone();</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">Student stu2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stu2 = (Student) stu1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">stu2.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/20/javabase26-newobj/gi.png" alt="异常处理"></p><blockquote><p>代码中的 try  catch  是异常处理，详细内容到后面异常处理再说，这里稍微提一下：</p><p><img src="/2020/02/20/javabase26-newobj/yc.png" alt="异常处理"></p><p><img src="/2020/02/20/javabase26-newobj/yc2.png" alt="两种不同的异常处理"></p><p>在实际开发中用 try catch 比较多</p></blockquote><h2 id="二、隐式创建"><a href="#二、隐式创建" class="headerlink" title="二、隐式创建"></a>二、隐式创建</h2><p>隐式创建其实前面经常用了，举个例子就是 String str = “oh! awesome!!” 。</p><p>以及当使用字符串拼接时  str = str+”come on”  也会隐式创建对象，str 已经不是原来的 str 了。</p><p>最后 java 虚拟机在加载 .class 文件时，都会创建一个上面说到的 java.lang.Class 对象，用来封装类在方法区内的数据结构。</p><blockquote><p>垃圾回收（jvm gc）<br>每个对象都是相互独立的，在内存中占有独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成了垃圾，由 Java 虚拟机自带的垃圾回收机制处理。</p></blockquote><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>显式的三种方法，前两种要掌握，clone 方法要了解，隐式就没什么可说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;把对象创建的过程称为类的实例化，如果类没有实例化，无论是类属性还是方法都无法使用（除了 static 修饰的），本篇内容学习如何创建对象，&lt;strong&gt;主要内容有：三种显式、一种隐式创建方法&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十五）—— this 关键字</title>
    <link href="http://www.mggblog.ink/2020/02/19/javabase25-this/"/>
    <id>http://www.mggblog.ink/2020/02/19/javabase25-this/</id>
    <published>2020-02-19T10:09:17.000Z</published>
    <updated>2020-02-21T01:14:17.756Z</updated>
    
    <content type="html"><![CDATA[<p><em>this 关键字是 Java 常用的关键字，可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。<strong>本篇包括：this.属性，this.方法，this.构造方法</strong></em></p><a id="more"></a><hr><h2 id="一、this-属性名"><a href="#一、this-属性名" class="headerlink" title="一、this.属性名"></a>一、this.属性名</h2><p>大部分时候，普通方法访问其他方法、成员变量时无须使用 this 前缀，<strong>但如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用 this 前缀</strong>。</p><p>其实在上一篇说 getter setter的时候已经有遇到这个关键字了，<br>举一个 Person 类的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String gender; <span class="comment">//性别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> tall;  <span class="comment">//身高</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了加上 getter 和 setter 这次加点新的，添一个构造方法和一个 toString。</p><p>直接快速生成：<br><img src="/2020/02/19/javabase25-this/pc.png" alt="快速生成三个方法"></p><p>因为是第一次碰到构造方法，请自己仔细体会方法内部信息</p><p>此时 Person 类变成了 完全体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String gender; <span class="comment">//性别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> tall;  <span class="comment">//身高</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带参数构造方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tall</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender, <span class="keyword">double</span> tall)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line"><span class="keyword">this</span>.tall = tall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTall</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTall</span><span class="params">(<span class="keyword">double</span> tall)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tall = tall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", gender="</span> + gender + <span class="string">", tall="</span> + tall + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，构造方法和 setter 方法内部都有 this 关键字，通过 this.属性 让参数变为类属性的值，编写一个测试类来看一下构造方法的作用。</p><blockquote><p>补充一个问题,当类中只有一个有参构造：<br><img src="/2020/02/19/javabase25-this/t.png" alt="注意只有一个有参构造的情况"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">// 利用有参数的构造方法直接给Person类对象属性赋值</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"kangkang"</span>, <span class="number">10</span>, <span class="string">"男"</span>, <span class="number">110</span>);</span><br><span class="line">System.out.println(person.getName());</span><br><span class="line">System.out.println(person.getAge());</span><br><span class="line">System.out.println(person.getGender());</span><br><span class="line">System.out.println(person.getTall());</span><br><span class="line"><span class="comment">// 直接使用toString</span></span><br><span class="line">System.out.println(person.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/19/javabase25-this/t1.png" alt="输出结果"></p><p>很明显，通过类中的有参构造，为 Person 类属性赋值，而在构造方法中正是使用了 this 关键字（仔细体会开头的那句话：<strong>如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用 this 前缀</strong>）</p><p><em>提示：当一个类的属性（成员变量）名与访问该属性的方法参数名相同时，则需要使用 this 关键字来访问类中的属性，以区分类的属性和方法中的参数。</em></p><h2 id="二、this-方法名"><a href="#二、this-方法名" class="headerlink" title="二、this.方法名"></a>二、this.方法名</h2><p>this 关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。</p><p>新建一个 Student 类，让其中一个方法调用另一个方法，具体流程为吃晚饭，写作业，睡觉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"Tom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do homework"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 吃饭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"have a dinner"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 睡觉</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.eat();</span><br><span class="line"><span class="keyword">this</span>.study();</span><br><span class="line">System.out.println(<span class="string">"do sleep"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(Student.name);</span><br><span class="line">stu.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看结果：<br><img src="/2020/02/19/javabase25-this/t2.png" alt="运行结果"></p><p>在 Student 类中的sleep 方法使用this 关键字调用了其他两个方法，在测试类中只需要调用一个 sleep 就可以完成 三个方法的操作。</p><p>我们发现当 sleep 方法改为这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">eat();</span><br><span class="line">study();</span><br><span class="line">System.out.println(<span class="string">"do sleep"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行测试类，发现输出结果一样，<strong>省略 this 前缀只是一种假象，虽然程序员省略了调用 eat()、study() 方法之前的 this，但实际上这个 this 依然是存在的。</strong></p><blockquote><p>注意：对于 static 修饰的方法而言，可以使用类来直接调用该方法，如果在 static 修饰的方法中使用 this 关键字，则这个关键字就无法指向合适的对象。所以，static 修饰的方法中不能使用 this 引用。并且 Java 语法规定，静态成员不能直接访问非静态成员。</p></blockquote><h2 id="三、this-访问构造方法"><a href="#三、this-访问构造方法" class="headerlink" title="三、this 访问构造方法"></a>三、this 访问构造方法</h2><p>将 Student 改为这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.name+ <span class="string">"  do homework"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="string">"Tom"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">stu.study();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/19/javabase25-this/t3.png" alt="输出结果"></p><p>无参构造直接通过 this(“Tom”) 给私有属性赋予了值， this(“Tom”) 与 this.Student(“Tom”) 等价，且只能在构造方法中使用，也必是第一条代码。</p><blockquote><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>当在创建无参构造时，会发现方法中有 super();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super 关键字是指向父类的引用，前面说过创建的每一个类都会继承 Object 类，刚才 this() 的用法为指向自己个构造，那么 super() 就会指向父类构造方法，我认为这解释了为什么创建基类对象后，父类方法可以直接使用。</p><p>与 this() 一样，只能在构造方法中使用，也必是第一条代码。</p></blockquote><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>在正常的开发中，用到实体类都会有专门的软件生成，不用自己手写，因为写实体类实在浪费时间。实体类一建生成可以让程序员吧时间放在逻辑代码部分，提高开发效率。但是作为新手的话，还是多写写，多多体会。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;this 关键字是 Java 常用的关键字，可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。&lt;strong&gt;本篇包括：this.属性，this.方法，this.构造方法&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十四）——类的概念、定义、类属性、类方法</title>
    <link href="http://www.mggblog.ink/2020/02/19/javabase24-oop-class/"/>
    <id>http://www.mggblog.ink/2020/02/19/javabase24-oop-class/</id>
    <published>2020-02-19T00:47:36.000Z</published>
    <updated>2020-02-21T01:13:33.293Z</updated>
    
    <content type="html"><![CDATA[<p><em>在面向对象中，类和对象是最基本、最重要的组成单元。类实际上是表示一个客观世界某类群体的一些基本特征抽象。对象就是表示一个个具体的东西。所以说类是对象的抽象，对象是类的具体。</em></p><a id="more"></a><hr><h2 id="一、类的概念"><a href="#一、类的概念" class="headerlink" title="一、类的概念"></a>一、类的概念</h2><p>类（Class） 就是类别，在上一篇说封装时我们提到类是对象的封装，对象是自然界客观存在的个体，而类是一个概念，并不是可以看得见摸得着的。无论是进口法拉利、兰博基尼、还是国产长城、吉利都属于汽车，汽车是对这些对象的描述，都有外壳、车轮、底盘、方向盘、发动机等，都可以向前跑，向后倒车，鸣喇叭、刹车。类与对象的关系就是 汽车 与这些具体实物的关系，由此可见。</p><ul><li>类是概念模型，定义对象的所有特性和所需的操作，对象是真实的模型，是一个具体的实体。</li><li>类是描述了一组有相同特性（属性）和相同行为（方法）的一组对象的集合。</li></ul><p>我们买车的时候会去了解，动发动机怎么样，座椅舒不舒服，悬挂系统稳不稳，轮胎大小等具体信息，这些事对象的属性。还要去试驾开起来如何，体现了对象中的方法。不同的车属性和驾驶体验各有不同。</p><ul><li>对象或实体所拥有的特征在类中表示时称为类的属性。</li><li>对象执行的操作称为类的方法。</li></ul><p><strong>类是构造面向对象程序的基本单位</strong>，是抽取了同类对象的共同属性和方法所形成的对象或实体的“模板”。而对象是现实世界中实体的描述，对象要创建才存在，有了对象才能对对象进行操作。类是对象的模板，对象是类的实例。</p><p>举一些类的例子：</p><p><img src="/2020/02/19/javabase24-oop-class/cd.png" alt="类"></p><h2 id="二、类的定义"><a href="#二、类的定义" class="headerlink" title="二、类的定义"></a>二、类的定义</h2><p>Java中所有程序都基于类，类是引用类型。定义类的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[public][abstract|final]class&lt;class_name&gt;[extends&lt;class_name&gt;][implements&lt;interface_name&gt;] &#123;</span><br><span class="line">    <span class="comment">// 定义属性部分</span></span><br><span class="line">    &lt;property_type&gt;&lt;property1&gt;;</span><br><span class="line">    &lt;property_type&gt;&lt;property2&gt;;</span><br><span class="line">    &lt;property_type&gt;&lt;property3&gt;;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">// 定义方法部分</span></span><br><span class="line">    function1();</span><br><span class="line">    function2();</span><br><span class="line">    function3();</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述语法中各关键字的描述如下。</p><ul><li>public：表示“共有”的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，作为公共工具供其他类和程序使用的类应定义为 public 类。</li><li>abstract：如果类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用 abstract 修饰的方法）和具体方法（没有使用 abstract 修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。</li><li>final：如果类被 final 修饰，则不允许被继承。</li><li>class：声明类的关键字。</li><li>class_name：类的名称。</li><li>extends：表示继承其他类。</li><li>implements：表示实现某些接口。</li><li>property_type：表示成员变量的类型。</li><li>property：表示成员变量名称。</li><li>function()：表示成员方法名称。</li></ul><p>Java 类名的命名规则：</p><ol><li>类名应该以下划线（_）或字母开头，最好以字母开头。</li><li>第一个字母最好大写，如果类名由多个单词组成，则每个单词的首字母最好都大写。</li><li>类名不能为 Java 中的关键字，例如 boolean、this、int 等。</li><li>类名不能包含任何嵌入的空格或点号以及除了下划线（_）和美元符号（$）字符之外的特殊字符。</li></ol><p>例如定义一个汽车类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">String brand; <span class="comment">// 品牌</span></span><br><span class="line"><span class="keyword">double</span> length;<span class="comment">// 长度</span></span><br><span class="line"><span class="keyword">double</span> width; <span class="comment">// 宽度</span></span><br><span class="line"><span class="keyword">double</span> weight;<span class="comment">// 重量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Runing"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的汽车类的属性为：品牌、长度、宽度、重量；方法为 run()。</p><p>class 前的 public 代表公用的，外部可以随意访问该类，属性中的 private 代表私有，只有本类内部可以访问，方法前的 public 表示该方法可以在任意类中使用。</p><h2 id="三、类的属性和方法"><a href="#三、类的属性和方法" class="headerlink" title="三、类的属性和方法"></a>三、类的属性和方法</h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h3><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>|<span class="keyword">protected</span>|<span class="keyword">private</span>][<span class="keyword">static</span>][<span class="keyword">final</span>]&lt;type&gt;&lt;variable_name&gt;</span><br></pre></td></tr></table></figure><p>各参数的含义如下。</p><ul><li>public、protected、private：用于表示成员变量的访问权限。</li><li>static：表示该成员变量为类变量，也称为静态变量。</li><li>final：表示将该成员变量声明为常量，其值无法更改。</li><li>type：表示变量的类型。</li><li>variable_name：表示变量名称。</li></ul><p>为 Car 类中的属性加上修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brand = <span class="string">"Des Auto"</span>; <span class="comment">//品牌</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> length;<span class="comment">//长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> width; <span class="comment">//宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> weight;<span class="comment">//重量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Runing"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加完修饰符后，品牌 brand 属性变成了一个公有静态的常量，值为“ Des Auto ”，让这个汽车类变成类大众汽车的类，final 声明后品牌信息无法修改。</p><p>其他属性变成类私有属性，只能在类内部访问。</p><p>属性不赋值的话有默认值：</p><ul><li>整数型（byte、short、int 和 long）的基本类型变量的默认值为 0。</li><li>单精度浮点型（float）的基本类型变量的默认值为 0.0f。</li><li>双精度浮点型（double）的基本类型变量的默认值为 0.0d。</li><li>字符型（char）的基本类型变量的默认值为 “\u0000”。</li><li>布尔型的基本类型变量的默认值为 false。</li><li>数组引用类型的变量的默认值为 null。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。</li></ul><p>一般属性名的命名方式与变量一样，采用驼峰式，比如 身份证号 用 personId ，电话号码 用 telNumber， 组合词的话头字母小写，后面单词头字母大写，单个字母的属性名小写就可以了。另外还有中间加下划线的命名方式，如 person_id ，驼峰式命名用的比较广泛，但是具体还是要看项目开发规范的要求，有可能写规范的喜欢用下划线呢。</p><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h3><p>方法表示这个类可以完成哪些动作，比如上面 Car 类里有 run() 方法，语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>][<span class="keyword">static</span>]&lt;<span class="keyword">void</span>|return_type&gt;&lt;method_name&gt;([paramList]) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public | private | protected 只能选择一个，代表了不同的访问权限。</p><p>上述代码中一个方法包含 4 部分：方法的返回值、方法名称、方法的参数和方法体。其中 retum_type 是方法返回值的数据类型，数据类型可以是原始的数据类型，即常用的 8 种数据类型，也可以是一个引用数据类型，如一个类、接口和数组等。</p><p>除了这些，一个方法还可以没有返回值，即返回类型为 void，像 main() 方法。method_name 表示自定义的方法名称，方法的名称首先要遵循标识符的命名约定，除此之外，方法的名称第一个单词的第一个字母是小写，第二单词的第一个字母是大写，依此类推。</p><p>paramList 表示参数列表，这些变量都要有自己的数据类型，可以是原始数据类型，也可以是复杂数据类型，一个方法主要依靠参数来传递消息。方法主体是方法中执行功能操作的语句。其他各修饰符的含义如下。</p><ul><li>public、private、protected：表示成员方法的访问权限。</li><li>static：表示限定该成员方法为静态方法。</li><li>final：表示限定该成员方法不能被重写或重载。</li><li>abstract：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类</li></ul><p>这里涉及到的重载，重写，抽象方法后面再做了解。</p><p>我们约定采用驼峰式命名，比如 carRun() 汽车跑的方法：</p><p>为上面的 Car 类重新写个方法 carRun：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brand = <span class="string">"Des Auto"</span>; <span class="comment">// 品牌</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> length;<span class="comment">// 长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> width; <span class="comment">// 宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> weight;<span class="comment">// 重量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有方法 只能在类内部调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Runing"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公有且静态方法，可以在其他类不创建对象的情况下调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">carRun</span><span class="params">(<span class="keyword">double</span> speed)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;<span class="comment">// 共有的 静态的 无法被重写的 带有参数的 并且带有异常处理的方法</span></span><br><span class="line">System.out.println(<span class="string">"The car is start up!"</span>);<span class="comment">//启动引擎</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);<span class="comment">//等待一秒，线程先不用了解  InterruptedException 异常处理就是因为它 模拟汽车运行</span></span><br><span class="line">run();<span class="comment">//调用了类中的run方法</span></span><br><span class="line">System.out.println(<span class="string">"The car is running with speed: "</span> + speed + <span class="string">"km/s"</span>);<span class="comment">//使用了参数 speed</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"car turn off"</span>; <span class="comment">//返回了 car 的运行状态 执行完毕后 car 熄火了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上方 run 方法 与 carRun 在修饰上的不同，编写个测试类来演示一下：</p><blockquote><p>当想调用 Car的属性或者方法时发现只有 public 修饰的属性和方法可以访问<br><img src="/2020/02/19/javabase24-oop-class/bl.png" alt="只有public修饰的属性和方法可以访问"></p><p>那如何设置和获得 Car 类 中的私有属性呢？ 需要在 Car内部设置公有的 设置和读取属性的方法（setter 和 getter）。</p><p>现在大多数 IDE 都提供快速生成 setter 和 getter 方法的按钮，以及构造方法。</p><p>进入 Car 类 在其他方法下方右击→Source→Generate getter and setter<br><img src="/2020/02/19/javabase24-oop-class/gs.png" alt="快速生成 getter 和 setter 方法"><br><img src="/2020/02/19/javabase24-oop-class/set.png" alt="快速生成 getter 和 setter 方法"></p><p>保存 然后再返回测试类。</p><p>发现可以为 Car 的属性设置值了 看一下</p><p><img src="/2020/02/19/javabase24-oop-class/t.png" alt="成功通过类方法设置并获取了私有属性值"></p><p>通常凡是类中有属性的都会是这种形式，属性私有，然后创建公有的setter和getter方法。</p></blockquote><p>经过一段小插曲，继续方法 carRun 的测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//由于是静态方法，不需要new Car对象</span></span><br><span class="line">String status = Car.carRun(<span class="number">120.0</span>);  <span class="comment">//速度参数为double型 120.0，然后使用String 新建String变量 status 接收 carRun 方法返回值。</span></span><br><span class="line">System.out.println(status);</span><br><span class="line"><span class="comment">//System.out.println(Car.carRun(120.0));  //不新建变量直接这样也行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/19/javabase24-oop-class/carrun.gif" alt="测试 carRun 方法"></p><p>仔细对比 run 方法与 carRun 方法 体会不同修饰符的意义，体会有返回值方法 return 的用法。</p><blockquote><h3 id="方法中参数的用法"><a href="#方法中参数的用法" class="headerlink" title="方法中参数的用法"></a>方法中参数的用法</h3><p>方法中的参数可以有很多个且类型可以不同，用“ ,” 隔开。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">int</span> i, String str, Car car, <span class="keyword">double</span> d)</span></span>&#123;<span class="comment">// 方法内部的参数叫 形式参数 形参</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用方法时参数的顺序，数量，类型要严格一致，一一对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">10</span>;</span><br><span class="line">String s = <span class="string">"kk"</span>;</span><br><span class="line">Car car1 = <span class="keyword">new</span> Car;</span><br><span class="line"><span class="keyword">double</span> speed =  <span class="number">120.0</span>;</span><br><span class="line"></span><br><span class="line">printf(sum,s,car1,d);<span class="comment">// 调用方法时 给的参数叫 实际参数 实参</span></span><br></pre></td></tr></table></figure></blockquote><p>还要提醒一点：在方法内部注意变量的作用域 看好花括号 “ {} “</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>这部分知识内容多，需要多练，多体会，基础要打牢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在面向对象中，类和对象是最基本、最重要的组成单元。类实际上是表示一个客观世界某类群体的一些基本特征抽象。对象就是表示一个个具体的东西。所以说类是对象的抽象，对象是类的具体。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十三）——对象概念、面向对象的三个特征</title>
    <link href="http://www.mggblog.ink/2020/02/18/javabase23-oop1/"/>
    <id>http://www.mggblog.ink/2020/02/18/javabase23-oop1/</id>
    <published>2020-02-18T13:37:28.000Z</published>
    <updated>2020-02-21T01:16:45.650Z</updated>
    
    <content type="html"><![CDATA[<p><em>对 Java 语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过相互作用传递信息，实现程序开发。</em></p><a id="more"></a><hr><h2 id="一、对象的概念"><a href="#一、对象的概念" class="headerlink" title="一、对象的概念"></a>一、对象的概念</h2><p>“java是面向对象的语言”这种描述是老生常谈，概念知识没必要长篇大论，个人感觉一个合适的比喻比得过一大段详细的描述。那如何理解“对象”呢？</p><p>对象就是现实世界中的一个实体，比如说人类，每个人都是一个对象，用java程序语言来描述一个人的各种信息与动作，此时称java是面向对象的程序语言。</p><p>每个对象都有自身的特点，以人为例：</p><ul><li>每个人都有性别，名字等（对象的属性），每个正常人都可以吃饭、睡觉（对象的行为）；</li><li>人可以变胖或者变瘦（对象状态变化）；</li><li>每个人都是唯一的，没有完全相同的两个人（对象唯一性）；</li><li>物以类聚，人是生物的一个种类，我只是人类中的一员（对象是类别的实例）；</li><li>自然界除了人，还有花鸟虫鱼野兽等其他类生物，每一个具体的生物都是一个对象（一切皆为对象）。</li></ul><h2 id="二、面向对象的三个特征"><a href="#二、面向对象的三个特征" class="headerlink" title="二、面向对象的三个特征"></a>二、面向对象的三个特征</h2><p>面向对象有散个基本特征：<strong>封装、继承、多态</strong>。首先搞清楚，为什么要面向对象。以人为例：</p><ul><li>有一个人善于弹钢琴，在自己家可以弹，也可以被委派到音乐会去弹，他老婆是老师，每天都要去学校上课（面向对象代码可重复使用，不同种功能分开开发，提高开发效率）</li><li>这个人音乐天赋了得，有个乐团缺个打鼓手，他自学打鼓加入了乐团（面向对象可扩展性）</li><li>乐团按照乐器种类发工资，乐团里每个人都拿到了不同种乐器相应的钱（面向对象易于管理数据与功能的关系）</li></ul><p>以 java 来说，她多次蝉联世界编程语言使用人数第一的宝座，此殊荣说明了 java 的强大，但是成就了 java 如此强大的是她的三个核心特征：封装、继承、多态。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是将对象属性与方法结合起来，外部无法干扰到对象内部的属性信息与方法，保护了该对象不被破坏。有以下优点：</p><ul><li>保护对象，外部在没有权限的情况下无法随意访问对象内部</li><li>隐藏细节信息，如外人只知道我善于弹钢琴，但是他不知道我是如何弹的那么好的。</li><li>有利于建立对象间的耦合关系，还是乐团的例子，我会弹钢琴，别人会其他乐器，一起组了个乐团，合作一起做音乐。</li><li>提高软件复用率，有个乐团出高新招聘钢琴师，我不满意现在的工资跳槽了过去，我并不是只能在这个乐团弹。</li></ul><p>java 中封装的对象称为为类，有权限修饰符 private protect public  来限定外部访问的权限大小，后面再说。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承很容易理解，就以人来说，正常情况下，一个人可以走路，他的儿子应该也会走路，不但会走路，还会开车。放在程序中，就是子类继承了父类的所有属性和方法，并且可以具有父类没有的属性与方法。<strong>在java中每个类只可以继承一个父类（单继承机制）</strong></p><p>举个具体程序的例子：</p><p>有一个 Person 类:<br>类中属性有：姓名，性别，年龄。<br>类中的方法有：吃饭，睡觉。</p><p>我可以使用这个 Person 类完成一个具体的操作“康康是个男生，今年10岁，他正在吃饭，一会要去睡觉。”</p><p>现在我需要一个 Student 类来完成学生的具体操作“小红是个女生，今年9岁，她吃完饭，要去睡觉，睡醒要学习，然后再吃饭睡觉。” 显然 Person 中没有学习的功能，而且 student 类依然需要 person 类中的属性和方法。</p><p>此时只需要创建一个 student 类继承 person 类，然后在 student 类中新增 学习的方法就可以了。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态的属性是相对于接口来说的，因为类只支持单继承，而接口支持多实现（可以认为是接口的多继承），类在下一篇学，接口在单独讲多态的时候学，学完后可以再返回来看看这三个属性加深理解。</p><p>举例说明接口的多态：</p><p>有一个 teacher 类 ，类中有一个 teach 的抽象方法（接口中的方法都是抽象的，抽象的意思是只有方法名没有方法体，方法如何执行写在实现接口的类中）</p><p>然后有 englishteacher 类 和 mathteacher 类分别实现了 teacher 接口</p><p>englishteacher 类中的 teach 方法具体表现为 teach english</p><p>mathteacher 类中 teach 方法具体表现为 tech math。</p><p><img src="/2020/02/18/javabase23-oop1/dt.png" alt="接口的实现"></p><p>那么多态有什么什么好处呢，就上面的例子，写接口的人只需考虑老师要做哪些工作，不用考虑具体做什么，英语老师只需要关心教英语，数学老师只需要关心教数学。</p><p>今天的内容只是简单介绍，这些内容，会在后面的学习中有更多的体会。<br>__</p><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>最近掉头发掉的厉害，睡了睡了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;对 Java 语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过相互作用传递信息，实现程序开发。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十二）——选择排序</title>
    <link href="http://www.mggblog.ink/2020/02/18/javabase22-xzpx/"/>
    <id>http://www.mggblog.ink/2020/02/18/javabase22-xzpx/</id>
    <published>2020-02-18T01:43:31.000Z</published>
    <updated>2020-02-21T00:35:29.646Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇内容包括：选择排序，三种排序方法总结</em></p><a id="more"></a><hr><h2 id="一、选择排序"><a href="#一、选择排序" class="headerlink" title="一、选择排序"></a>一、选择排序</h2><h3 id="选择排序思路"><a href="#选择排序思路" class="headerlink" title="选择排序思路"></a>选择排序思路</h3><p>选择排序思路比较简单，从第一次开始，每次都找到数组中最小的值，互换掉索引最小的那个，举例说明：<br>如数组 int arr[] = {6,5,4,3,2,1} ,从第一个元素开始不断寻找最小值来互换：</p><p>第一步，找到最小值为 1 ，互换 6 结果为 1 5 4 3 2 6；</p><p>第二步，从剩下的 5 4 3 2 6 中找到最小值 2 ，互换 5 结果为 1 2 4 3 5 6；</p><p>第三步，从剩下的 4 3 5 6 中找到最小值 3 ，互换 4 结果为 1 2 3 4 5 6 ，排序完成了？</p><p>其实排序并没有完成，第三步完成后未排序元素为 4，5，6 ，只不过每次寻找最小都是自身了，但是程序依旧要执行后面的两步：</p><p>第四步，从 4 5 6 找出 4，</p><p>第五步，从 5 6 中 找出 5，</p><p>当只剩下 6 一个元素时 就没必要在运行下去了，因为没有下一个元素个可以比较了。最终排序结果 1 2 3 4 5 6。</p><p>分析例子：</p><p>6 个元素的数组需要找 5 次最小，每一次找到最小要和未被互换过的第一个元素互换，那么程序就理顺了：</p><ol><li>确定循环互换次数，</li><li>找最小值</li><li>互换直到当前元素下标与数组长度-1相等。</li></ol><h3 id="构建程序"><a href="#构建程序" class="headerlink" title="构建程序"></a>构建程序</h3><p>通过上面的分析可以确定，程序需要两层循环，外层循环控制互换次数，并执行互换操作，内层循环寻找最小值。</p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;<span class="comment">//外层确定次数</span></span><br><span class="line"><span class="keyword">int</span> min = arr[i];<span class="comment">//最小值</span></span><br><span class="line"><span class="keyword">int</span> index = i;<span class="comment">//最小值索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;<span class="comment">//找到最小值</span></span><br><span class="line"><span class="keyword">if</span> (min &gt; arr[j]) &#123;</span><br><span class="line">min = arr[j];</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[index] = arr[i];<span class="comment">//最小值与当前元素交换</span></span><br><span class="line">arr[i] = min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出排序完成结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/18/javabase22-xzpx/px.png" alt="排序完成"><br>别的没什么好说的，接下来谈谈冒泡、快速、选择排序的特点做个总结。</p><h2 id="二、总结三种排序方法"><a href="#二、总结三种排序方法" class="headerlink" title="二、总结三种排序方法"></a>二、总结三种排序方法</h2><p>三种方法的时间空间复杂度稳定性比较：<br><img src="/2020/02/18/javabase22-xzpx/td.png" alt="算法特点"></p><p>总结就是：</p><ul><li>冒泡稳定，速度一般；</li><li>快速快，不稳定；</li><li>选择速度一般且不稳定，元素越多效率越低。</li></ul><p>排序算法有七八种呢，这三种较为常见，别的有时间再去了解。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>接下来学 java 类和对象，java 语言的立足之本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本篇内容包括：选择排序，三种排序方法总结&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十一）——快速排序</title>
    <link href="http://www.mggblog.ink/2020/02/17/javabase21-kspx/"/>
    <id>http://www.mggblog.ink/2020/02/17/javabase21-kspx/</id>
    <published>2020-02-17T14:47:29.000Z</published>
    <updated>2020-02-21T01:13:14.130Z</updated>
    
    <content type="html"><![CDATA[<p><em>快速排序由C. A. R. Hoare在1960年提出。快速它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</em></p><a id="more"></a><hr><h2 id="一、快速排序思路"><a href="#一、快速排序思路" class="headerlink" title="一、快速排序思路"></a>一、快速排序思路</h2><p>快速排序相对于冒泡排序的逻辑复杂了很多，带来的好处就是快速排序在几种算法中排序效率较高，无论是面试还是软考很容易碰到，它采用分治法，思想简单概括为：</p><ul><li><ol><li>于数组中选出一个基数（就是排序时以他为准）。</li></ol></li><li><ol start="2"><li>分区，比基数大的放右边，小的放左边。</li></ol></li><li><ol start="3"><li>对两边分别再进行 1.2. 步，最终排序完成。<blockquote><p>从 3. 可以看出算法中肯定需要用到递归，不然无法完成左右再重新分的需求，新手还不懂递归是什么的点击<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/5634537?fr=aladdin">递归</a>。</p></blockquote></li></ol></li></ul><p>从其他博客中看来看去，最终找到了一种很好的理解方式（虽然我也懂得这个算法了，以我三脚猫的功夫怕是说不清啊，我会对博客内容进行整理）：</p><p><em>（以下内容转载自：<a href="https://me.csdn.net/shujuelin">脚丫先生</a>：<a href="https://blog.csdn.net/shujuelin/article/details/82423852">https://blog.csdn.net/shujuelin/article/details/82423852</a> ）</em></p><p>假设现在对“6 1 2 7 9 3 4 5 10 8”这个10个数进行排序。首先在这个序列中随便找一个数作为<strong>基准数</strong>（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列：</p><p>3 1 2 5 4 6 9 7 10 8</p><p>在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。想一想，你有办法可以做到这点吗？</p><p>方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。(直接看图理解就好，文字配图，效果更佳)</p><p><img src="/2020/02/17/javabase21-kspx/kp1.jpg" alt="开始">  </p><p>首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。</p><p><img src="/2020/02/17/javabase21-kspx/kp2.jpg" alt="两边找到符合条件的值">  </p><p><img src="/2020/02/17/javabase21-kspx/kp3.jpg" alt="交换">  </p><p>现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：</p><p>6 1 2 5 9 3 4 7 10 8</p><p><img src="/2020/02/17/javabase21-kspx/kp4.jpg" alt="继续寻找">  </p><p><img src="/2020/02/17/javabase21-kspx/kp5.jpg" alt="交换">  </p><p>到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：</p><p>6 1 2 5 4 3 9 7 10 8</p><p>第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。将基准数6和3进行交换。交换之后的序列如下：</p><p>3 1 2 5 4 6 9 7 10 8</p><p><em>两个哨兵碰头，对应数组内两端取到同一个索引：</em><br><img src="/2020/02/17/javabase21-kspx/kp6.jpg" alt="两个哨兵碰头"><br><em>对应索引与基准数交换：</em><br><img src="/2020/02/17/javabase21-kspx/kp7.jpg" alt="交换"><br><em>交换：</em><br><img src="/2020/02/17/javabase21-kspx/kp8.jpg" alt="交换完成">  </p><p><em>交换完成后结束了相当重要的工作，剩下工作就是对左右两边数组再次进行相同操作，这部分操作对应代码中递归调用的阶段。</em></p><p>到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。</p><p>OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。</p><p>左边的序列是“3 1 2 5 4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧</p><p>如果你模拟的没有错，调整完毕之后的序列的顺序应该是：</p><p>2 1 3 5 4</p><p>OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：</p><p>1 2 3 4 5 6 9 7 10 8</p><p>对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下</p><p>1 2 3 4 5 6 7 8 9 10</p><p><strong>到此，排序完全结束。</strong> 细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。</p><p><img src="/2020/02/17/javabase21-kspx/kpmap.jpg" alt="过程图解">  </p><p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。</p><h2 id="二、构建程序"><a href="#二、构建程序" class="headerlink" title="二、构建程序"></a>二、构建程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_qsort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序入口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="comment">// 输入起始参数，数组arr， 基准数索引为0，最右侧索引为 length-1</span></span><br><span class="line">quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 输出最终结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> low</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> high</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果不知道要会用到多少变量，可以先往下写，用到了再补到上面，i j 分别代表左右索引</span></span><br><span class="line"><span class="keyword">int</span> i, j, temp, t;</span><br><span class="line"><span class="comment">// 如果不满足下面条件说明排序已经完成了</span></span><br><span class="line"><span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明基准数</span></span><br><span class="line">temp = arr[low];</span><br><span class="line"><span class="comment">// 因为后面要和基准数做交换，所以需要声明新变量</span></span><br><span class="line">i = low;</span><br><span class="line">j = high;</span><br><span class="line"><span class="comment">// 根据基准数，左右开始找合适的值</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="comment">// 先从右边开始找小于基准数的元素 自己想想为什么？</span></span><br><span class="line"><span class="keyword">while</span> (temp &lt;= arr[j] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后左边开始找大于基准数的元素</span></span><br><span class="line"><span class="keyword">while</span> (temp &gt;= arr[i] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右边找到小于基准数的元素，左边找到大于基准数的元素，在两边索引还不一致的情况下，交换位置</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">t = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完成了两边交换，此时左右定位到同一个索引上，新型基准数与当前索引元素的交换。</span></span><br><span class="line">arr[low] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line"><span class="comment">// 左右分别开始以上步骤</span></span><br><span class="line"><span class="comment">// 右边数组 虽然此时 i = j 但是在递归调用时 i 会变为 0，所以只能用 j-1 来代表定位同一索引的值</span></span><br><span class="line">quickSort(arr, low, j - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 左边数组</span></span><br><span class="line">quickSort(arr, j + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序结果:<br><img src="/2020/02/17/javabase21-kspx/pxjg.png" alt="过程图解">  </p><p>快速排序不知有一种写法，但是中心思想不变，等熟练了可以试试换种写法。</p><h2 id="三、为什么要先从右边开始找？"><a href="#三、为什么要先从右边开始找？" class="headerlink" title="三、为什么要先从右边开始找？"></a>三、为什么要先从右边开始找？</h2><p>以习惯的基准数在左边第一个，排序为升序为例：</p><p>无论是手写示例还是代码调试都可以很容易找到答案</p><p>以 b 代表基准数，s 代表与基准数互换的数， sL 代表s左边的数, sR 代表s右边的数</p><p>图解：<br><img src="/2020/02/17/javabase21-kspx/bug.png" alt="问题图解">  </p><p>在基准数与 i = j  所在索引的数对换前： </p><p>在对调前还不会出现问题，问题出在对调的数变了，因为在完成 b 与 s 调换后，要达到 b 的左边都小于 b ，右边都大于 b ，那么在调换前这几个数的关系是  sR&gt;b&gt;sL?s,那么开始调换，如果从左边先，索引 i+1 后到达 s，s &lt; b,明显 i 不能停留在 s 的位置，继续 +1 找到大于 b 的数 sR ，然后 j 从右边开始 正好此时 j=i ，本来应该 s 与 b 交换，现在变成了 sR 与 b 交换，sR 是这几个数里最大的，跑到左边肯定就不对了，从这一步开始，后面排序都乱了，从右边先开始就没有这个问题了。</p><p>至于如何从先左边开始才能正确，我觉得要把 左小右大 的规则反过来，这样代码里的逻辑就要完全改变了。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>更新博客睡觉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;快速排序由C. A. R. Hoare在1960年提出。快速它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十）——冒泡排序</title>
    <link href="http://www.mggblog.ink/2020/02/17/javabase20-px/"/>
    <id>http://www.mggblog.ink/2020/02/17/javabase20-px/</id>
    <published>2020-02-17T07:32:04.000Z</published>
    <updated>2020-02-21T01:12:14.826Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇学习数组三种排序方法中的冒泡排序，名字很形象了，冒泡，像汽水里的泡泡一个一个冒到液面。冒泡排序的思想是从第一个元素开始，和相邻的元素比较，如果大于后面元素就交换位置，最终完成排序。</em></p><a id="more"></a><hr><h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><p>了解了思想如何体现到程序上呢，很抽象，那就需要举个排序例子来研究一下。我们直接考虑最麻烦的情况，元素是从大到小排列，每个元素都要冒泡冒上去。</p><p>如一个整数数组 arr[] 中元素为 ：4，3，2，1 。</p><p>对数组进行排序：</p><ol><li><p>根据排序思想，首先 4 和 3 比较 4 &gt; 3 ,顺序变为 3，4，2，1，然后再比较 4 和 2，最终第一次比完结果为 3，2，1，4；<br>一共比对了 3 次，分别是 arr[0]:arr[1],arr[1]:arr[2],arr[2]:arr[3]。</p></li><li><p>然后对 3，2，1，4再进行比较排序…. 第二次比对完结果为：2，1，3，4；<br>此时发现，第一次比对完成后，最后一位元素 4 前面肯定没有了比 4 大的数，已经确定了 4 为最大值，所以剩下的元素比较不用和 4 比，只需要比 2 次即可,分别是 arr[0]:arr[1],arr[1]:arr[2]。本次结果确定了 3 是第二大。</p></li><li><p>最后对 2，1，3，4进行比较….第三次比对完结果为：1，2，3，4；<br>同理当比对完第二次后，确定了 4 为最大值，3 为第二大值， 剩下的数据不需要再和 3，4 比较，只比较 1 次就可以了，arr[0]:arr[1]，最终完成了排序。</p></li></ol><p>由此可以得出结论：4 个元素的数组在最麻烦的情况下，整个数组元素从第一个到最后一个需要比对 3 次，每次数组内部相邻元素分别需要比对 3、2、1次。</p><p>推广到 n 个元素的数组：n 个元素的数组在最麻烦的情况下，需要循环对比 n-1 次，每次数组内相邻的元素分别需要对比 n-1、n-2….2、1次。</p><p>考虑了排序最麻烦的情况，如果程序可以正确处理最麻烦的情况，那像原数组元素排序为 3，2，4，1 这种也不在话下，因为它被包含于最复杂的情况中。</p><p>接下来就可以思考程序内部怎么写了。</p><p>如何让两个元素值对换，如 i=1，j=2，变为 i=2，j=1？</p><p>当直接 i=j 时 j 就无法通过 j=i 获得 真实i 的值，所以 需要一个中间变量先将 i 的值存起来。<br>就是这样： sum = i; i=j; j=sum;  三步走完成数值交换。</p><h2 id="二、构建程序"><a href="#二、构建程序" class="headerlink" title="二、构建程序"></a>二、构建程序</h2><p>从上面的思考中可以看出：</p><ol><li>程序必须有两个循环，外部循环控制总比对次数，内部循环根据索引控制哪两个元素进行比对。</li><li>然后是两个相邻元素的交换需要交换的两个元素需要借助一个额外的变量来做中间量。</li></ol><p>那么程序就出来了：</p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">11</span>, <span class="number">32</span>, <span class="number">56</span>, <span class="number">13</span>, <span class="number">66</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">//控制总循环次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123; <span class="comment">//控制索引进行比对,不理解的话仔细观察思路 1.2.3.</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">sum = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">arr[j] = sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">//输出每次排序的结果</span></span><br><span class="line">System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"次排序，排序结果："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : arr)</span><br><span class="line">System.out.print(a + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//输出最终排序结果</span></span><br><span class="line">System.out.println(<span class="string">"排序结果："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/17/javabase20-px/mp.png" alt="结果符合预期">;</p><p>程序可以还改一改，从控制台输入元素的值，然后排序，这里不再举例。</p><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>冒泡排序是三个排序中最容易理解的排序，仔细体会，下一篇写快速排序，快速排序很少写，没印象，我还要学一学。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本篇学习数组三种排序方法中的冒泡排序，名字很形象了，冒泡，像汽水里的泡泡一个一个冒到液面。冒泡排序的思想是从第一个元素开始，和相邻的元素比较，如果大于后面元素就交换位置，最终完成排序。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十九）——数组查询、复制</title>
    <link href="http://www.mggblog.ink/2020/02/16/javabase19-array-s-c/"/>
    <id>http://www.mggblog.ink/2020/02/16/javabase19-array-s-c/</id>
    <published>2020-02-16T07:23:04.000Z</published>
    <updated>2020-02-21T01:12:13.442Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>本篇内容包括：数组查询指定元素，数组复制</strong></em></p><a id="more"></a><hr><h2 id="一、数组查询指定元素（binarySearch-方法）"><a href="#一、数组查询指定元素（binarySearch-方法）" class="headerlink" title="一、数组查询指定元素（binarySearch() 方法）"></a>一、数组查询指定元素（binarySearch() 方法）</h2><p>两种搜索，一个是查元素返回索引，一个是限定索引范围查元素返回索引。<br><strong>1. binarySearch(Object[] a,Object key)</strong><br>以 int 型数组为例：</p><p>使用二分搜索法来搜索指定的 int 型数组，以获得指定的值。<strong>必须在进行此调用之前对数组进行排序（通过 sort(int[]) 方法）</strong>。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。 </p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">55</span>,<span class="number">22</span>,<span class="number">34</span>,<span class="number">77</span>,<span class="number">11</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(<span class="string">"元素77的索引为："</span>+Arrays.binarySearch(arr, <span class="number">77</span>));</span><br><span class="line">System.out.println(<span class="string">"元素77的索引为："</span>+Arrays.binarySearch(arr, <span class="number">33</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/bs.png" alt="经过排序后77索引为4，如果没有返回负值"></p><p><strong>2. binarySearch(Object[] a,int fromIndex,int toIndex,Object key);</strong><br>依然以 int 型数组为例：</p><p>使用二分搜索法来搜索指定的 int 型数组的范围，以获得指定的值。<strong>必须在进行此调用之前对范围进行排序（通过 sort(int[], int, int) 方法）（jdk文档里这么说，我倒觉得不如直接完全排序清楚）</strong>。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个带有指定值的元素，则无法保证找到的是哪一个。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> fromIndex，<span class="keyword">int</span> endIndex,<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line">Arrays.sort(arr);<span class="comment">// 完全排序</span></span><br><span class="line">System.out.println(<span class="string">"元素77的索引为："</span> + Arrays.binarySearch(arr, <span class="number">1</span>, <span class="number">5</span>, <span class="number">34</span>));</span><br><span class="line">System.out.println(<span class="string">"元素11的索引为："</span> + Arrays.binarySearch(arr, <span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/bs2.png" alt="经过排序后34索引为3，范围内没11，返回负值"></p><h2 id="二、数组复制"><a href="#二、数组复制" class="headerlink" title="二、数组复制"></a>二、数组复制</h2><p>数组复制是编程时常见需求，Java 中提供了四种方法：</p><ol><li>Arrays 类的 copyOf() 方法</li><li>Arrays 类的 copyOfRange() 方法</li><li>System 类的 arraycopy() 方法</li><li>Object 类的 clone() 方法  </li></ol><p>下面分别介绍用法：</p><h3 id="copyOf-与-copyOfRange"><a href="#copyOf-与-copyOfRange" class="headerlink" title="copyOf 与 copyOfRange"></a>copyOf 与 copyOfRange</h3><p>copyOf() 方法是复制数组至指定长度，copyOfRange() 方法则将指定数组的指定长度复制到一个新数组中。<strong>注意：目标数组如果已经存在，将会被重构。</strong><br><strong>1. copyOf</strong><br>以 int 数组方法为例</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOf(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length);</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOf(arr, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">int</span>[] newArr2 = Arrays.copyOf(arr, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"完全复制的新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n未完全复制的新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr2) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/fzjg1.png" alt="复制结果"></p><p><strong>2. copyOfRange</strong><br>依然以 int 数组为例</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOf(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> fromIndex,<span class="keyword">int</span> endIndex);</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOfRange(arr,<span class="number">2</span>,<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">"从索引2-5复制的新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/fzjg2.png" alt="复制结果"></p><p>元素一共八个，但是结束索引的位置是10，新数组中补充了两个 int数组默认值 0 。</p><h2 id="三、arraycopy-方法"><a href="#三、arraycopy-方法" class="headerlink" title="三、arraycopy 方法"></a>三、arraycopy 方法</h2><p>arraycopy() 方法位于 java.lang.System 类中，其语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(dataType[] srcArray,<span class="keyword">int</span> srcIndex,<span class="keyword">int</span> destArray,<span class="keyword">int</span> destIndex,<span class="keyword">int</span> length)</span><br></pre></td></tr></table></figure><p>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的源数组到 dest 引用的目标数组，数组组件的一个子序列被复制下来。被复制的组件的编号等于 length 参数。源数组中位置在 srcPos 到 srcPos+length-1 之间的组件被分别复制到目标数组中的 destPos 到 destPos+length-1 位置。</p><p><strong>注意：目标数组不会被覆盖，相当于替换目标数组中元素的值</strong></p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = &#123;<span class="number">23</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">90</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">26</span>,<span class="number">33</span>,<span class="number">66</span>,<span class="number">77</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"原数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :arr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n目标数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">       <span class="comment">//原函数索引从 0 开始，目标函数索引从2开始，替换长度为 5</span></span><br><span class="line">System.arraycopy(arr, <span class="number">0</span>, newArr, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"\n复制后目标数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/ac.png" alt="复制结果"></p><h2 id="四、clone-方法"><a href="#四、clone-方法" class="headerlink" title="四、clone 方法"></a>四、clone 方法</h2><p>Object类方法，原数组可以直接调用，<strong>目标数组如果已经存在，将会被重构</strong>，由于方法返回值为 Object 型对象，需要强制转换为数组对象（虽然这么说，但是我用过后不用转也可以）。<br>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] newArr = arr.clone();</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr =(<span class="keyword">int</span>[]) arr.clone();</span><br><span class="line">System.out.println(<span class="string">"原数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :arr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n"</span>+arr.equals(newArr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/c.png" alt="复制结果"></p><blockquote><p>注意：以上几种方法都是浅拷贝（浅复制）。浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变。</p></blockquote><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>数组常规操作都有了，下回我们一起学三种排序，冒泡、快速、选择排序，这是算法新手的第一个拦路虎，不同语言有不同的写法，但是思路相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;strong&gt;本篇内容包括：数组查询指定元素，数组复制&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十八）——二维、多维数组及常用方法</title>
    <link href="http://www.mggblog.ink/2020/02/16/javabase18-array2/"/>
    <id>http://www.mggblog.ink/2020/02/16/javabase18-array2/</id>
    <published>2020-02-16T02:14:12.000Z</published>
    <updated>2020-02-21T01:12:11.795Z</updated>
    
    <content type="html"><![CDATA[<p><em>一维数组显然还无法满足日常数据的存储，最常用的 Excel 有行有列就可以满足普通数据的存储需要，二维数组就是表格形式，<strong>本期内容：二维数组、多维数组、数组常用方法（Arrays 类）</strong></em> </p><a id="more"></a><hr><h2 id="一、-二维数组"><a href="#一、-二维数组" class="headerlink" title="一、[二维数组]"></a>一、[二维数组]</h2><h3 id="二维数组声明"><a href="#二维数组声明" class="headerlink" title="二维数组声明"></a>二维数组声明</h3><p>将二维数组理解成一个一维数组的每个元素都是一维数组就可以了，声明方法就是加 [] :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [][] 像一维数组提到的 可以换位置  int[][] arr   或者是 int arr[][]</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">5</span>];<span class="comment">//定义五行五列的int数组</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];<span class="comment">//第二维可以不预设长度，但是用到时要先设置好，否者空指针异常。</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">int</span> arr[][]; <span class="comment">//等用到了再初始化 直接给值 或者设定长度</span></span><br></pre></td></tr></table></figure><p>Demo：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> arr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];<span class="comment">//声明时初始化</span></span><br><span class="line"><span class="keyword">int</span> arr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][]; <span class="comment">//声明时第二维没有初始化</span></span><br><span class="line"><span class="keyword">int</span> arr3[][]; <span class="comment">//声明时未初始化</span></span><br><span class="line">arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">System.out.println(arr1);</span><br><span class="line">System.out.println(arr2);</span><br><span class="line">System.out.println(arr3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase18-array2/csh.png" alt="运行结果"></p><h3 id="二维数组赋值与遍历"><a href="#二维数组赋值与遍历" class="headerlink" title="二维数组赋值与遍历"></a>二维数组赋值与遍历</h3><p>选择初始化时直接赋值或者通过索引赋值。</p><ol><li>直接赋值：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维 int 型数组</span></span><br><span class="line"><span class="keyword">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li>for 循环赋值<br>一维数组赋值时使用一个 for 循环，二维时就需要再嵌套一个 for 循环：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length;j++) &#123;</span><br><span class="line">arr[i][j] = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>赋值用了两层，那么遍历也需要两层，来练习一下。</p><p>创建一个二维数组，从控制台输入值并且遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">System.out.println(<span class="string">"请输入第"</span> + (i + <span class="number">1</span>) + <span class="string">"行第"</span> + (j + <span class="number">1</span>) + <span class="string">"列元素："</span>);</span><br><span class="line">arr[i][j] = input.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"\n~~~~~~~~~~~~"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"行第"</span> + (j + <span class="number">1</span>) + <span class="string">"列元素="</span> + arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果  </p><p><img src="/2020/02/16/javabase18-array2/fzbl.png" alt="二维数组赋值与遍历"></p><p>遍历也可以使用 foreach ,同样要使用两层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] row : arr )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> val : row)&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个数组元素都会获得了，那获取整行整列也就比较简单了。</p><p>以上面demo为例，获取第一行，只需要使用第一个索引就可以了 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] row = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : row) System.out.println(i);</span><br></pre></td></tr></table></figure><p>如果要获取某一列的值就有点麻烦了，无法直接通过获取数组来遍历了，需要使用 for 循环，访问下标,比如获取第二列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"第"</span>+<span class="number">2</span>+<span class="string">"列："</span>+arr[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、多维数组"><a href="#二、多维数组" class="headerlink" title="二、多维数组"></a>二、多维数组</h2><p>其实类似二维数组的理解，一维数组的每个元素都是一维以上的数组，如每个元素都是二维数组就是三维数组，就这么套娃套下去，只要内存顶得住，想多少维就多少维。<br>举个三维的例子，直接赋值吧，控制台输入就是三层 for 嵌套了，遍历也是三层 for 嵌套，几维就需要几个嵌套。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[][][] = &#123;&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;,&#123;&#123;<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>&#125;&#125;&#125;; <span class="comment">//多维的声明就是加 []</span></span><br></pre></td></tr></table></figure><p>这是一个2X2X2的立体数据块，这么理解就可以了，到了四维数组，脑子是理解不动了，反正将索引 [] 使用数学的排列组合就可以定位到所有元素了。</p><p>说到底无论几维数组，都是一维数组，一直嵌套而已，因为内存存储并没有那么多维度，只分栈和堆。由一维的地址指向值，变成地址指向地址，最后在指向堆内的值。</p><p>掌握一维和二维数组用法足够对付大部分问题了。</p><h2 id="三、数组常用方法"><a href="#三、数组常用方法" class="headerlink" title="三、数组常用方法"></a>三、数组常用方法</h2><p>Arrays 类为数组的处理提供了众多方法，例如排序 sort，比较 equals等，里面重载的方法众多，挑出代表，重点在于知道这些方法的使用方式，而不是掌握所有方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>asList(T… a)</td><td>返回一个受指定数组支持的固定大小的列表。</td></tr><tr><td>binarySearch(byte[] a, byte key)</td><td>使用二分搜索法来搜索指定的 byte 型数组，以获得指定的值。</td></tr><tr><td>copyOf(boolean[] original, int newLength)</td><td>复制指定的数组，截取或用 false 填充（如有必要），以使副本具有指定的长度。</td></tr><tr><td>copyOfRange(boolean[] original, int from, int to)</td><td>将指定数组的指定范围复制到一个新数组。</td></tr><tr><td>deepEquals(Object[] a1, Object[] a2)</td><td>如果两个指定数组彼此是深层相等 的，则返回 true。</td></tr><tr><td>deepHashCode(Object[] a)</td><td>基于指定数组的“深层内容”返回哈希码。</td></tr><tr><td>deepToString(Object[] a)</td><td>返回指定数组“深层内容”的字符串表示形式。</td></tr><tr><td>equals(boolean[] a, boolean[] a2)</td><td>如果两个指定的 boolean 型数组彼此相等，则返回 true。</td></tr><tr><td>fill(boolean[] a, boolean val)</td><td>将指定的 boolean 值分配给指定 boolean 型数组的每个元素。</td></tr><tr><td>hashCode(boolean[] a)</td><td>基于指定数组的内容返回哈希码。</td></tr><tr><td>sort(byte[] a)</td><td>对指定的 byte 型数组按数字升序进行排序。</td></tr><tr><td>toString(boolean[] a)</td><td>返回指定数组内容的字符串表示形式。</td></tr></tbody></table><p>这是从jdk1.6文档中获得的数据，在网上看博客时得到 jdk8 中 Arrays 得到加强，添加了许多新方法，这就需要下载jdk8 文档，我从其他博客里转载过来一段。</p><p>由于计算机硬件的飞速发展，目前几乎所有家用 PC 都是 4 核、8 核的 CPU，而服务器的 CPU 则具有更好的性能，因此 Java 8 与时俱进地增加了并发支持，并发支持可以充分利用硬件设备来提高程序的运行性能。</p><ol><li>oid parallelPrefix(xxx[] array, XxxBinaryOperator op)<br>该方法使用 op 参数指定的计算公式计算得到的结果作为新的元素。op 计算公式包括 left、right 两个形参，其中 left 代表数组中前一个索引处的元素，right 代表数组中当前索引处的元素，当计算第一个新数组元素时，left 的值默认为 1。</li><li>void parallelPrefix(xxx[] array, int fromIndex, int toIndex, XxxBinaryOperator op)<br>该方法与上一个方法相似，区别是该方法仅重新计算 fromIndex 到 toIndex 索引的元素。</li><li>void setAll(xxx[] array, IntToXxxFunction generator)<br>该方法使用指定的生成器（generator）为所有数组元素设置值，该生成器控制数组元素的值的生成算法。</li><li>void parallelSetAll(xxx[] array, IntToXxxFunction generator)<br>该方法的功能与上一个方法相同，只是该方法增加了并行能力，可以利用多 CPU 并行来提高性能。</li><li>void parallelSort(xxx[] a)<br>该方法的功能与 Arrays 类以前就有的 sort() 方法相似，只是该方法增加了并行能力，可以利用多 CPU 并行来提高性能。</li><li>void parallelSort(xxx[] a，int fromIndex, int toIndex)<br>该方法与上一个方法相似，区別是该方法仅对 fromIndex 到 toIndex 索引的元素进行排序。</li><li>Spliterator.OfXxx spliterator(xxx[] array)<br>将该数组的所有元素转换成对应的 Spliterator 对象。</li><li>Spliterator.OfXxx spliterator(xxx[] array, int startInclusive, int endExclusive)<br>该方法与上一个方法相似，区别是该方法仅转换 startInclusive 到 endExclusive 索引的元素。</li><li>XxxStream stream(xxx[] array)<br>该方法将数组转换为 Stream，Stream 是 Java 8 新增的流式编程的 API。</li><li>XxxStream stream(xxx[] array, int startInclusive, int endExclusive)<br>该方法与上一个方法相似，区别是该方法仅将 fromIndex 到 toIndex 索引的元索转换为 Stream。</li></ol><p>上面方法列表中，所有以 parallel 开头的方法都表示该方法可利用 CPU 并行的能力来提高性能。上面方法中的 xxx 代表不同的数据类型，比如处理 int[] 型数组时应将 xxx 换成 int，处理 long[] 型数组时应将 XXX 换成 long。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>虽然写了这么多方法，如果不用还是没用，脑袋记和容易网，能做到多翻文档就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;一维数组显然还无法满足日常数据的存储，最常用的 Excel 有行有列就可以满足普通数据的存储需要，二维数组就是表格形式，&lt;strong&gt;本期内容：二维数组、多维数组、数组常用方法（Arrays 类）&lt;/strong&gt;&lt;/em&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十七）——数组简介和一维数组</title>
    <link href="http://www.mggblog.ink/2020/02/15/javabase17-array/"/>
    <id>http://www.mggblog.ink/2020/02/15/javabase17-array/</id>
    <published>2020-02-15T08:30:43.000Z</published>
    <updated>2020-02-21T01:12:09.152Z</updated>
    
    <content type="html"><![CDATA[<p><em>一个数据用变量存储，如果10个人名呢，建十个变量也谈不上麻烦，那100个呢？这时候就需要引入一个新的工具来存储数据了，Java为我们提供了数组工具，<strong>本篇内容：数组简介，一维数组。</strong></em></p><a id="more"></a><hr><h2 id="一、数组简介"><a href="#一、数组简介" class="headerlink" title="一、数组简介"></a>一、数组简介</h2><p>数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。</p><h3 id="数组特征"><a href="#数组特征" class="headerlink" title="数组特征"></a>数组特征</h3><p>数组主要有三个基本特征：</p><ol><li>一个数组内部存放的数据类型一致，如一个元素是 int 型，其他元素也只能是 int 型。</li><li>数组内元素有序排列，这里说的有序是指索引有序，索引从 0 开始，最大值为元素个数 -1。</li><li>初始化数组后，数组的元素个数不能再变化。</li></ol><p>数组大概是这个样子：<br><img src="/2020/02/15/javabase17-array/sl.png" alt="一维和多维数组"></p><p>而且还有几个特点：</p><ol><li>数组可分为一维数组、二维数组和多维数组。</li><li>数值元素默认值为 0 ，引用元素默认为 null，字符型默认为’\u0000’。</li><li>数组内元素可以为数组，这也是多维数组的原理。</li><li>数组是 Array 的派生类。可以使用 Array 类方法处理数组</li></ol><h3 id="数组的内存存储"><a href="#数组的内存存储" class="headerlink" title="数组的内存存储"></a>数组的内存存储</h3><p>数组为引用类型，变量名保存在栈中，元素值保存在堆中。<br>以整型数组为例：  </p><p><img src="/2020/02/15/javabase17-array/szcf.png" alt="int 型数组内存存放"></p><p>如果初始化了一个空数组，堆内数据都为默认值。</p><h2 id="二、一维数组"><a href="#二、一维数组" class="headerlink" title="二、一维数组"></a>二、一维数组</h2><p>上面说了数组是引用类型，所以使用数组时一定要记住需要声明和初始化。</p><h3 id="定义一维数组"><a href="#定义一维数组" class="headerlink" title="定义一维数组"></a>定义一维数组</h3><p>定义数组形式有三种：</p><ol><li>直接定义和初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li><li>指定数组长度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] strs = <span class="keyword">new</span> String [<span class="number">3</span>]; <span class="comment">//当然可以先定义用的时候再初始化 如String [] strs =null ; strs = new String [3];</span></span><br></pre></td></tr></table></figure></li><li>不设定长度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[] &#123; <span class="string">"kk"</span>, <span class="string">"jj"</span> &#125;; <span class="comment">//实在鸡肋方法</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>“ [] “ 在定义中可以变位置，如 int a [] = new int[3];  </li><li>一旦声明了数组的大小，就不能再修改。这里的数组长度也是必需的，不能少。  </li></ul></blockquote></li></ol><h3 id="数组元素赋值与遍历"><a href="#数组元素赋值与遍历" class="headerlink" title="数组元素赋值与遍历"></a>数组元素赋值与遍历</h3><p>数组中每个元素都有索引且索引从 0 开始，使用中括号 [] 读取索引，如 arr[1] 代表着数组 arr 的第二个元素。赋值与遍历是与索引分不开的，写个例子练习一下，其实前面有写过。</p><p>写个Demo，通过控制台给数组赋值，然后再遍历出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String strs[] = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strs.length ;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"请输入第"</span>+(i+<span class="number">1</span>)+<span class="string">"个元素："</span>);</span><br><span class="line">strs[i] = input.nextLine();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"~~~~~~~~~~~~~~\n遍历结果为："</span>);</span><br><span class="line"><span class="keyword">for</span>(String s : strs) System.out.println(s);  <span class="comment">//只遍历数据可以用foreach ,需要通过索引操作还是for循环方便。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/15/javabase17-array/szfz.png" alt="数组元素赋值与遍历"></p><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>Jdk文档中有 Arrays 类定义了大量的数组 sort 方法，可对数组进行排序，感兴趣要去看看 Arrays 类中排序方法的源代码，在这里只说怎么用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">44</span>,<span class="number">55</span>,<span class="number">22</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">80</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) System.out.println((i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/15/javabase17-array/sx.png" alt="按升序排列"></p><p>后面会详细学三种排序算法（冒泡排序、快速排序、选择排序），先看看源码获得启发。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>数组这边要多练习，非常重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;一个数据用变量存储，如果10个人名呢，建十个变量也谈不上麻烦，那100个呢？这时候就需要引入一个新的工具来存储数据了，Java为我们提供了数组工具，&lt;strong&gt;本篇内容：数组简介，一维数组。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十六）——数据类型封装类</title>
    <link href="http://www.mggblog.ink/2020/02/15/javabase16-sjfzl/"/>
    <id>http://www.mggblog.ink/2020/02/15/javabase16-sjfzl/</id>
    <published>2020-02-15T02:00:05.000Z</published>
    <updated>2020-02-17T09:56:50.357Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>本篇内容：Integer 类、Float 类、Double 类、Number 类、Character 类、Boolean 类、 Byte 类。</strong></em></p><a id="more"></a><hr><h2 id="一、Integer-类"><a href="#一、Integer-类" class="headerlink" title="一、Integer 类"></a>一、Integer 类</h2><p>Integer 类在对象中包装了一个基本类型 int 的值。Integer 类型的对象包含一个 int 类型的字段。</p><h3 id="两个带参数构造："><a href="#两个带参数构造：" class="headerlink" title="两个带参数构造："></a>两个带参数构造：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="keyword">int</span> val);<span class="comment">//参数为整型</span></span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(String val);<span class="comment">//参数为字符串型</span></span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>byte  byteValue()</td><td>以 byte 类型返回该 Integer 的值</td></tr><tr><td>short shortValue()</td><td>以 short 类型返回该 Integer 的值</td></tr><tr><td>int  intValue()</td><td>以 int 类型返回该 Integer 的值</td></tr><tr><td>String  toString()</td><td>返回一个表示该 Integer 值的 String 对象</td></tr><tr><td>boolean  equals(Object obj)</td><td>比较此对象与指定对象是否相等</td></tr><tr><td>int  compareTo(Integer anotherlnteger)</td><td>在数字上比较两个 Integer 对象，如相等，则返回 0；小于返回负值大于返回正值</td></tr><tr><td>Integer  valueOf(String s)</td><td>返回保存指定的 String 值的 Integer 对象</td></tr><tr><td>int  parseInt(String s)</td><td>将数字字符串转换为 int 数值</td></tr></tbody></table><p>其中有几个方法我们在前面 String 与 int 互转已经用过很多次了，看看其他方法是什么个效果：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="string">"100"</span>);</span><br><span class="line">System.out.println(integer.compareTo(<span class="keyword">new</span> Integer(<span class="string">"200"</span>)));</span><br><span class="line">System.out.println(integer.doubleValue());</span><br><span class="line">System.out.println(integer.byteValue());</span><br><span class="line">System.out.println(integer.floatValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/integer.png" alt="运行结果">  </p><h3 id="Integer常量"><a href="#Integer常量" class="headerlink" title="Integer常量"></a>Integer常量</h3><p> 常用常量：</p><ul><li>MAX_VALUE：值为 231-1 的常量，它表示 int 类型能够表示的最大值。</li><li>MIN_VALUE：值为 -231 的常量，它表示 int 类型能够表示的最小值。</li><li>SIZE：用来以二进制补码形式表示 int 值的比特位数。</li><li>TYPE：表示基本类型 int 的 Class 实例。</li></ul><h2 id="二、Float-类"><a href="#二、Float-类" class="headerlink" title="二、Float 类"></a>二、Float 类</h2><p>Float 类在对象中包装一个基本类型 float 的值。Float 类型的对象包含一个 float 类型的字段。 </p><p>此外，此类提供了几种方法，可将 float 类型与 String 类型互相转换，还提供了处理 float 类型时非常有用的其他一些常量和方法。 </p><h3 id="Float-类的三个构造方法："><a href="#Float-类的三个构造方法：" class="headerlink" title="Float 类的三个构造方法："></a>Float 类的三个构造方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Float float1 = <span class="keyword">new</span> Float(<span class="keyword">double</span> value);    <span class="comment">// 以 double 类型的变量作为参数创建 Float 对象</span></span><br><span class="line">Float float2 = <span class="keyword">new</span> Float(<span class="keyword">float</span> value);    <span class="comment">// 以 float 类型的变量作为参数创建 Float 对象</span></span><br><span class="line">Float float3 = <span class="keyword">new</span> Float(String s);    <span class="comment">// 以 String 类型的变量作为参数创建 Float 对象</span></span><br></pre></td></tr></table></figure><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>Float 同样提供了与字符串之间相互转换的方法，以及用于比较的 equlas方法，来学一下其他方法：</p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>byteValue()</td><td>byte</td><td>以 byte 类型返回该 Float 的值</td></tr><tr><td>doubleValue()</td><td>double</td><td>以 double 类型返回该 Float 的值</td></tr><tr><td>floatValue()</td><td>float</td><td>以 float 类型返回该 Float 的值</td></tr><tr><td>intValue()</td><td>int</td><td>以 int 类型返回该 Float 的值（强制转换为 int 类型）</td></tr><tr><td>longValue()</td><td>long</td><td>以 long 类型返回该 Float 的值（强制转换为 long 类型）</td></tr><tr><td>shortValue()</td><td>short</td><td>以 short 类型返回该 Float 的值（强制转换为 short 类型）</td></tr><tr><td>isNaN()</td><td>boolean</td><td>如果此 Float 值是一个非数字值，则返回 true，否则返回 false</td></tr><tr><td>isNaN(float v)</td><td>boolean</td><td>如果指定的参数是一个非数字值，则返回 true，否则返回 false</td></tr><tr><td>toString()</td><td>String</td><td>返回一个表示该 Float 值的 String 对象</td></tr><tr><td>valueOf(String s)</td><td>Float</td><td>返回保存指定的 String 值的 Float 对象</td></tr><tr><td>parseFloat(String s)</td><td>float</td><td>将数字字符串转换为 float 数值</td></tr></tbody></table><p>写个 float 与 String 转化demo加深印象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"12.3"</span>;</span><br><span class="line"><span class="keyword">float</span> num = Float.parseFloat(str); <span class="comment">// 将字符串转换为 float 类型的数值</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">45.6f</span>;</span><br><span class="line">String s = Float.toString(f); <span class="comment">// 将 float 类型的数值转换为字符串</span></span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/s.png" alt="运行结果">  </p><h3 id="Float-常量"><a href="#Float-常量" class="headerlink" title="Float 常量"></a>Float 常量</h3><p>在 Float 类中包含了很多常量，其中较为常用的常量如下。</p><ul><li>MAX_VALUE：值为 1.4E38 的常量，它表示 float 类型能够表示的最大值。</li><li>MIN_VALUE：值为 3.4E-45 的常量，它表示 float 类型能够表示的最小值。</li><li>MAX_EXPONENT:有限 float 变量可能具有的最大指数。</li><li>MIN_EXPONENT：标准化 float 变量可能具有的最小指数。</li><li>MIN_NORMAL：保存 float 类型数值的最小标准值的常量，即 2-126。</li><li>NaN：保存 float 类型的非数字值的常量。</li><li>SIZE：用来以二进制补码形式表示 float 值的比特位数。</li><li>TYPE：表示基本类型 float 的 Class 实例。</li></ul><p>输出看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> max_value = Float.MAX_VALUE; <span class="comment">// 获取 float 类型可取的最大值</span></span><br><span class="line"><span class="keyword">float</span> min_value = Float.MIN_VALUE; <span class="comment">// 获取 float 类型可取的最小值</span></span><br><span class="line"><span class="keyword">float</span> min_normal = Float.MIN_NORMAL; <span class="comment">// 获取 float 类型可取的最小标准值</span></span><br><span class="line"><span class="keyword">float</span> size = Float.SIZE; <span class="comment">// 获取 float 类型的二进制位</span></span><br><span class="line">System.out.println(max_value);</span><br><span class="line">System.out.println(min_value);</span><br><span class="line">System.out.println(min_normal);</span><br><span class="line">System.out.println(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/f.png" alt="运行结果">  </p><h2 id="三、Double-类"><a href="#三、Double-类" class="headerlink" title="三、Double 类"></a>三、Double 类</h2><p>Double 类在对象中包装一个基本类型 double 的值。每个 Double 类型的对象都包含一个 double 类型的字段。 </p><p>此外，该类还提供多个方法，可以将 double 转换为 String，将 String 转换为 double，也提供了其他一些处理 double 时有用的常量和方法。</p><h3 id="两个构造方法："><a href="#两个构造方法：" class="headerlink" title="两个构造方法："></a>两个构造方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Double d = <span class="keyword">new</span> Double(<span class="keyword">double</span> value);<span class="comment">//构造一个新分配的 Double 对象，它表示基本的 double 参数</span></span><br><span class="line">Double d = <span class="keyword">new</span> Double(String s); <span class="comment">//构造一个新分配的 Double 对象，表示用字符串表示的 double 类型的浮点值。该方法与 valueOf 方法一样，可将字符串转换为 double 值。</span></span><br></pre></td></tr></table></figure><p>如果字符串有数字以外的字符就会抛出异常。</p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>这些包装类的类方法基本都差不多：<br><img src="/2020/02/15/javabase16-sjfzl/df.png" alt="Double 类常用方法"><br>double 型 与 String 互转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"123.4"</span>;</span><br><span class="line"><span class="keyword">double</span> num = Double.parseDouble(str);    <span class="comment">// 将字符串转换为 double 类型的数值</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">56.78</span>;</span><br><span class="line">String s = Double.toString(d);    <span class="comment">// 将double类型的数值转换为字符串</span></span><br><span class="line">System.out.println(Double.isNaN(d));  <span class="comment">//验证</span></span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/d.png" alt="运行结果">  </p><h3 id="Double-类常量"><a href="#Double-类常量" class="headerlink" title="Double 类常量"></a>Double 类常量</h3><p>基本个Float一样：</p><ul><li>MAX_VALUE:值为 1.8E308 的常量，它表示 double 类型的最大正有限值的常量。</li><li>MIN_VALUE：值为 4.9E-324 的常量，它表示 double 类型数据能够保持的最小正非零值的常量。</li><li>NaN：保存 double 类型的非数字值的常量。</li><li>NEGATIVE_INFINITY：保持 double 类型的负无穷大的常量。</li><li>POSITIVE_INFINITY：保持 double 类型的正无穷大的常量。</li><li>SIZE：用秦以二进制补码形式表示 double 值的比特位数。</li><li>TYPE：表示基本类型 double 的 Class 实例。</li></ul><h2 id="四、Number-类"><a href="#四、Number-类" class="headerlink" title="四、Number 类"></a>四、Number 类</h2><p>抽象类 Number 是 BigDecimal、BigInteger、Byte、Double、Float、Integer、Long 和 Short 类的超类。 </p><p>Number 的子类必须提供将表示的数值转换为 byte、double、float、int、long 和 short 的方法。 </p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p><img src="/2020/02/15/javabase16-sjfzl/n.png" alt="Number 类方法">  </p><p>因为是抽象类，不能自己实例化，要依靠子类，方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number num = <span class="keyword">new</span> Integer(); <span class="comment">//Integer 可以换为任何子类；</span></span><br></pre></td></tr></table></figure><h2 id="五、Character-类"><a href="#五、Character-类" class="headerlink" title="五、Character 类"></a>五、Character 类</h2><p>Character 类在对象中包装一个基本类型 char 的值。Character 类型的对象包含类型为 char 的单个字段。 </p><p>此外，该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然。 </p><p>编码参照 Unicode 标准，我前面说 char 是 ASCII 码，其实没什么问题，Unicode 是 ASCII 码优化来的，都是机器码。</p><h3 id="一个构造方法"><a href="#一个构造方法" class="headerlink" title="一个构造方法"></a>一个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character c = <span class="keyword">new</span> Character(<span class="keyword">char</span> value); <span class="comment">//构造一个新分配的 Character 对象，用以表示指定的 char 值。</span></span><br></pre></td></tr></table></figure><h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><p>无论是字符处理还是判断这些方法都是很重要且常用的,方法都是静态方法，可以直接用。<br><img src="/2020/02/15/javabase16-sjfzl/n2.png" alt="Character 类方法"> </p><p>写个demo，验证字符串大小写，并处理为大写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] c = &#123; <span class="string">'K'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Character.isLowerCase(c[i])) &#123;</span><br><span class="line">c[i] = Character.toUpperCase(c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch : c) &#123;</span><br><span class="line">System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/k.png" alt="运行结果"> </p><h2 id="六、Boolean-类"><a href="#六、Boolean-类" class="headerlink" title="六、Boolean 类"></a>六、Boolean 类</h2><p>Boolean 类将基本类型为 boolean 的值包装在一个对象中。一个 Boolean 类型的对象只包含一个类型为 boolean 的字段。 </p><p>此外，此类还为 boolean 和 String 的相互转换提供了许多方法，并提供了处理 boolean 时非常有用的其他一些常量和方法。 </p><h3 id="两个构造方法"><a href="#两个构造方法" class="headerlink" title="两个构造方法"></a>两个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean b = <span class="keyword">new</span> Boolean(<span class="keyword">boolean</span> value); <span class="comment">// 分配一个表示 value 参数的 Boolean 对象。 </span></span><br><span class="line">Boolean b = <span class="keyword">new</span> Boolean(String s); <span class="comment">//如果 String 参数不为 null 且在忽略大小写时等于 "true"，则分配一个表示 true 值的 Boolean 对象。否则分配一个表示 false 值的 Boolean 对象.</span></span><br></pre></td></tr></table></figure><p>注：一般情况下都不宜使用 new Boolean(boolean value) 构造方法。若不需要新新的实例，则静态工厂 valueOf(boolean) 通常是一个更好的选择。这有可能显著提高空间和时间性能。 </p><p>注： new Boolean(String s) 字符串参数只能为 true/false 不能时其他，比如 yes/no ，ok 什么的。</p><h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><p>相对其他数据类型方法少的多：<br><img src="/2020/02/15/javabase16-sjfzl/b.png" alt="Boolean 常用方法"><br>其中还有一些静态方法很少用到，不再举例。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>三个常量，经常用：</p><ul><li>TRUE：对应基值 true 的 Boolean 对象。</li><li>FALSE：对应基值 false 的 Boolean 对象。</li><li>TYPE：表示基本类型 boolean 的 Class 对象。</li></ul><h2 id="七、Byte-类"><a href="#七、Byte-类" class="headerlink" title="七、Byte 类"></a>七、Byte 类</h2><p>Byte 类将基本类型 byte 的值包装在一个对象中。一个 Byte 类型的对象只包含一个类型为 byte 的字段。 </p><p>此外，该类还为 byte 和 String 的相互转换提供了几种方法，并提供了处理 byte 时非常有用的其他一些常量和方法。 </p><h3 id="两个个构造方法"><a href="#两个个构造方法" class="headerlink" title="两个个构造方法"></a>两个个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Byte b = <span class="keyword">new</span> Byte(<span class="keyword">byte</span> value);<span class="comment">//构造一个新分配的 Byte 对象，以表示指定的 byte 值。 </span></span><br><span class="line">Byte b = <span class="keyword">new</span> Byte(String s); <span class="comment">//构造一个新分配的 Byte 对象，以表示 String 参数所指示的 byte 值。该字符串以使用基数 10 的 parseByte 方法所使用的方式被转换成一个 byte 值。</span></span><br></pre></td></tr></table></figure><p>new Byte(String s) 如果字符串不是 byte值会抛出异常。</p><h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><p>都是一些转换方法：<br><img src="/2020/02/15/javabase16-sjfzl/b1.png" alt="Byte 常用方法"><br>另外还有很多静态方法，感兴趣打开文档看看去。</p><h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><p>在 Byte 类中包含了很多的常量，其中较为常用的常量如下。</p><ul><li>MIN_VALUE：byte 类可取的最小值。</li><li>MAX_VALUE：byte 类可取的最大值。</li><li>SIZE：用于以二进制补码形式表示的 byte 值的位数。</li><li>TYPE：表示基本类 byte 的 Class 实例。</li></ul><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>内置包装类整完了，看着很多，其实并没多少东西，而且各个类方法都有互通之处，记住一个类就可以了，一般用的的方法都一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;strong&gt;本篇内容：Integer 类、Float 类、Double 类、Number 类、Character 类、Boolean 类、 Byte 类。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java内置包装类" scheme="http://www.mggblog.ink/tags/Java%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十五）——Object类和System类</title>
    <link href="http://www.mggblog.ink/2020/02/14/javabase15-obj-sys/"/>
    <id>http://www.mggblog.ink/2020/02/14/javabase15-obj-sys/</id>
    <published>2020-02-14T14:36:42.000Z</published>
    <updated>2020-02-21T01:12:07.574Z</updated>
    
    <content type="html"><![CDATA[<p><em>Object类是所有类的父类，System类是系统类，把这俩类放一块写。剩下的数据类型包装类放一块，下回写。</em></p><a id="more"></a><hr><h2 id="一、Object-类"><a href="#一、Object-类" class="headerlink" title="一、Object 类"></a>一、Object 类</h2><p>类 Object 是类层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法（他是所有类的爸爸）。<br>比如随便新建一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实等价于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下他的类方法有哪些：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Object clone()</td><td>创建与该对象的类相同的新对象</td></tr><tr><td>boolean equals(Object)</td><td>比较两对象是否相等</td></tr><tr><td>void finalize()</td><td>当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法</td></tr><tr><td>Class getClass()</td><td>返回一个对象运行时的实例类</td></tr><tr><td>int hashCode()</td><td>返回该对象的散列码值</td></tr><tr><td>void notify()</td><td>激活等待在该对象的监视器上的一个线程</td></tr><tr><td>void notifyAll()</td><td>激活等待在该对象的监视器上的全部线程</td></tr><tr><td>String toString()</td><td>返回该对象的字符串表示</td></tr><tr><td>void wait()</td><td>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待</td></tr></tbody></table><p>因为 Object 类是所有类的父类，所以这些方法所有类都可以直接用，其中 getClass、equals、toString比较常用。线程相关方法不会出现在业务代码里，用的也比较少，到线程再学：  </p><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p.toString());</span><br><span class="line">System.out.println(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">String name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase15-obj-sys/ts.png" alt="运行结果"><br>结果发现用不用 toString 方法输出结果都是一样的，，这时候可以在 Person 类里重写 toString 方法，让他输出一些有价值的东西（这里涉及后面继承的知识，先看看，不理解后面再学，当前重点在 toString ）。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p.toString());</span><br><span class="line">System.out.println(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">String name = <span class="string">"kangkang"</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行<br><img src="/2020/02/14/javabase15-obj-sys/ts2.png" alt="运行结果">  </p><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a>equals() 方法</h3><p>文档中解释：</p><blockquote><p>指示其他某个对象是否与此对象“相等”。<br>equals 方法在非空对象引用上实现相等关系： </p><ul><li>自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 </li><li>对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 </li><li>传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 </li><li>一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 </li><li>对于任何非空引用值 x，x.equals(null) 都应返回 false。 </li><li>Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。<br>注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。 </li></ul></blockquote><p>巴拉巴拉一大堆，以我理解，就是相当于 == 的效果，没什么用，在各个包装类里的 equals 方法都被重写了，没什么好说的，拿出来说的目的是提醒这个方法和平时用的 equals 不一样。</p><h3 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass() 方法"></a>getClass() 方法</h3><p>getClass 返回一个 Class 对象，所以这个方法要配合Class 类方法使用，举个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">""</span>;</span><br><span class="line">System.out.println(str.getClass());<span class="comment">// 获取Class对象</span></span><br><span class="line">Method[] ms = str.getClass().getMethods();<span class="comment">//获取所有方法</span></span><br><span class="line">System.out.println(str.getClass().getName()); <span class="comment">//获取Class对象名称</span></span><br><span class="line"><span class="keyword">for</span> (Method m :ms ) &#123;</span><br><span class="line">System.out.println(m.getName()); <span class="comment">// 遍历方法名</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase15-obj-sys/ff.png" alt="运行结果">  </p><p>这个 getclass 到后面反射机制的时候会用到。</p><h2 id="二、System-类"><a href="#二、System-类" class="headerlink" title="二、System 类"></a>二、System 类</h2><p>System 类包含一些有用的类字段和方法。它不能被实例化。   </p><p>在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。 </p><p>经常用的 System.out.println() 以及 在控制台输入时 System.in ，那么再来了解了解其他常用的系统级方法：</p><h3 id="arraycopy-方法"><a href="#arraycopy-方法" class="headerlink" title="arraycopy() 方法"></a>arraycopy() 方法</h3><p>该方法的作用是数组复制，即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。该方法的具体定义如下：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,<span class="keyword">int</span> srcPos,Object dest,<span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>其中，src 表示源数组，srcPos 表示从源数组中复制的起始位置，dest 表示目标数组，destPos 表示要复制到的目标数组的起始位置，length 表示复制的个数。<br>来试一下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] srcArray = &#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] destArray = &#123;<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,<span class="string">'H'</span>&#125;;</span><br><span class="line">        System.arraycopy(srcArray,<span class="number">1</span>,destArray,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"源数组："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; srcArray.length;i++) &#123;</span><br><span class="line">            System.out.print(srcArray[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n目标数组："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; destArray.length;j++) &#123;</span><br><span class="line">            System.out.print(destArray[j]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line">   </span><br><span class="line">![运行结果](javabase15-obj-sys/cp.png)  </span><br><span class="line">  </span><br><span class="line">### currentTimeMillis() 方法</span><br><span class="line">返回最准确的可用系统计时器的当前值，以毫微秒为单位。与时钟时间无关系，多用于测试代码执行时间。</span><br><span class="line">```java</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000000</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> time = end - start;</span><br><span class="line">        System.out.println(<span class="string">"程序执行时间"</span> + time + <span class="string">"秒"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase15-obj-sys/sj.png" alt="运行结果"> </p><h3 id="exit-方法"><a href="#exit-方法" class="headerlink" title="exit() 方法"></a>exit() 方法</h3><p>终止当前正在运行的 Java 虚拟机。<br>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br></pre></td></tr></table></figure><p>根据惯例，非 0 的状态码表示异常终止。<br>该方法调用 Runtime 类中的 exit 方法。该方法永远不会正常返回。<br>调用 System.exit(n) 实际上等效于调用： Runtime.getRuntime().exit(n)</p><h3 id="gc-方法"><a href="#gc-方法" class="headerlink" title="gc() 方法"></a>gc() 方法</h3><p>定义：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>运行垃圾回收器。 Java 比 C++ 好的地方之一是有这个 gc 自动回收内存，不用自己管，非要自己调用gc的话用吧，</p><p>调用 gc 方法暗示着 Java 虚拟机做了一些努力来回收未用对象，以便能够快速地重用这些对象当前占用的内存。当控制权从方法调用中返回时，虚拟机已经尽最大努力从所有丢弃的对象中回收了空间。<br>调用 System.gc() 实际上等效于调用： Runtime.getRuntime().gc()</p><h3 id="getProperty-方法"><a href="#getProperty-方法" class="headerlink" title="getProperty() 方法"></a>getProperty() 方法</h3><p>这个方法常用，获取系统中已有的键值对的值。<br>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getProperty</span><span class="params">(String key)</span></span></span><br></pre></td></tr></table></figure><p>常见系统属性：  </p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>java.version</td><td>Java 运行时环境版本</td></tr><tr><td>java.home</td><td>Java 安装目录</td></tr><tr><td>os.name</td><td>操作系统的名称</td></tr><tr><td>os.version</td><td>操作系统的版本</td></tr><tr><td>user.name</td><td>用户的账户名称</td></tr><tr><td>user.home</td><td>用户的主目录</td></tr><tr><td>user.dir</td><td>用户的当前工作目录</td></tr></tbody></table><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(System.getProperty(<span class="string">"java.home"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase15-obj-sys/jh.png" alt="运行结果"> </p><p>就这样吧，不一一距举例了。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>下一篇一次性把几个数组类型的包装类弄了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Object类是所有类的父类，System类是系统类，把这俩类放一块写。剩下的数据类型包装类放一块，下回写。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java内置包装类" scheme="http://www.mggblog.ink/tags/Java%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十四）——包装类、装箱拆箱</title>
    <link href="http://www.mggblog.ink/2020/02/14/javabase14-bz-zxcx/"/>
    <id>http://www.mggblog.ink/2020/02/14/javabase14-bz-zxcx/</id>
    <published>2020-02-14T11:02:20.000Z</published>
    <updated>2020-02-21T01:12:06.663Z</updated>
    
    <content type="html"><![CDATA[<p><em>Java提倡一切皆对象，是面向对象的语言，但是从数据类型来看，引用型数据有对应的对象类，如String，而基本型数据无法被称为对象，为解决这个尴尬问题，Java为每个基本型数据类提供了对应的类，称为包装类，顾名思义就是给它们外面裹一层。<strong>本篇内容：装箱拆箱，包装类应用。</strong></em></p><a id="more"></a><hr><p>首先要对每个基本类型的包装类是什么有所了解，Java提供的包装类除了 int 和 char 的包装类分别为 Integer 和 Character 外，其他包装类都是首字母变大写，还是比较好记的，如下表。</p><table><thead><tr><th>类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>这些包装类为对应的数据类型提供了丰富的类方法，比如在 String 与 int 类型互转用到的 toString 方法，这么多类型不在一一举例，详情后面单独说。</p><h2 id="一、装箱与拆箱"><a href="#一、装箱与拆箱" class="headerlink" title="一、装箱与拆箱"></a>一、装箱与拆箱</h2><p>顾名思义，装箱是将东西装进去，拆箱是将东西拿出来，对应到包装类操作就分别是：基本型→包装类和包装类→基本型，从jdk1.5版本以来提供了自动装箱拆箱支持，下面来看看如何操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">Integer integer = i; <span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> j = integer; <span class="comment">//自动拆箱</span></span><br><span class="line">System.out.println(<span class="string">"拆箱后j="</span>+j);</span><br><span class="line">Integer integer2 = <span class="keyword">new</span> Integer(j);<span class="comment">//手动装箱</span></span><br><span class="line"><span class="keyword">int</span> k = integer2.intValue(); <span class="comment">//手动拆箱</span></span><br><span class="line">System.out.println(<span class="string">"拆箱后k="</span>+k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase14-bz-zxcx/zxcx.png" alt="运行结果"></p><h2 id="二、包装类应用"><a href="#二、包装类应用" class="headerlink" title="二、包装类应用"></a>二、包装类应用</h2><p>手动自动拆装都试过了，装箱为的是使用箱子给提供的方法，最常用就是类型转换，在这里用 int String 互转举例，后面再详细说各个包装类：</p><ol><li><p>int 类型数据 转为 String ,以后都用自动装箱。<br>要用到 Integer 类中 toString();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">Integer integer = i; <span class="comment">// 自动装箱</span></span><br><span class="line">String str = integer.toString();</span><br><span class="line">System.out.println(<span class="string">"装换后字符串："</span> + str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase14-bz-zxcx/izs.png" alt="运行结果">  </p></li><li><p>String 转 int ，使用 Integer.parseInt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"100"</span>;</span><br><span class="line"><span class="keyword">int</span> i =  Integer.parseInt(str);<span class="comment">// 自动拆箱，不拆也没关系</span></span><br><span class="line">System.out.println(<span class="string">"str*2="</span>+i*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase14-bz-zxcx/szi.png" alt="运行结果">  </p></li></ol><p>拆箱装箱的目的就是要使用类方法达到一定目的，到后面封装方法也是一样的目的。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>这篇内容比较少，主要做个介绍，虽然两个概念词听起来很高大上，其实前面已经用到过了，后面的各个包装类，我打算分两次弄完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Java提倡一切皆对象，是面向对象的语言，但是从数据类型来看，引用型数据有对应的对象类，如String，而基本型数据无法被称为对象，为解决这个尴尬问题，Java为每个基本型数据类提供了对应的类，称为包装类，顾名思义就是给它们外面裹一层。&lt;strong&gt;本篇内容：装箱拆箱，包装类应用。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java内置包装类" scheme="http://www.mggblog.ink/tags/Java%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十三）——时间日期处理（Date、Calendar、时间格式化）</title>
    <link href="http://www.mggblog.ink/2020/02/14/javabase13-szcl/"/>
    <id>http://www.mggblog.ink/2020/02/14/javabase13-szcl/</id>
    <published>2020-02-14T02:04:05.000Z</published>
    <updated>2020-02-21T01:12:06.009Z</updated>
    
    <content type="html"><![CDATA[<p><em>在开发中做数据持久化时常常需要统一的时间格式，统一查询口径，方便查询，Java提供了日期处理类 Date 和 Calendar ，Date类封装了系统时间，Calendar 根据系统日历解释 Date 对象，两个类处理时间的思路不一样。<strong>本篇内容包括：Date 类与 Calendar 类使用介绍，日期格式化</strong></em></p><a id="more"></a><hr><h2 id="一、Date-类"><a href="#一、Date-类" class="headerlink" title="一、Date 类"></a>一、Date 类</h2><p>类 Date 表示特定的瞬间，精确到毫秒(Java中还有一个 Date 类，全称为java.sql.Date,这个类是sql相关时间类，平时用到的是java.util.Date,导包的时候注意别导错了)。它表示时间的顺序是星期、月、日、小时、分、秒、年。打开jdk帮助文档，我们发现 Date 类未过时的构造方法有两个，分别是：</p><ul><li>Date()  分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li>Date(long date)  分配 Date 对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即 1970 年 1 月 1 日 00:00:00 GMT）以来的指定毫秒数。<br>举个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">Date d2 = <span class="keyword">new</span> Date(<span class="number">80000000</span>);</span><br><span class="line">System.out.println(d1);</span><br><span class="line">System.out.println(d2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/02/14/javabase13-szcl/sj1.png" alt="输出结果"></li></ul><p>同样可以看到文档中大量方法已经过时，我在下面整理出来可以正常用的：  </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean after(Date when)</td><td>判断此日期是否在指定日期之后</td></tr><tr><td>boolean before(Date when)</td><td>判断此日期是否在指定日期之前</td></tr><tr><td>int compareTo(Date anotherDate)</td><td>比较两个日期的顺序</td></tr><tr><td>boolean equals(Object obj)</td><td>比较两个日期的相等性</td></tr><tr><td>long getTime()</td><td>返回自 1970 年 1 月 1 日 00:00:00 GMT 以来，此 Date 对象表示的毫秒数</td></tr><tr><td>String toString()</td><td>把此 Date 对象转换为以下形式的 String: dow mon dd  hh:mm:ss zzz yyyy。其中 dow 是一周中的某一天(Sun、Mon、Tue、Wed、Thu、Fri 及 Sat)</td></tr></tbody></table><p>做个练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">Date d2 = <span class="keyword">new</span> Date(<span class="number">80000000</span>);</span><br><span class="line">System.out.println(d1.after(d2));</span><br><span class="line">System.out.println(d1.before(d2));</span><br><span class="line">System.out.println(d1.compareTo(d2));<span class="comment">// 相等返回 0 大于返回1 小于返回-1</span></span><br><span class="line">System.out.println(d1.equals(d2));</span><br><span class="line">System.out.println(d1.getTime());</span><br><span class="line">System.out.println(d1.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/14/javabase13-szcl/sj2.png" alt="输出结果"></p><h2 id="二、Calendar-类"><a href="#二、Calendar-类" class="headerlink" title="二、Calendar 类"></a>二、Calendar 类</h2><p>Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 </p><p>因为 Calendar 是一个抽象类，无法像普通类一样 new 一个对象出来，它提供了 getInstance() 方法来完成对象创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar c  = Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>Calendar 提供了众多时间处理方法，要有个大致了解： </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void add(int field, int amount)</td><td>根据日历的规则，为给定的日历字段 field 添加或减去指定的时间量 amount</td></tr><tr><td>boolean after(Object when)</td><td>判断此 Calendar 表示的时间是否在指定时间 when 之后，并返回判断结果</td></tr><tr><td>boolean before(Object when)</td><td>判断此 Calendar 表示的时间是否在指定时间 when 之前，并返回判断结果</td></tr><tr><td>void clear()</td><td>清空 Calendar 中的日期时间值</td></tr><tr><td>int compareTo(Calendar anotherCalendar)</td><td>比较两个 Calendar 对象表示的时间值（从格林威治时间 1970 年 01 月 01 日00 时 00 分 00 秒至现在的毫秒偏移量），大则返回 1，小则返回 -1，相等返回 0</td></tr><tr><td>int get(int field)</td><td>返回指定日历字段的值</td></tr><tr><td>int getActualMaximum(int field)</td><td>返回指定日历字段可能拥有的最大值</td></tr><tr><td>int getActualMinimum(int field)</td><td>返回指定日历字段可能拥有的最小值</td></tr><tr><td>int getFirstDayOfWeek()</td><td>获取一星期的第一天。根据不同的国家地区，返回不同的值</td></tr><tr><td>static Calendar getInstance()</td><td>使用默认时区和语言坏境获得一个日历</td></tr><tr><td>static Calendar getInstance(TimeZone zone)</td><td>使用指定时区和默认语言环境获得一个日历</td></tr><tr><td>static Calendar getInstance(TimeZone zone,Locale aLocale)</td><td>使用指定时区和语言环境获得一个日历</td></tr><tr><td>Date getTime()</td><td>返回一个表示此 Calendar 时间值（从格林威治时间 1970 年 01 月 01 日 00 时00 分 00 秒至现在的毫秒偏移量）的 Date 对象</td></tr><tr><td>long getTimeInMillis()</td><td>返回此 Calendar 的时间值，以毫秒为单位</td></tr><tr><td>void set(int field, int value)</td><td>为指定的日历字段设置给定值</td></tr><tr><td>void set(int year, int month, int date)</td><td>设置日历字段 YEAR、MONTH 和 DAY_OF_MONTH 的值</td></tr><tr><td>void set(int year, int month, int date, int hourOfDay,int minute, int second)</td><td>设置字段 YEAR、MONTH、DAY_OF_MONTH、HOUR、 MINUTE 和 SECOND 的值</td></tr><tr><td>void setFirstDayOfWeek(int value)</td><td>设置一星期的第一天是哪一天</td></tr><tr><td>void setTimeInMillis(long millis)</td><td>用给定的 long 值设置此 Calendar 的当前时间值</td></tr></tbody></table><p>Calendar 对象可以调用 set() 方法将日历翻到任何一个时间，当参数 year 取负数时表示公元前。Calendar 对象调用 get() 方法可以获取有关年、月、日等时间信息，参数 field 的有效值由 Calendar 静态常量指定。</p><p><strong>Calendar 类中定义了许多常量，分别表示不同的意义。</strong></p><ul><li>Calendar.YEAR：年份。</li><li>Calendar.MONTH：月份。</li><li>Calendar.DATE：日期。</li><li>Calendar.DAY_OF_MONTH：日期，和上面的字段意义完全相同。</li><li>Calendar.HOUR：12小时制的小时。</li><li>Calendar.HOUR_OF_DAY：24 小时制的小时。</li><li>Calendar.MINUTE：分钟。</li><li>Calendar.SECOND：秒。</li><li>Calendar.DAY_OF_WEEK：星期几。</li></ul><p>例如要获取当前月份：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> month = Calendar.getInstance().get(Calendar.MONTH);</span><br></pre></td></tr></table></figure><p>方法都用用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Calendar calendar = Calendar.getInstance(); <span class="comment">// 如果不设置时间，则默认为当前时间</span></span><br><span class="line">calendar.setTime(<span class="keyword">new</span> Date()); <span class="comment">// 将系统当前时间赋值给 Calendar 对象</span></span><br><span class="line">System.out.println(<span class="string">"现在时刻："</span> + calendar.getTime()); <span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="keyword">int</span> year = calendar.get(Calendar.YEAR); <span class="comment">// 获取当前年份</span></span><br><span class="line">System.out.println(<span class="string">"现在是"</span> + year + <span class="string">"年"</span>);</span><br><span class="line"><span class="keyword">int</span> month = calendar.get(Calendar.MONTH) + <span class="number">1</span>; <span class="comment">// 获取当前月份（月份从 0 开始，所以加 1）</span></span><br><span class="line">System.out.print(month + <span class="string">"月"</span>);</span><br><span class="line"><span class="keyword">int</span> day = calendar.get(Calendar.DATE); <span class="comment">// 获取日</span></span><br><span class="line">System.out.print(day + <span class="string">"日"</span>);</span><br><span class="line"><span class="keyword">int</span> week = calendar.get(Calendar.DAY_OF_WEEK) - <span class="number">1</span>; <span class="comment">// 获取今天星期几（以星期日为第一天）</span></span><br><span class="line">System.out.print(<span class="string">"星期"</span> + week);</span><br><span class="line"><span class="keyword">int</span> hour = calendar.get(Calendar.HOUR_OF_DAY); <span class="comment">// 获取当前小时数（24 小时制）</span></span><br><span class="line">System.out.print(hour + <span class="string">"时"</span>);</span><br><span class="line"><span class="keyword">int</span> minute = calendar.get(Calendar.MINUTE); <span class="comment">// 获取当前分钟</span></span><br><span class="line">System.out.print(minute + <span class="string">"分"</span>);</span><br><span class="line"><span class="keyword">int</span> second = calendar.get(Calendar.SECOND); <span class="comment">// 获取当前秒数</span></span><br><span class="line">System.out.print(second + <span class="string">"秒"</span>);</span><br><span class="line"><span class="keyword">int</span> millisecond = calendar.get(Calendar.MILLISECOND); <span class="comment">// 获取毫秒数</span></span><br><span class="line">System.out.print(millisecond + <span class="string">"毫秒"</span>);</span><br><span class="line"><span class="keyword">int</span> dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH); <span class="comment">// 获取今天是本月第几天</span></span><br><span class="line">System.out.println(<span class="string">"今天是本月的第 "</span> + dayOfMonth + <span class="string">" 天"</span>);</span><br><span class="line"><span class="keyword">int</span> dayOfWeekInMonth = calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH); <span class="comment">// 获取今天是本月第几周</span></span><br><span class="line">System.out.println(<span class="string">"今天是本月第 "</span> + dayOfWeekInMonth + <span class="string">" 周"</span>);</span><br><span class="line"><span class="keyword">int</span> many = calendar.get(Calendar.DAY_OF_YEAR); <span class="comment">// 获取今天是今年第几天</span></span><br><span class="line">System.out.println(<span class="string">"今天是今年第 "</span> + many + <span class="string">" 天"</span>);</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.set(<span class="number">2008</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment">// 设置年月日，时分秒将默认采用当前值</span></span><br><span class="line">System.out.println(<span class="string">"设置日期为 2008-8-8 后的时间："</span> + c.getTime()); <span class="comment">// 输出时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/14/javabase13-szcl/sj3.png" alt="输出结果"></p><p>到后面会专门写个日历的博客，以现在的进度放在这里写有点不合适（先挖个坑）。</p><h2 id="三、日期格式化"><a href="#三、日期格式化" class="headerlink" title="三、日期格式化"></a>三、日期格式化</h2><p>大多数时候不能直接使用 Date 类提供的时间格式，Date 原时间格式用的最多的时候应该是写系统日志，这是专门给人看的，只要可以分辨就可以了。但是大多数业务逻辑下，时间都是要存入数据库，要通过时间来查询，如果直接存时间戳进去，数据库sql写着比较麻烦，还要转格式，比如我把日期用String格式存起来（20200214000000），写查询sql的时候就可以直接用了。</p><p>Java为我们提供了 DateFormat 类和它的子类 SimpleDateFormat 类来完成日期格式化，下面一起来看一看。</p><h3 id="DateFormat-类"><a href="#DateFormat-类" class="headerlink" title="DateFormat 类"></a>DateFormat 类</h3><p>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。将日期表示为 Date 对象，或者表示为从 GMT（格林尼治标准时间）1970 年 1 月 1 日 00:00:00 这一刻开始的毫秒数。 </p><p>因为是抽象类，所以也不能使用 new 来创建实例对象，使用静态类方法 getDateInstance() :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateFormat df = DateFormat.getDatelnstance();</span><br></pre></td></tr></table></figure><p>创建完对象，来看一下它的类方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String format(Date date)    将 Date 格式化日期/时间字符串</td><td></td></tr><tr><td>Calendar getCalendar()</td><td>获取与此日期/时间格式相关联的日历</td></tr><tr><td>static DateFormat getDateInstance()</td><td>获取具有默认格式化风格和默认语言环境的日期格式</td></tr><tr><td>static DateFormat getDateInstance(int style)</td><td>获取具有指定格式化风格和默认语言环境的日期格式</td></tr><tr><td>static DateFormat getDateInstance(int style,Locale locale)</td><td>获取具有指定格式化风格和指定语言环境的日期格式</td></tr><tr><td>static DateFormat getDateTimeInstance()</td><td>获取具有默认格式化风格和默认语言环境的日期/时间格式</td></tr><tr><td>static DateFormat getDateTimeInstance(int dateStyle,int timeStyle)</td><td>获取具有指定日期/时间格式化风格和默认语言环境的日期/时间格式</td></tr><tr><td>static DateFormat getDateTimeInstance(int dateStyle,int timeStyle,Locale locale)</td><td>获取具有指定日期/时间格式化风格和指定语言环境的日期/时间格式</td></tr><tr><td>static DateFormat getTimeInstance()</td><td>获取具有默认格式化风格和默认语言环境的时间格式</td></tr><tr><td>static DateFormat getTimeInstance(int style)</td><td>获取具有指定格式化风格和默认语言环境的时间格式</td></tr><tr><td>static DateFormat getTimeInstance(int style,Locale locale)</td><td>获取具有指定格式化风格和指定语言环境的时间格式</td></tr><tr><td>void setCalendar(Calendar newCalendar)</td><td>为此格式设置日历</td></tr><tr><td>Date parse(String source)</td><td>将给定的字符串解析成日期/时间</td></tr></tbody></table><p>格式化样式主要通过 DateFormat 常量设置。将不同的常量传入到表 1 所示的方法中，以控制结果的长度。DateFormat 类的常量如下。</p><ul><li>SHORT：完全为数字，如 12.5.10 或 5:30pm。</li><li>MEDIUM：较长，如 May 10，2016。</li><li>LONG：更长，如 May 12，2016 或 11:15:32am。</li><li>FULL：是完全指定，如 Tuesday、May 10、2012 AD 或 11:l5:42am CST。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取不同格式化风格和中国环境的日期</span></span><br><span class="line">DateFormat df1 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line">DateFormat df2 = DateFormat.getDateInstance(DateFormat.FULL, Locale.CHINA);</span><br><span class="line">DateFormat df3 = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.CHINA);</span><br><span class="line">DateFormat df4 = DateFormat.getDateInstance(DateFormat.LONG, Locale.CHINA);</span><br><span class="line"><span class="comment">// 获取不同格式化风格和中国环境的时间</span></span><br><span class="line">DateFormat df5 = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line">DateFormat df6 = DateFormat.getTimeInstance(DateFormat.FULL, Locale.CHINA);</span><br><span class="line">DateFormat df7 = DateFormat.getTimeInstance(DateFormat.MEDIUM, Locale.CHINA);</span><br><span class="line">DateFormat df8 = DateFormat.getTimeInstance(DateFormat.LONG, Locale.CHINA);</span><br><span class="line"><span class="comment">// 将不同格式化风格的日期格式化为日期字符串</span></span><br><span class="line">String date1 = df1.format(<span class="keyword">new</span> Date());</span><br><span class="line">String date2 = df2.format(<span class="keyword">new</span> Date());</span><br><span class="line">String date3 = df3.format(<span class="keyword">new</span> Date());</span><br><span class="line">String date4 = df4.format(<span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">// 将不同格式化风格的时间格式化为时间字符串</span></span><br><span class="line">String time1 = df5.format(<span class="keyword">new</span> Date());</span><br><span class="line">String time2 = df6.format(<span class="keyword">new</span> Date());</span><br><span class="line">String time3 = df7.format(<span class="keyword">new</span> Date());</span><br><span class="line">String time4 = df8.format(<span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">// 输出日期</span></span><br><span class="line">System.out.println(<span class="string">"SHORT："</span> + date1 + <span class="string">" "</span> + time1);</span><br><span class="line">System.out.println(<span class="string">"FULL："</span> + date2 + <span class="string">" "</span> + time2);</span><br><span class="line">System.out.println(<span class="string">"MEDIUM："</span> + date3 + <span class="string">" "</span> + time3);</span><br><span class="line">System.out.println(<span class="string">"LONG："</span> + date4 + <span class="string">" "</span> + time4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/14/javabase13-szcl/sj4.png" alt="输出结果"></p><p>虽然输出的时间更容易理解了，但是并不能达到要求，还需要更加定制化的时间格式，这时候就要有请 Calendar的儿子 SimpleDateFormat 类上场了。</p><h3 id="SimpleDateFormat-类"><a href="#SimpleDateFormat-类" class="headerlink" title="SimpleDateFormat 类"></a>SimpleDateFormat 类</h3><p>SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。</p><p>这个类是最常用的类了，至少我在格式化时间的时候都用它，功能强大，随心所欲。<br>SimpleDateFormat 有四个构造方法，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下三种构造依赖语言环境，可能无法适应特定的语言环境</span></span><br><span class="line">SimpleDateFormat sdf  = SimpleDateFormat();</span><br><span class="line">SimpleDateFormat sdf  = SimpleDateFormat(String pattern);</span><br><span class="line">SimpleDateFormat sdf  = SimpleDateFormat(String pattern,Locale locale);</span><br><span class="line"><span class="comment">//用给定的模式和日期符号构造 SimpleDateFormat。</span></span><br><span class="line">SimpleDateFormat sdf  = SimpleDateFormat(String pattern,DateFormatSymbols formatSymbols);</span><br></pre></td></tr></table></figure><p>要用文本解析时间或者时间解析文本就要有文本规范，不能随便写，SimpleDateFormat 解析文本通过字母符号组成的文本，字母文本都比较好记：</p><p><img src="/2020/02/14/javabase13-szcl/sjzm.png" alt="字母意义与示例"></p><p>以及解析字符串的例子，以美国时间模式为例（这就是上面说的语言环境）：</p><p><img src="/2020/02/14/javabase13-szcl/sjzfc.png" alt="字符串解析示例"></p><p>我们举一个最常用到方法的例子， 按2020-02-14 12:00:00 形式输出当前时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String time = df.format(d);</span><br><span class="line">System.out.print(time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase13-szcl/now.png" alt="运行结果">  </p><p>只要记住大小写字母代表的意义就可以了，记不住差文档也可以，反正这种时间格式化的代码不会天天写，而且现在有专门时间格式化的开源包，比如我用过的 <a href="https://www.joda.org/joda-time/userguide.html">JodaTime</a> ,感兴趣可以了解一下，虽然自己不用处理时间，但是我还是感觉 时间统一用 “ yyyyMMddHHmmss “这种格式简单粗暴，省了好多事。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>时间处理知道这些足够了，忘了就翻文档，搜博客，还有一种需求是求特定的哪一天是周几啊，距离现在几天啊这种。这就是思想延伸的东西了，这里就不介绍了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在开发中做数据持久化时常常需要统一的时间格式，统一查询口径，方便查询，Java提供了日期处理类 Date 和 Calendar ，Date类封装了系统时间，Calendar 根据系统日历解释 Date 对象，两个类处理时间的思路不一样。&lt;strong&gt;本篇内容包括：Date 类与 Calendar 类使用介绍，日期格式化&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java时间日期处理" scheme="http://www.mggblog.ink/tags/Java%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十二）——数字处理类（Math，Random，BigInteger，BigDecimal）</title>
    <link href="http://www.mggblog.ink/2020/02/13/javabase12-math/"/>
    <id>http://www.mggblog.ink/2020/02/13/javabase12-math/</id>
    <published>2020-02-13T11:52:36.456Z</published>
    <updated>2020-02-21T01:12:05.290Z</updated>
    
    <content type="html"><![CDATA[<p><em>只用四则运算符无法完成三角、对数、指数等复杂运算，以及非常大的数字运算，Java提供Math等类解决问题，<strong>本篇内容有：Math类常用方法，随机数生成，数字格式化，大数字运算。</strong></em></p><a id="more"></a><hr><h2 id="一、Math类常用方法"><a href="#一、Math类常用方法" class="headerlink" title="一、Math类常用方法"></a>一、Math类常用方法</h2><p>挑一些经常用到的，有静态常量（自然数e，圆周率π）、求最大最小值和绝对值、求整、三角函数、指数运算，其实最常用的就是最大最小值和求整了。</p><h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><p>自然数e和圆周率π：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//e</span></span><br><span class="line">Math.E;</span><br><span class="line"><span class="comment">//π</span></span><br><span class="line">Math.PI;</span><br></pre></td></tr></table></figure><p>控制台输出看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"e="</span>+Math.E);</span><br><span class="line">System.out.println(<span class="string">"π="</span>+Math.PI);</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/epi.png" alt="输出结果"></p><h2 id="二、求最大最小值和绝对值"><a href="#二、求最大最小值和绝对值" class="headerlink" title="二、求最大最小值和绝对值"></a>二、求最大最小值和绝对值</h2><p>最常用功能，几个函数搞定，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.方法名;</span><br></pre></td></tr></table></figure><p>函数与说明：   </p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>static int abs(int a)</td><td>返回 a 的绝对值</td></tr><tr><td>static long abs(long a)</td><td>返回 a 的绝对值</td></tr><tr><td>static float abs(float a)</td><td>返回 a 的绝对值</td></tr><tr><td>static double abs(double a)</td><td>返回 a 的绝对值</td></tr><tr><td>static int max(int x,int y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static double max(double x,double y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static long max(long x,long y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static float max(float x,float y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static int min(int x,int y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static long min(long x,long y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static double min(double x,double y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static float min(float x,float y)</td><td>返回 x 和 y 中的最小值</td></tr></tbody></table><p>实践一下，分别求一下最大值最小值与绝对值：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">29</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">98</span>;</span><br><span class="line">  <span class="keyword">int</span> k = -<span class="number">200</span>;</span><br><span class="line">  System.out.println(Math.max(i, j));</span><br><span class="line">  System.out.println(Math.min(i, j));</span><br><span class="line">  System.out.println(Math.abs(k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/jd.png" alt="输出结果"></p><h3 id="求整运算"><a href="#求整运算" class="headerlink" title="求整运算"></a>求整运算</h3><p>多用在需要不要求高精度数据展示的时候，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.方法名;</span><br></pre></td></tr></table></figure><p>函数与说明：  </p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>static double ceil(double a)</td><td>返回大于或等于 a 的最小整数</td></tr><tr><td>static double floor(double a)</td><td>返回小于或等于 a 的最大整数</td></tr><tr><td>static double rint(double a)</td><td>返回最接近 a 的整数值，如果有两个同样接近的整数，则结果取偶数</td></tr><tr><td>static int round(float a)</td><td>将参数加上 1/2 后返回与参数最近的整数</td></tr><tr><td>static long round(double a)</td><td>将参数加上 1/2 后返回与参数最近的整数，然后强制转换为长整型</td></tr></tbody></table><p>实践一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      <span class="keyword">double</span> num = input.nextDouble();</span><br><span class="line">      System.out.println(<span class="string">"大于或等于 "</span>+ num +<span class="string">" 的最小整数："</span> + Math.ceil(num));</span><br><span class="line">      System.out.println(<span class="string">"小于或等于 "</span>+ num +<span class="string">" 的最大整数："</span> + Math.floor(num));</span><br><span class="line">      System.out.println(<span class="string">"将 "</span>+ num +<span class="string">" 加上 0.5 之后最接近的整数："</span> + Math.round(num));</span><br><span class="line">      System.out.println(<span class="string">"最接近 "</span>+num+<span class="string">" 的整数："</span> + Math.rint(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/qz.png" alt="输出结果"></p><h3 id="三角函数运算"><a href="#三角函数运算" class="headerlink" title="三角函数运算"></a>三角函数运算</h3><p>大概要做加密，或者数学运算软件才会用到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.方法名;</span><br></pre></td></tr></table></figure><p>函数与说明：   </p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>static double sin(double a)</td><td>返回角的三角正弦值，参数以孤度为单位</td></tr><tr><td>static double cos(double a)</td><td>返回角的三角余弦值，参数以孤度为单位</td></tr><tr><td>static double asin(double a)</td><td>返回一个值的反正弦值，参数域在 [-1,1]，值域在 [-PI/2,PI/2]</td></tr><tr><td>static double acos(double a)</td><td>返回一个值的反余弦值，参数域在 [-1,1]，值域在 [0.0,PI]</td></tr><tr><td>static double tan(double a)</td><td>返回角的三角正切值，参数以弧度为单位</td></tr><tr><td>static double atan(double a)</td><td>返回一个值的反正切值，值域在 [-PI/2,PI/2]</td></tr><tr><td>static double toDegrees(double angrad)</td><td>将用孤度表示的角转换为近似相等的用角度表示的角</td></tr><tr><td>staticdouble toRadians(double angdeg)</td><td>将用角度表示的角转换为近似相等的用弧度表示的角</td></tr></tbody></table><p>来实践一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  System.out.println(<span class="string">"90 度的正弦值："</span> + Math.sin(Math.PI/<span class="number">2</span>));</span><br><span class="line">      System.out.println(<span class="string">"0 度的余弦值："</span> + Math.cos(<span class="number">0</span>));</span><br><span class="line">      System.out.println(<span class="string">"0.5 的反正切值："</span> + Math.atan(<span class="number">0.5</span>));</span><br><span class="line">      System.out.println(<span class="string">"120 度的弧度值："</span> + Math.toRadians(<span class="number">120.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/pi.png" alt="输出结果"></p><h3 id="指数与对数运算"><a href="#指数与对数运算" class="headerlink" title="指数与对数运算"></a>指数与对数运算</h3><p>也是很少用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.方法名;</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static double exp(double a)</td><td>返回 e 的 a 次幂</td></tr><tr><td>static double pow(double a,double b)</td><td>返回以 a 为底数，以 b 为指数的幂值</td></tr><tr><td>static double sqrt(double a)</td><td>返回 a 的平方根</td></tr><tr><td>static double cbrt(double a)</td><td>返回 a 的立方根</td></tr><tr><td>static double log(double a)</td><td>返回 a 的自然对数，即 lna 的值</td></tr><tr><td>static double log10(double a)</td><td>返回以 10 为底 a 的对数</td></tr></tbody></table><p>实践一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">"2 的立方值："</span> + Math.pow(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">      System.out.println(<span class="string">"10 的平方根："</span> + Math.sqrt(<span class="number">10</span>));</span><br><span class="line">      System.out.println(<span class="string">"10 为底 2 的对数："</span> + Math.log10(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/log.png" alt="输出结果"></p><blockquote><p>观察发现Java并没有提供log a（b）的方法，因为Java提供的两个对数方法已经足够计算机算对数用了，如果需要计算普通对数，可以变通一下，利用高中数学里用到的换底公式，log a (b) = log n (b) / log n (a) ,把 n 代为自然数 e 就可以了,当然log10()也是可以的。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">  &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">    System.out.println(&quot;8 为底 2 的对数：&quot; + (Math.log(8) &#x2F; Math.log(2))); &#x2F;&#x2F; 3.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、随机数生成"><a href="#三、随机数生成" class="headerlink" title="三、随机数生成"></a>三、随机数生成</h2><p>随机数也是非常常用的功能，比如需要从数据库随机抓取数据，Java中的 Random 类提供众多生成随机数的方法，另外 Math 类也提供了一个生成随机数的方法 Math.random()，还有一种野路子，使用 currentTimeMillis（时间处理会用到，可以先了解一下） 获取毫秒值 取模生成随机数。一般情况下生成整数随机数的需求比较多一点。</p><h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h3><p>如果只是随便生成一个 float 随机数，那用这个是非常合适的选择，因为 Math 是静态类，不用new 来新建对象。这个方法返回带正号的 double 值，该值大于等于 0.0 且小于 1.0，但是可以通过乘法来扩大数值，然后通过加减运算再取整函数来获得一个符合预期的随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  System.out.println(Math.random()); <span class="comment">//0.24037287785722083</span></span><br><span class="line">  <span class="comment">//比如我想要一个100 以内的随机数</span></span><br><span class="line">  System.out.println((<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>)); <span class="comment">//39</span></span><br><span class="line">  <span class="comment">//想得到一个50-100的随机数</span></span><br><span class="line">  System.out.println((<span class="keyword">int</span>)(<span class="number">50</span>+(Math.random()*(<span class="number">100</span>-<span class="number">50</span>)))); <span class="comment">//68</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论是这个方法取随机还是用 Random类 生成特定范围内的随机数，算法都是一样的 <strong>( int )(min + ( 方法 *( max - main )))</strong> 。用 currentTimeMillis() 略有不同 把中间乘号改为取模( % )。</p></blockquote><h3 id="Random-类方法"><a href="#Random-类方法" class="headerlink" title="Random 类方法"></a>Random 类方法</h3><p>Random 类为我们提供了整套的随机数生成方案，足够日常业务需求使用。打开JDK帮助文档看看吧（变懒了不想手写表格了），首先是用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先需要新建 Random 对象</span></span><br><span class="line">Random rd = newRandom();</span><br><span class="line"><span class="comment">//重载构造 带种子的对象</span></span><br><span class="line">Random rd = newRandom(<span class="keyword">long</span> seed);</span><br><span class="line"><span class="comment">//然后调用方法</span></span><br><span class="line">类型 变量名 = rd.方法;</span><br></pre></td></tr></table></figure><p>看图：<br><img src="/2020/02/13/javabase12-math/rd.png" alt="random 类"></p><p>方法不做详细说明等会直接写个demo，说一下这个种子是什么鬼。种子在这里可能是翻译问题，用标识说更贴切，如 new Random(1) 当运行的时候用 1 的标识生成的随机数，即使再运行也不会变；如果是 new Random() 同个方法每次运行生成的随机数都会不一样。  </p><p>把这段代码运行两次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  Random rd1 = <span class="keyword">new</span> Random(<span class="number">1</span>);</span><br><span class="line">  Random rd2 = <span class="keyword">new</span> Random();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    System.out.print(rd1.nextInt(<span class="number">100</span>)+<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"\n~~~~~~~~~~~~~~"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    System.out.print(rd2.nextInt(<span class="number">100</span>)+<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行第一次<br><img src="/2020/02/13/javabase12-math/r1.png" alt="第一次"><br>运行第二次<br><img src="/2020/02/13/javabase12-math/r2.png" alt="第二次">  </p><p>看到使用种子创建对象的类方法产生的随机数是一样的，在实际使用的时候还是不带种子的多一些。</p><p>把其他方法都跑一下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  Random r = <span class="keyword">new</span> Random();</span><br><span class="line">  <span class="keyword">double</span> d1 = r.nextDouble(); <span class="comment">// 生成[0,1.0]区间的小数</span></span><br><span class="line">  <span class="keyword">double</span> d2 = r.nextDouble() * <span class="number">7</span>; <span class="comment">// 生成[0,7.0]区间的小数</span></span><br><span class="line">  <span class="keyword">int</span> i1 = r.nextInt(<span class="number">10</span>); <span class="comment">// 生成[0,10]区间的整数</span></span><br><span class="line">  <span class="keyword">int</span> i2 = r.nextInt(<span class="number">18</span>) - <span class="number">3</span>; <span class="comment">// 生成[-3,15]区间的整数</span></span><br><span class="line">  <span class="keyword">long</span> l1 = r.nextLong(); <span class="comment">// 生成一个随机长整型值</span></span><br><span class="line">  <span class="keyword">boolean</span> b1 = r.nextBoolean(); <span class="comment">// 生成一个随机布尔型值</span></span><br><span class="line">  <span class="keyword">float</span> f1 = r.nextFloat(); <span class="comment">// 生成一个随机浮点型值</span></span><br><span class="line">  System.out.println(<span class="string">"生成的[0,1.0]区间的小数是："</span> + d1);</span><br><span class="line">  System.out.println(<span class="string">"生成的[0,7.0]区间的小数是："</span> + d2);</span><br><span class="line">  System.out.println(<span class="string">"生成的[0,10]区间的整数是："</span> + i1);</span><br><span class="line">  System.out.println(<span class="string">"生成的[-3,15]区间的整数是："</span> + i2);</span><br><span class="line">  System.out.println(<span class="string">"生成一个随机长整型值："</span> + l1);</span><br><span class="line">  System.out.println(<span class="string">"生成一个随机布尔型值："</span> + b1);</span><br><span class="line">  System.out.println(<span class="string">"生成一个随机浮点型值："</span> + f1);</span><br><span class="line">  System.out.print(<span class="string">"下期七星彩开奖号码预测："</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = r.nextInt(<span class="number">9</span>); <span class="comment">// 生成[0,9]区间的整数</span></span><br><span class="line">    System.out.print(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/sj.png" alt="运行结果"></p><h3 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h3><p>这是个牛逼的野路子，大佬的思路我不懂，一般也不会用这个，不详细说了，举个例子带过吧。</p><p>方法返回从1970年1月1日0时0分0秒（这与UNIX系统有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">100</span>, min = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">long</span> randomNum = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">int</span> ran3 = (<span class="keyword">int</span>) (randomNum % (max - min) + min);</span><br><span class="line">  System.out.println(ran3);<span class="comment">// 60</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、数字格式化"><a href="#四、数字格式化" class="headerlink" title="四、数字格式化"></a>四、数字格式化</h2><p>数字的格式在解决实际问题时使用非常普遍，这时可以使用 DecimalFormat 类对结果进行格式化处理。例如，将小数位统一成 2 位，不足 2 位的以 0 补齐。<br>DecimalFormat 是 NumberFormat 的一个子类，用于格式化十进制数字。DecimalFormat 类包含一个模式和一组符号，常用符号看图<br><img src="/2020/02/13/javabase12-math/sjgs.png" alt="常用符号"><br>举个例子：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化DecimalFormat类的对象，并指定格式</span></span><br><span class="line">  DecimalFormat df1 = <span class="keyword">new</span> DecimalFormat(<span class="string">"0.0"</span>);</span><br><span class="line">  DecimalFormat df2 = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.#"</span>);</span><br><span class="line">  DecimalFormat df3 = <span class="keyword">new</span> DecimalFormat(<span class="string">"000.000"</span>);</span><br><span class="line">  DecimalFormat df4 = <span class="keyword">new</span> DecimalFormat(<span class="string">"###.###"</span>);</span><br><span class="line">  Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">  System.out.print(<span class="string">"请输入一个float类型的数字："</span>);</span><br><span class="line">  <span class="keyword">float</span> f = scan.nextFloat();</span><br><span class="line">  <span class="comment">// 对输入的数字应用格式，并输出结果</span></span><br><span class="line">  System.out.println(<span class="string">"0.0 格式："</span> + df1.format(f));</span><br><span class="line">  System.out.println(<span class="string">"#.# 格式："</span> + df2.format(f));</span><br><span class="line">  System.out.println(<span class="string">"000.000 格式："</span> + df3.format(f));</span><br><span class="line">  System.out.println(<span class="string">"###.### 格式："</span> + df4.format(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/sjgsh.png" alt="运行结果"></p><h2 id="五、大数字运算"><a href="#五、大数字运算" class="headerlink" title="五、大数字运算"></a>五、大数字运算</h2><p>Java提供两个类进行大数字处理，BigInteger 类和 BigDecimal 类，解决 int 范围问题（任何数字数据类型都有范围 Java中 int 是-2147483648 ~ 2147483647 这和计算机二进制补码计算有关，感兴趣可以了解一下，用2147483647+1看看会得到什么结果）。</p><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>使用方法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象  val 是十进制数字 但是注意参数格式是字符串</span></span><br><span class="line">BigInteger bi = BigInteger(String val)</span><br></pre></td></tr></table></figure><p>文档里方法太多了我挑些常用的方法（和 int不同的地方在于不能使用运算符计算，要用方法计算）：<br><img src="/2020/02/13/javabase12-math/bi.png" alt="BigInteger 类方法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">"999999999999999"</span>);</span><br><span class="line">    <span class="comment">// 加一</span></span><br><span class="line">    System.out.println(<span class="string">"加1结果："</span> + bi.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/bi1.png" alt="运行结果"></p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>BigDecimal 多用于算钱，在数量较大时又能保证高精度（支持任何精度），比 BigInteger 更为实用，用法和 BigInteger 基本一样，先建对象，再使用方法计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象  val 是十进制数字 但是注意参数格式是字符串</span></span><br><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(String val)</span><br></pre></td></tr></table></figure><p>计算方法(文档里太难看了我放到excel)：<br><img src="/2020/02/13/javabase12-math/bdjs.png" alt="加减乘除"><br>其中，divide() 方法的 3 个参数分别表示除数、商的小数点后的位数和近似值处理模式。</p><p>BigDecimal 还提供了计算模式，各种模式满足你算钱的需求（看了文档才知道这么厉害，我以前也就用它加加减减）：<br><img src="/2020/02/13/javabase12-math/bdjsms.png" alt="计算模式"></p><p>举个例子描述结束今天的学习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  BigDecimal bi = <span class="keyword">new</span> BigDecimal(<span class="string">"999999999999999.345678"</span>);</span><br><span class="line">  <span class="comment">// 加法</span></span><br><span class="line">  System.out.println(<span class="string">"加法结果："</span> + bi.add(<span class="keyword">new</span> BigDecimal(<span class="string">"1.3465"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/bdjf.png" alt="运行结果"></p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>这些内容可以分俩博客讲的，但是我觉得东西不多，就直接塞一块儿了，夜深了，睡觉了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;只用四则运算符无法完成三角、对数、指数等复杂运算，以及非常大的数字运算，Java提供Math等类解决问题，&lt;strong&gt;本篇内容有：Math类常用方法，随机数生成，数字格式化，大数字运算。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数字处理" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十一）——Java正则表达式</title>
    <link href="http://www.mggblog.ink/2020/02/13/javabase11-zzbds/"/>
    <id>http://www.mggblog.ink/2020/02/13/javabase11-zzbds/</id>
    <published>2020-02-13T01:55:42.000Z</published>
    <updated>2020-02-21T01:12:04.498Z</updated>
    
    <content type="html"><![CDATA[<p><em>Java正则表达式也是字符串处理的内容，但是并不几个方法就能说清楚的，所以单独拿出来说一说。正则表达式多用于数据筛选，数据验证等，重要且用途广泛。但是Java正则表达式内容很多，以我的三脚猫功夫怕是讲不出个所以然，在我看博客学正则时看到一个几万字的博客，虽然他也是转载的吧，<a href="https://www.cnblogs.com/xyou/p/7427779.html">正则表达式详解</a>,作为初学者只需要记住几个常见的正则写法：电话，邮箱，用户名，密码，等真的需要考虑特别复杂情况的正则时再翻书学习，因为并不是天天写正则，现在学个大概，到用时差不多也忘光了。本篇大量引用了<a href="http://c.biancheng.net/view/5812.html">c语言中文网-Java正则表达式</a>,同时推荐去看一下<a href="https://www.runoob.com/java/java-regular-expressions.html">菜鸟教程。</a></em></p><a id="more"></a><hr><p>正则表达式（regex）由普通字符与特殊字符组成，用来匹配一个或多个字符，如：”^\d+(.\d+)?”,可以匹配带小数点的数。</p><p>String 类提供了几个特殊的字符串匹配方法，这些方法依赖于Java对正则表达式的支持：</p><ul><li>boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。</li><li>String replaceAll(String regex, String replacement)：将该字符串中所有匹配 regex 的子串替换成 replacement。</li><li>String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配 regex 的子串替换成 replacement。</li><li>String[] split(String regex)：以 regex 作为分隔符，把该字符串分割成多个子串。</li></ul><p>上面举的匹配小数的正则表达式例子看上去很复杂，其实并不复杂，随便一个字符串就是一个正则表达式，如”abc”，只是它只能匹配”abc”而已，功能强大的正则表达式，只是一个特殊的字符串，那应该如何创建正则表达式呢？</p><h2 id="正则表达式的构成"><a href="#正则表达式的构成" class="headerlink" title="正则表达式的构成"></a>正则表达式的构成</h2><ol><li>组成正则表达式的合法字符<table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>字符x（x 可代表任何合法的字符)</td></tr><tr><td>\0mnn</td><td>八进制数 0mnn 所表示的字符</td></tr><tr><td>\xhh</td><td>十六进制值 0xhh 所表示的字符</td></tr><tr><td>\uhhhh</td><td>十六进制值 0xhhhh 所表示的 Unicode 字符</td></tr><tr><td>\t</td><td>制表符（“\u0009”）</td></tr><tr><td>\n</td><td>新行（换行）符（‘\u000A’）</td></tr><tr><td>\r</td><td>回车符（‘\u000D’)</td></tr><tr><td>\f</td><td>换页符（‘\u000C’）</td></tr><tr><td>\a</td><td>报警（bell）符（‘\u0007’）</td></tr><tr><td>\e</td><td>Escape 符（‘\u001B’）</td></tr><tr><td>\cx</td><td>x 对应的的控制符。例如，\cM匹配 Ctrl-M。x 值必须为 A~Z 或 a~z 之一。</td></tr></tbody></table></li><li>特殊字符，使用特殊字符时要加转义字符“\”<table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>匹配一行的结尾。要匹配 $ 字符本身，请使用\$</td></tr><tr><td>^</td><td>匹配一行的开头。要匹配 ^ 字符本身，请使用\^</td></tr><tr><td>()</td><td>标记子表达式的开始和结束位置。要匹配这些字符，请使用\(和\)</td></tr><tr><td>[]</td><td>用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用\[和\]</td></tr><tr><td>{}</td><td>用于标记前面子表达式的出现频度。要匹配这些字符，请使用\{和\}</td></tr><tr><td>*</td><td>指定前面子表达式可以出现零次或多次。要匹配 * 字符本身，请使用\*</td></tr><tr><td>+</td><td>指定前面子表达式可以出现一次或多次。要匹配 + 字符本身，请使用\+</td></tr><tr><td>?</td><td>指定前面子表达式可以出现零次或一次。要匹配 ？字符本身，请使用\?</td></tr><tr><td>.</td><td>匹配除换行符\n之外的任何单字符。要匹配.字符本身，请使用.</td></tr><tr><td>\</td><td>用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配\字符，请用\\</td></tr><tr><td>|</td><td>指定两项之间任选一项。如果要匹配丨字符本身，请使用\|</td></tr></tbody></table></li><li>上面所说的只能匹配单个字符，通配符让正则表达式真正的强大起来。<table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\.</td><td>可以匹配任何字符</td></tr><tr><td>\d</td><td>匹配 0~9 的所有数字</td></tr><tr><td>\D</td><td>匹配非数字</td></tr><tr><td>\s</td><td>匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等</td></tr><tr><td>\S</td><td>匹配所有的非空白字符</td></tr><tr><td>\w</td><td>匹配所有的单词字符，包括 0~9 所有数字、26 个英文字母和下画线_</td></tr><tr><td>\W</td><td>匹配所有的非单词字符</td></tr></tbody></table></li></ol><p>上面的 7 个预定义字符其实很容易记忆，其中：</p><ul><li>d 是 digit 的意思，代表数字。</li><li>s 是 space 的意思，代表空白。</li><li>w 是 word 的意思，代表单词。</li><li>d、s、w 的大写形式恰好匹配与之相反的字符。<br>举个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c\\wt    <span class="comment">// 可以匹配cat、cbt、cct、cOt、c9t等一批字符串</span></span><br><span class="line">\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d    <span class="comment">// 匹配如 000-000-0000 形式的电话号码</span></span><br></pre></td></tr></table></figure>在一些特殊情况下，例如，若只想匹配 a~f 的字母，或者匹配除 ab 之外的所有小写字母，或者匹配中文字符，上面这些预定义字符就无能为力了，此时就需要使用方括号表达式，方括号表达式有几种形式。<table><thead><tr><th>方括号表达式</th><th>说明</th></tr></thead><tbody><tr><td>表示枚举</td><td>例如[abc]表示 a、b、c 其中任意一个字符；[gz]表示 g、z 其中任意一个字符</td></tr><tr><td>表示范围：-</td><td>例如[a-f]表示 a~f 范围内的任意字符；[\u0041-\u0056]表示十六进制字符 \u0041 到 \u0056 范围的字符。范围可以和枚举结合使用，如[a-cx-z]，表示 a~c、x~z 范围内的任意字符</td></tr><tr><td>表示求否：^</td><td>例如[^abc]表示非 a、b、c 的任意字符；[^a-f]表示不是 a~f 范围内的任意字符</td></tr><tr><td>表示“与”运算：&amp;&amp;</td><td>例如 [a-z&amp;&amp;[def]]是 a~z 和 [def] 的交集，表示 d、e f[a-z&amp;&amp;^bc]]是 a~z 范围内的所有字符，除 b 和 c 之外 [ad-z] [a-z&amp;&amp;[m-p]]是 a~z 范围内的所有字符，除 m~p 范围之外的字符</td></tr><tr><td>表示“并”运算</td><td>并运算与前面的枚举类似。例如[a-d[m-p]]表示 [a-dm-p]</td></tr></tbody></table></li></ul><p>方括号表达式比前面的预定义字符灵活多了，几乎可以匹配任何字符。例如，若需要匹配所有的中文字符，就可以利用 [\u0041-\u0056] 形式——因为所有中文字符的 Unicode 值是连续的，只要找出所有中文字符中最小、最大的 Unicode 值，就可以利用上面形式来匹配所有的中文字符。</p><p>正则表达式还支持圆括号，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符|。例如，正则表达式“((public)|(protected)|(private))”用于匹配 Java 的三个访问控制符其中之一。</p><p>除此之外，Java 正则表达式还支持几个边界匹配符:</p><table><thead><tr><th>边界匹配符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>行的开头</td></tr><tr><td>$</td><td>行的结尾</td></tr><tr><td>\b</td><td>单词的边界</td></tr><tr><td>\B</td><td>非单词的边界</td></tr><tr><td>\A</td><td>输入的开头</td></tr><tr><td>\G</td><td>前一个匹配的结尾</td></tr><tr><td>\Z</td><td>输入的结尾，仅用于最后的结束符</td></tr><tr><td>\z</td><td>输入的结尾</td></tr></tbody></table><p>前面例子中需要建立一个匹配 000-000-0000 形式的电话号码时，使用了 \d\d\d-\d\d\d-\d\d\d\d 正则表达式，这看起来比较烦琐。实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。</p><ul><li>Greedy（贪婪模式）：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。</li><li>Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。</li><li>Possessive（占有模式）：用加号后缀（+）表示，目前只有 Java 支持占有模式，通常比较少用。</li></ul><p>如图：<br><img src="/2020/02/13/javabase11-zzbds/szms.png" alt="三种模式的数量表示符"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"hello,java!"</span>;</span><br><span class="line"><span class="comment">// 贪婪模式的正则表达式</span></span><br><span class="line">System.out.println(str.replaceFirst(<span class="string">"\\w*"</span> , <span class="string">"■"</span>));    <span class="comment">//输出■,java!</span></span><br><span class="line"><span class="comment">// 勉强模式的正则表达式</span></span><br><span class="line">System.out.println(str.replaceFirst(<span class="string">"\\w*?"</span> , <span class="string">"■"</span>)); <span class="comment">//输出■hello, java!</span></span><br></pre></td></tr></table></figure><p>当从“hello java!”字符串中查找匹配\w<em>子串时，因为\w</em>使用了贪婪模式，数量表示符<em>会一直匹配下去，所以该字符串前面的所有单词字符都被它匹配到，直到遇到空格，所以替换后的效果是“■，Java!”；如果使用勉强模式，数量表示符</em>会尽量匹配最少字符，即匹配 0 个字符，所以替换后的结果是“■hello，java!”。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>这正则表达式文章让我自己写，我还很菜，写不出来，所以参考了其他博客的文章，毕竟我写代码一年多，还没用到过比较复杂的正则表达式，而且一般正则表达式可以在百度搜出来，但是又不能不写这内容，我自己这段时间学一学，学成回来补充或者重写本篇。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Java正则表达式也是字符串处理的内容，但是并不几个方法就能说清楚的，所以单独拿出来说一说。正则表达式多用于数据筛选，数据验证等，重要且用途广泛。但是Java正则表达式内容很多，以我的三脚猫功夫怕是讲不出个所以然，在我看博客学正则时看到一个几万字的博客，虽然他也是转载的吧，&lt;a href=&quot;https://www.cnblogs.com/xyou/p/7427779.html&quot;&gt;正则表达式详解&lt;/a&gt;,作为初学者只需要记住几个常见的正则写法：电话，邮箱，用户名，密码，等真的需要考虑特别复杂情况的正则时再翻书学习，因为并不是天天写正则，现在学个大概，到用时差不多也忘光了。本篇大量引用了&lt;a href=&quot;http://c.biancheng.net/view/5812.html&quot;&gt;c语言中文网-Java正则表达式&lt;/a&gt;,同时推荐去看一下&lt;a href=&quot;https://www.runoob.com/java/java-regular-expressions.html&quot;&gt;菜鸟教程。&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十）——字符串处理（3）</title>
    <link href="http://www.mggblog.ink/2020/02/12/javabase10-zfccl3/"/>
    <id>http://www.mggblog.ink/2020/02/12/javabase10-zfccl3/</id>
    <published>2020-02-12T13:49:55.000Z</published>
    <updated>2020-02-21T01:12:03.688Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>本篇内容：字符串的比较和查找。</strong>字符串比较在代码中非常常见，多用于判断和验证，如根据字符串内容执行不同的代码，验证是否符合逻辑规则否则抛出异常等等，下面根据实际方法来说一下。</em></p><a id="more"></a><hr><h2 id="一、字符串比较"><a href="#一、字符串比较" class="headerlink" title="一、字符串比较"></a>一、字符串比较</h2><p>字符串比较是否相等，比较大小，比较前缀后缀，非常常见，Java为我们提供了三个字符串比较方法，分别是equals() 方法、equalsIgnoreCase() 方法、 compareTo() 方法，方法的返回值都是布尔类型（boolean），下面分开介绍。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>只比较两个字符串的值是否相等，用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1.equals(str2);</span><br></pre></td></tr></table></figure><p>比如小羊们需要验证是谁在敲门：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">  String str = input.nextLine();</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">"mother"</span>.equals(str)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"open the door"</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"call 110"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/12/javabase10-zfccl3/xy.png" alt="是妈妈，开门"></p><blockquote><p><strong>这里我们说一下 equals() 与 “ == “的区别，equals() 比较的是字符串的内容，而” == “比较的是对象实例，使用” == “比较两个对象即使字符串相同，返回结果也会是 false，简言之基础类型用==，String 类型用 equals()。举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"><span class="comment">//基础类型数据使用 == 比较</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(i == j); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/javabase10-zfccl3/ccc.png" alt="运行结果"></p></blockquote><h3 id="equalsIgnoreCase"><a href="#equalsIgnoreCase" class="headerlink" title="equalsIgnoreCase()"></a>equalsIgnoreCase()</h3><p>本方法与 equals() 用法形式相同，用法区别于笨方法不区分大小写，我想不需要举例解释了吧。</p><h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h3><p>比较两个字符串谁大谁小，形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.compareTo(String otherstr);</span><br></pre></td></tr></table></figure><p>str 值在参数 otherstr 值前 结果为负，否则为正，两个字符串相等结果为零，举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str1 = <span class="string">"abc"</span>;</span><br><span class="line">  System.out.println(str1.compareTo(<span class="string">"bcd"</span>));</span><br><span class="line">  System.out.println(str1.compareTo(<span class="string">"abc"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/12/javabase10-zfccl3/ct.png" alt="结果"></p><h2 id="二、字符串查找"><a href="#二、字符串查找" class="headerlink" title="二、字符串查找"></a>二、字符串查找</h2><p>String 类的 indexOf() 方法和 lastlndexOf() 方法用于在字符串中获取匹配字符（串）的索引值。</p><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>indexOf() 方法用于返回字符（串）在指定字符串中首次出现的索引位置，如果能找到，则返回索引值，否则返回 -1。该方法主要有两种重载形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.indexOf(value);</span><br><span class="line">str.indexOf(value,<span class="keyword">int</span> fromIndex);</span><br></pre></td></tr></table></figure><p>其中，str 表示指定字符串；value 表示待查找的字符（串）；fromIndex 表示查找时的起始索引，如果不指定 fromIndex，则默认从指定字符串中的开始位置（即 fromIndex 默认为 0）开始查找。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str = <span class="string">"hello world"</span>;</span><br><span class="line">  <span class="keyword">int</span> i = str.indexOf(<span class="string">"o"</span>);</span><br><span class="line">  <span class="keyword">int</span> j = str.indexOf(<span class="string">"o"</span>,<span class="number">5</span>);</span><br><span class="line">  System.out.println(i);</span><br><span class="line">  System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/javabase10-zfccl3/i2.png" alt="结果"></p><h3 id="lastlndexOf"><a href="#lastlndexOf" class="headerlink" title="lastlndexOf()"></a>lastlndexOf()</h3><p>lastIndexOf() 方法用于返回字符（串）在指定字符串中最后一次出现的索引位置，如果能找到则返回索引值，否则返回 -1。该方法也有两种重载形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.lastIndexOf(value)</span><br><span class="line">str.lastlndexOf(value, <span class="keyword">int</span> fromIndex)</span><br></pre></td></tr></table></figure><p>lastIndexOf() 方法的查找策略是从右往左查找，如果不指定起始索引，则默认从字符串的末尾开始查找。举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str = <span class="string">"hello world"</span>;</span><br><span class="line">  <span class="keyword">int</span> i = str.lastIndexOf(<span class="string">"o"</span>);</span><br><span class="line">  <span class="keyword">int</span> j = str.lastIndexOf(<span class="string">"o"</span>,<span class="number">5</span>);</span><br><span class="line">  System.out.println(i);</span><br><span class="line">  System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/javabase10-zfccl3/i3.png" alt="结果"></p><h3 id="补充：根据索引查找"><a href="#补充：根据索引查找" class="headerlink" title="补充：根据索引查找"></a>补充：根据索引查找</h3><p>String 类的 charAt() 方法可以在字符串内根据指定的索引查找字符，形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.charAt(<span class="keyword">int</span> index);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str = <span class="string">"hello world"</span>;</span><br><span class="line">  <span class="keyword">char</span> c = str.charAt(<span class="number">6</span>);</span><br><span class="line">  System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/javabase10-zfccl3/i4.png" alt="结果"></p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>字符串处理写完了，方法众多不可能说全部记下来，多练的意义在于加深印象，遇到相关需求的时候知道有这么个方法可以解决问题，不要到时候发出“这可咋办的呼喊”，又到深夜了，加油！奥利给！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;strong&gt;本篇内容：字符串的比较和查找。&lt;/strong&gt;字符串比较在代码中非常常见，多用于判断和验证，如根据字符串内容执行不同的代码，验证是否符合逻辑规则否则抛出异常等等，下面根据实际方法来说一下。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java字符串处理" scheme="http://www.mggblog.ink/tags/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
