<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MggBlog</title>
  
  <subtitle>MggBlog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mggblog.ink/"/>
  <updated>2020-02-26T02:16:35.450Z</updated>
  <id>http://www.mggblog.ink/</id>
  
  <author>
    <name>Mgg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十五）——Set 详解</title>
    <link href="http://www.mggblog.ink/2020/02/25/javabase45-set/"/>
    <id>http://www.mggblog.ink/2020/02/25/javabase45-set/</id>
    <published>2020-02-25T14:30:39.000Z</published>
    <updated>2020-02-26T02:16:35.450Z</updated>
    
    <content type="html"><![CDATA[<p><em>Set 集合存储的数据无序且独一无二，可以有 null ，但是只能有一个。它实现了 Collection 接口，本篇介绍： <strong>HashSet 和 TreeSet</strong> 两个实现类。 LinkedHashSet 可自行了解，与 HashSet 区别为 LinkedHashSet 内元素按添加顺序排序。</em></p><a id="more"></a><hr><p>开篇提醒：通常说的 Set 无序是不准确的，顺序通常指：按添加的顺序排列 和 按自然顺序a-z排列。</p><ul><li><p>传统说的Set无序是指 HashSet ，它不能保证元素的添加顺序，更不能保证自然顺序；</p></li><li><p>LinkedHashSet可以保证元素添加的顺序；</p></li><li><p>TreeSet可以保证元素自然的顺序。</p></li></ul><h2 id="一、HashSet-类"><a href="#一、HashSet-类" class="headerlink" title="一、HashSet 类"></a>一、HashSet 类</h2><p>HashSet 是 Set 接口的典型实现，使用 Hash 算法存储数据，具有很好的读写性能。</p><p>HashSet具有以下特点：</p><ol><li>无序</li><li>线程不同步，多线程访问需要手动同步数据。</li><li>元素可为 null ，但只能有一个。</li></ol><p>通过对象的 hashCode() 方法获得 hashCode 值，根据 hashCode 值确定存储位置，即使两个对象使用 equals 比较结果为 true ，只要 hashCode 值不同就可以存储。所以 <strong>HashSet 通过判断 equals 方法返回值和 hashCode 值是否完全一致来确定元素是否相等</strong>。</p><p>在 HashSet 类中实现了 Collection 接口中的所有方法。HashSet 类的常用构造方法重载形式如下。</p><ul><li>HashSet()：构造一个新的空的 Set 集合。</li><li>HashSet(Collection&lt;? extends E&gt;c)：构造一个包含指定 Collection 集合元素的新 Set 集合。其中，“&lt; &gt;”中的 extends 表示 HashSet 的父类，即指明该 Set 集合中存放的集合元素类型。c 表示其中的元素将被存放在此 Set 集合中。</li></ul><p>创建 HashSet 对象的两种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashSet hs = <span class="keyword">new</span> HashSet();    <span class="comment">// 调用无参的构造函数创建HashSet对象</span></span><br><span class="line">HashSet&lt;String&gt; hss = <span class="keyword">new</span> HashSet&lt;String&gt;();    <span class="comment">// 创建泛型的 HashSet 集合对象</span></span><br></pre></td></tr></table></figure><p>使用 foreach 或者 Iterator 迭代器遍历</p><blockquote><h3 id="关于-Iterator-迭代器"><a href="#关于-Iterator-迭代器" class="headerlink" title="关于 Iterator 迭代器"></a>关于 Iterator 迭代器</h3><p>Iterator 接口可以说是专门用来迭代遍历集合用的</p><p>提供了四个方法：</p><ol><li>forEachRemaining(Consumer&lt;? super E&gt; action)  对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。</li><li>hasNext()  如果迭代具有更多元素，则返回 true 。</li><li>next()  返回迭代中的下一个元素。</li><li>remove()  从底层集合中删除此迭代器返回的最后一个元素（可选操作）。 </li></ol><p>比如上篇List只讲了用 foreach 遍历，其实还可以用 Iterator 遍历。<br>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Iterator itr = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(itr.hasNext()) </span><br><span class="line">  System.out.println(itr.next()); <span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure></blockquote><p>举个HashSet用法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">HashSet&lt;String&gt; hs = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">hs.add(<span class="string">"one"</span>);</span><br><span class="line">hs.add(<span class="string">"two"</span>);</span><br><span class="line">hs.add(<span class="string">"three"</span>);</span><br><span class="line">hs.add(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// foreach 遍历</span></span><br><span class="line">System.out.println(<span class="string">"foreach 遍历"</span>);</span><br><span class="line"><span class="keyword">for</span> (String str : hs)</span><br><span class="line">System.out.print(str + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// Iterator 遍历</span></span><br><span class="line">System.out.println(<span class="string">"\nIterator 遍历"</span>);</span><br><span class="line">Iterator itr = hs.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext())</span><br><span class="line">System.out.print(itr.next() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="/2020/02/25/javabase45-set/t1.png" alt="创建带泛型set并遍历"></p><p>注意：如果向 Set 集合中添加两个相同的元素，则后添加的会覆盖前面添加的元素，即在 Set 集合中不会出现相同的元素。</p><h2 id="二、TreeSet-类"><a href="#二、TreeSet-类" class="headerlink" title="二、TreeSet 类"></a>二、TreeSet 类</h2><p>TreeSet 类同时实现了 Set 接口和 SortedSet 接口。SortedSet 接口是 Set 接口的子接口，可以实现对集合进行自然排序，因此使用 TreeSet 类实现的 Set 接口默认情况下是自然排序的，这里的自然排序指的是升序排序。</p><p>TreeSet 只能对实现了 Comparable 接口的类对象进行排序，因为 Comparable 接口中有一个 compareTo(Object o) 方法用于比较两个对象的大小。例如 a.compareTo(b)，如果 a 和 b 相等，则该方法返回 0；如果 a 大于 b，则该方法返回大于 0 的值；如果 a 小于 b，则该方法返回小于 0 的值。</p><p>Comparable 的三种比较大小方式：</p><ol><li>包装类（BigDecimal、Biglnteger、 Byte、Double、Float、Integer、Long 及 Short) ：按照数字大小比较。</li><li>Character ：按字符的 Unicode 值的数字大小比较</li><li>String ：按字符串中字符的 Unicode 值的数字大小比较</li></ol><p>TreeSet 常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>E first()</td><td>返回此集合中的第一个元素。其中，E 表示集合中元素的数据类型</td></tr><tr><td>E last()</td><td>返回此集合中的最后一个元素</td></tr><tr><td>E poolFirst()</td><td>获取并移除此集合中的第一个元素</td></tr><tr><td>E poolLast()</td><td>获取并移除此集合中的最后一个元素</td></tr><tr><td>SortedSet<E> subSet(E fromElement,E toElement)</E></td><td>返回一个新的集合，新集合包含原集合中 fromElement 对象与 toElement对象之间的所有对象。包含 fromElement 对象，不包含 toElement 对象</td></tr><tr><td>SortedSet<E> headSet(E toElement)</E></td><td>返回一个新的集合，新集合包含原集合中 toElement 对象之前的所有对象。不包含 toElement 对象</td></tr><tr><td>SortedSet<E> tailSet(E fromElement)</E></td><td>返回一个新的集合，新集合包含原集合中 fromElement 对象之后的所有对象。包含 fromElement 对象</td></tr></tbody></table><p>注意：表面上看起来这些方法很多，其实很简单。因为 TreeSet 中的元素是有序的，所以增加了访问第一个、前一个、后一个、最后一个元素的方法，并提供了 3 个从 TreeSet 中截取子 TreeSet 的方法。</p><p>用法举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">TreeSet&lt;Integer&gt; ts = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">ts.add(<span class="number">88</span>);</span><br><span class="line">ts.add(<span class="number">46</span>);</span><br><span class="line">ts.add(<span class="number">99</span>);</span><br><span class="line">ts.add(<span class="number">11</span>);</span><br><span class="line">ts.add(<span class="number">6</span>);</span><br><span class="line">ts.add(<span class="number">56</span>);</span><br><span class="line">Iterator itr = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 遍历原set</span></span><br><span class="line">System.out.println(<span class="string">"遍历原set："</span>);</span><br><span class="line">itr = ts.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext())</span><br><span class="line">System.out.print(itr.next() + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// subSet截取子set 11-88</span></span><br><span class="line">TreeSet&lt;Integer&gt; ts2 = (TreeSet&lt;Integer&gt;) ts.subSet(<span class="number">11</span>, <span class="number">88</span>);</span><br><span class="line"><span class="comment">// Iterator 遍历</span></span><br><span class="line">System.out.println(<span class="string">"\nsubSet截取子set后遍历set："</span>);</span><br><span class="line">itr = ts2.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext())</span><br><span class="line">System.out.print(itr.next() + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// headSet截取子set from56</span></span><br><span class="line">TreeSet&lt;Integer&gt; ts3 = (TreeSet&lt;Integer&gt;) ts.headSet(<span class="number">56</span>);</span><br><span class="line"><span class="comment">// Iterator 遍历</span></span><br><span class="line">System.out.println(<span class="string">"\nheadSet截取子set后遍历set："</span>);</span><br><span class="line">itr = ts3.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext())</span><br><span class="line">System.out.print(itr.next() + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tailSet截取子set from56</span></span><br><span class="line">TreeSet&lt;Integer&gt; ts4 = (TreeSet&lt;Integer&gt;) ts.tailSet(<span class="number">56</span>);</span><br><span class="line"><span class="comment">// Iterator 遍历</span></span><br><span class="line">System.out.println(<span class="string">"\ntailSet截取子set后遍历set："</span>);</span><br><span class="line">itr = ts4.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext())</span><br><span class="line">System.out.print(itr.next() + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/25/javabase45-set/t2.png" alt="获取子set"></p><p>（这些元素的范围可以概括为：参数在头部就包含，在尾部就不包含，java中的使用范围参数的方法大多都这样。）</p><p>jdk 文档中还有众多方法，用法基本和list一样，不再举例了。</p><p>无论是 TreeSet 还是 LinkedHashSet 几乎都很少会用到，最常用的还是 HashSet 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Set 集合存储的数据无序且独一无二，可以有 null ，但是只能有一个。它实现了 Collection 接口，本篇介绍： &lt;strong&gt;HashSet 和 TreeSet&lt;/strong&gt; 两个实现类。 LinkedHashSet 可自行了解，与 HashSet 区别为 LinkedHashSet 内元素按添加顺序排序。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java集合" scheme="http://www.mggblog.ink/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十四）——List 详解</title>
    <link href="http://www.mggblog.ink/2020/02/25/javabase44-list/"/>
    <id>http://www.mggblog.ink/2020/02/25/javabase44-list/</id>
    <published>2020-02-25T10:39:54.000Z</published>
    <updated>2020-02-26T02:09:43.224Z</updated>
    
    <content type="html"><![CDATA[<p><em>List是一个有序、可重复的集合，与数组相似，通过索引访问元素，且索引从 0 开始，list实现了 Collection 接口，两个主要的常用类：<strong>ArrayList 类和 LinkedList 类</strong>。</em></p><a id="more"></a><hr><h2 id="一、ArrayList-类"><a href="#一、ArrayList-类" class="headerlink" title="一、ArrayList 类"></a>一、ArrayList 类</h2><p>ArrayList 类实现了可变数组大小，靠索引访问元素，对尾部成员的增加和删除支持较好。</p><p>ArrayList 类常用的构造方法有如下形式：</p><ul><li>ArrayList():构造一个出容量为 10 的空列表。</li><li>ArrayList(Collection &lt;? extends E&gt; c):构造一个包含指定 Collection 元素的列表，这些元素是按照该 Collection 的迭代器返回它们的顺序排列的。</li></ul><p>List 接口 为 ArrayList 提供的方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>E get(int index)</td><td>获取此集合中指定索引位置的元素，E 为集合中元素的数据类型</td></tr><tr><td>int index(Object o)</td><td>返回此集合中第一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</td></tr><tr><td>int lastIndexOf(Object o)</td><td>返回此集合中最后一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</td></tr><tr><td>E set(int index, Eelement)</td><td>将此集合中指定索引位置的元素修改为 element 参数指定的对象。此方法返回此集合中指定索引位置的原元素</td></tr><tr><td>List<E> subList(int fromlndex, int tolndex)</E></td><td>返回一个新的集合，新集合中包含 fromlndex 和 tolndex 索引之间的所有元素。包含 fromlndex 处的元素，不包含 tolndex 索引处的元素</td></tr></tbody></table><p>注意：当调用 List 的 set(int index, Object element) 方法来改变 List 集合指定索引处的元素时，指定的索引必须是 List 集合的有效索引。例如集合长度为 4，就不能指定替换索引为 4 处的元素，也就是说这个方法不会改变 List 集合的长度。</p><p>举个例子：<br>例1，使用 ArrayList 存储 Dog 对象：<br>Dog 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age, String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toString</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dog [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", type="</span> + type + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">List&lt;Dog&gt; list = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">Dog dog1 = <span class="keyword">new</span> Dog(<span class="string">"阿旺"</span>,<span class="number">2</span>, <span class="string">"金毛犬"</span>);</span><br><span class="line">Dog dog2 = <span class="keyword">new</span> Dog(<span class="string">"阿喵"</span>,<span class="number">3</span>, <span class="string">"拉布拉多犬"</span>);</span><br><span class="line">Dog dog3 = <span class="keyword">new</span> Dog(<span class="string">"阿哈"</span>,<span class="number">2</span>, <span class="string">"哈士奇"</span>);</span><br><span class="line">list.add(dog1);</span><br><span class="line">list.add(dog2);</span><br><span class="line">list.add(dog3);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(Dog dog:list) System.out.println(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2020/02/25/javabase44-list/t1.png" alt="输出结果"></p><p>测试类代码中，&lt;Dog&gt; 就是使用了泛型，在这里先预习一下，表示当前 List 内的元素对象类型为 Dog ，如果不用泛型在 forEach 内部就要用 Object 类型来遍历。使用for循环需要强制转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line"><span class="comment">// 如果不使用泛型 这里要强制转型</span></span><br><span class="line">dog = (Dog) list.get(i);</span><br><span class="line">System.out.println(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2，indexOf 和 lastIndexOf 方法：<br>indexOf() 方法是查询元素的索引，lastIndexOf() 方法查询元素在 list 中最后一次出现的索引，使用时要注意区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"kangkang"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"jhon"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"jane"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"amy"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"lucy"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"amy"</span>));</span><br><span class="line"><span class="keyword">int</span> i = list.indexOf(<span class="string">"jhon"</span>);</span><br><span class="line">System.out.println(<span class="string">"jhon 的位置为"</span> + (i + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">int</span> j = list.lastIndexOf(<span class="string">"amy"</span>);</span><br><span class="line">System.out.println(<span class="string">"amy 的最后位置为"</span> + (j + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="/2020/02/25/javabase44-list/t2.png" alt="输出结果"></p><p>例3，subList 方法：<br>使用subList() 方法截取 List 部分元素，注意参数索引，subList(1,4),截取 1-3 的三个元素，和字符串截取方法 substring 是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"kangkang"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"jhon"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"jane"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"amy"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"lucy"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"amy"</span>));</span><br><span class="line">List list2 = list.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (Object str : list2)</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="/2020/02/25/javabase44-list/t3.png" alt="输出结果"></p><h2 id="二、LinkedList-类"><a href="#二、LinkedList-类" class="headerlink" title="二、LinkedList 类"></a>二、LinkedList 类</h2><p>链表结构，当需要频繁向集合中插入数据的话使用 LinkedList 要比 ArrayList 效率要高。相对的，按照索引检索时就比较慢了。</p><p>LinkedList 类方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void addFirst(E e)</td><td>将指定元素添加到此集合的开头</td></tr><tr><td>void addLast(E e)</td><td>将指定元素添加到此集合的末尾</td></tr><tr><td>E getFirst()</td><td>返回此集合的第一个元素</td></tr><tr><td>E getLast()</td><td>返回此集合的最后一个元素</td></tr><tr><td>E removeFirst()</td><td>删除此集合中的第一个元素</td></tr><tr><td>E removeLast()</td><td>删除此集合中的最后一个元素</td></tr></tbody></table><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">list.add(<span class="number">10</span>);</span><br><span class="line">list.add(<span class="number">9</span>);</span><br><span class="line">list.add(<span class="number">8</span>);</span><br><span class="line">list.add(<span class="number">7</span>);</span><br><span class="line">list.add(<span class="number">6</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 第一个元素</span></span><br><span class="line">System.out.println(<span class="string">"第一个元素为："</span> + list.getFirst());</span><br><span class="line"><span class="comment">// 最后一个元素</span></span><br><span class="line">System.out.println(<span class="string">"最后一个元素为："</span> + list.getLast());</span><br><span class="line">System.out.println(<span class="string">"遍历链表："</span>);</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (Object i : list)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 删去索引为 2的元素</span></span><br><span class="line">list.remove(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"\n删去索引为2的元素后遍历链表："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 在向2处插入8</span></span><br><span class="line">list.add(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">"\n在索引为2处插入8后遍历链表："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 删除第一个元素</span></span><br><span class="line">list.removeFirst();</span><br><span class="line"><span class="comment">// 删除最后一个元素</span></span><br><span class="line">list.removeLast();</span><br><span class="line">System.out.println(<span class="string">"\n掐头去尾后遍历链表："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/25/javabase44-list/t4.png" alt="输出结果"></p><h2 id="三、ArrayList-与-LinkedList-区别"><a href="#三、ArrayList-与-LinkedList-区别" class="headerlink" title="三、ArrayList 与 LinkedList 区别"></a>三、ArrayList 与 LinkedList 区别</h2><p>ArrayList 与 LinkedList 都是 List 接口的实现类，因此都实现了 List 的所有未实现的方法，只是实现的方式有所不同。</p><p>ArrayList 是基于动态数组数据结构的实现，访问元素速度优于 LinkedList。LinkedList 是基于链表数据结构的实现，占用的内存空间比较大，但在批量插入或删除数据时优于 ArrayList。</p><p>对于快速访问对象的需求，使用 ArrayList 实现执行效率上会比较好。需要频繁向集合中插入和删除元素时，使用 LinkedList 类比 ArrayList 类效果高。</p><p>不同的结构对应于不同的算法，有的考虑节省占用空间，有的考虑提高运行效率，对于程序员而言，它们就像是“熊掌”和“鱼肉”，不可兼得。高运行速度往往是以牺牲空间为代价的，而节省占用空间往往是以牺牲运行速度为代价的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;List是一个有序、可重复的集合，与数组相似，通过索引访问元素，且索引从 0 开始，list实现了 Collection 接口，两个主要的常用类：&lt;strong&gt;ArrayList 类和 LinkedList 类&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java集合" scheme="http://www.mggblog.ink/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十三）——集合、Collection 接口</title>
    <link href="http://www.mggblog.ink/2020/02/25/javabase43-collection/"/>
    <id>http://www.mggblog.ink/2020/02/25/javabase43-collection/</id>
    <published>2020-02-25T07:47:16.000Z</published>
    <updated>2020-02-26T02:01:30.535Z</updated>
    
    <content type="html"><![CDATA[<p><em>随着程序越来越复杂，数组已经不能满足数组存储的需要，况且声明数组需要设定长度，不够灵活。Java为开发者提供了内容丰富、功能强大的集合类，处于 java.util 包中，分为 Collection 和 Map 两个根接口，接下来详细讲解 Collection 接口。</em></p><a id="more"></a><hr><h2 id="一、集合简介"><a href="#一、集合简介" class="headerlink" title="一、集合简介"></a>一、集合简介</h2><p>Java 集合类型分为 Collection 和 Map，同为Java集合根接口，集合的众多功能来源于两个接口的子接口和实现类。<br><img src="/2020/02/25/javabase43-collection/jh.gif" alt="集合结构"></p><p>下面对集合的接口和实现类分别做个简单的介绍：</p><h3 id="集合接口："><a href="#集合接口：" class="headerlink" title="集合接口："></a>集合接口：</h3><table><thead><tr><th>接口</th><th>说明</th></tr></thead><tbody><tr><td>Iterator 接口</td><td>集合的输出接口，主要用于遍历输出（即迭代访问）Collection 集合中的元素，Iterator 对象被称之为迭代器。迭代器接口是集合接口的父接口，实现类实现 Collection 时就必须实现 Iterator 接口。</td></tr><tr><td>Collection 接口</td><td>是 List、Set 和 Queue 的父接口，是存放一组单值的最大接口。所谓的单值是指集合中的每个元素都是一个对象。一般很少直接使用此接口直接操作。</td></tr><tr><td>Queue 接口</td><td>Queue 是 Java 提供的队列实现，有点类似于 List。</td></tr><tr><td>Dueue 接口</td><td>是 Queue 的一个子接口，为双向队列。</td></tr><tr><td>List 接口</td><td>是最常用的接口。是有序集合，允许有相同的元素。使用 List 能够精确地控制每个元素插入的位置，用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，与数组类似。</td></tr><tr><td>Set 接口</td><td>不能包含重复的元素。</td></tr><tr><td>Map 接口</td><td>是存放一对值的最大接口，即接口中的每个元素都是一对，以 key→value 的形式保存。</td></tr></tbody></table><p>对于 Set、List、Queue 和 Map 这 4 种集合，Java 最常用的实现类分别是 HashSet、TreeSet、ArrayList、ArrayDueue、LinkedList 和 HashMap、TreeMap 等。</p><h3 id="集合实现类"><a href="#集合实现类" class="headerlink" title="集合实现类"></a>集合实现类</h3><table><thead><tr><th>类名称</th><th>说明</th></tr></thead><tbody><tr><td>HashSet</td><td>为优化査询速度而设计的 Set。它是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，实现比较简单</td></tr><tr><td>TreeSet</td><td>实现了 Set 接口，是一个有序的 Set，这样就能从 Set 里面提取一个有序序列</td></tr><tr><td>ArrayList</td><td>一个用数组实现的 List，能进行快速的随机访问，效率高而且实现了可变大小的数组</td></tr><tr><td>ArrayDueue</td><td>是一个基于数组实现的双端队列，按“先进先出”的方式操作集合元素</td></tr><tr><td>LinkedList</td><td>对顺序访问进行了优化，但随机访问的速度相对较慢。此外它还有 addFirst()、addLast()、getFirst()、getLast()、removeFirst() 和 removeLast() 等方法，能把它当成栈（Stack）或队列（Queue）来用</td></tr><tr><td>HsahMap</td><td>按哈希算法来存取键对象</td></tr><tr><td>TreeMap</td><td>可以对键对象进行排序</td></tr></tbody></table><h2 id="二、Collection-接口详解"><a href="#二、Collection-接口详解" class="headerlink" title="二、Collection 接口详解"></a>二、Collection 接口详解</h2><p>Collection 接口是 List、Set 和 Queue 的父接口，通常不直接使用，通过 Collection 接口中的一些通用方法，可以实现集对集合的基本操作。</p><p>Collection 接口中的常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>向集合中添加一个元素，如果集合对象被添加操作改变了，则返回 true。E 是元素的数据类型</td></tr><tr><td>boolean addAll(Collection c)</td><td>向集合中添加集合 c 中的所有元素，如果集合对象被添加操作改变了，则返回 true。</td></tr><tr><td>void clear()</td><td>清除集合中的所有元素，将集合长度变为 0。</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否存在指定元素</td></tr><tr><td>boolean containsAll(Collection c)</td><td>判断集合中是否包含集合 c 中的所有元素</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>Iterator<E>iterator()</E></td><td>返回一个 Iterator 对象，用于遍历集合中的元素</td></tr><tr><td>boolean remove(Object o)</td><td>从集合中删除一个指定元素，当集合中包含了一个或多个元素 o 时，该方法只删除第一个符合条件的元素，该方法将返回 true。</td></tr><tr><td>boolean removeAll(Collection c)</td><td>从集合中删除所有在集合 c 中出现的元素（相当于把调用该方法的集合减去集合 c）。如果该操作改变了调用该方法的集合，则该方法返回 true。</td></tr><tr><td>boolean retainAll(Collection c)</td><td>从集合中删除集合 c 里不包含的元素（相当于把调用该方法的集合变成该集合和集合 c 的交集），如果该操作改变了调用该方法的集合，则该方法返回 true。</td></tr><tr><td>int size()</td><td>返回集合中元素的个数</td></tr><tr><td>Object[] toArray()</td><td>把集合转换为一个数组，所有的集合元素变成对应的数组元素。</td></tr></tbody></table><p>这些方法源于 jdk 帮助文档，只需记住 Collection 为我们提供了操作集合的常用方法就可以，例如判断非空，存在，遍历，长度，新增，删减等方法，有需要但是不会用的话直接去查文档即可。</p><p>用法举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">List list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">// 为集合添加元素</span></span><br><span class="line">list1.add(<span class="number">3</span>);</span><br><span class="line">list1.add(<span class="number">2</span>);</span><br><span class="line">list1.add(<span class="number">22</span>);</span><br><span class="line">list1.add(<span class="number">33</span>);</span><br><span class="line">list1.add(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 判断集合是否为空</span></span><br><span class="line">System.out.println(<span class="string">"list1 if empty? "</span> + list1.isEmpty());</span><br><span class="line"><span class="comment">// 获取长度</span></span><br><span class="line">System.out.println(<span class="string">"list1 长度： "</span> + list1.size());</span><br><span class="line"><span class="comment">// 判断是否存在指定元素</span></span><br><span class="line">System.out.println(<span class="string">"list1 exist 11? "</span> + list1.contains(<span class="number">11</span>));</span><br><span class="line"><span class="comment">// 遍历集合list1</span></span><br><span class="line">System.out.print(<span class="string">"list1 中元素："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list1)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// 通过list1 为list2 赋值</span></span><br><span class="line">list2.addAll(list1);</span><br><span class="line"><span class="comment">// 遍历list2</span></span><br><span class="line">System.out.print(<span class="string">"list1为list2赋值后 list2包含元素："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list2)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// 通过索引获取元素</span></span><br><span class="line">System.out.println(<span class="string">"list2 索引为3的元素："</span> + list2.get(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// 为list2 添加元素</span></span><br><span class="line">list2.add(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 移除 list2 中 在list1中没有的元素 10</span></span><br><span class="line">list2.retainAll(list1);</span><br><span class="line"><span class="comment">// retainAll后 遍历list2 元素</span></span><br><span class="line">System.out.print(<span class="string">"retainAll后遍历list2 元素："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list2)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// 移除list2 所有元素</span></span><br><span class="line">list2.removeAll(list2);</span><br><span class="line"><span class="comment">// 移除后list2长度</span></span><br><span class="line">System.out.println(<span class="string">"list2移除所有元素后长度："</span> + list2.size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/25/javabase43-collection/jhcz.png" alt="集合一般操作"></p><p>在写代码时会发现在编辑器中会出现大量黄色下划线，这是因为没有为集合指定类型的警告，涉及到了泛型的知识，后面详细讲解。如果不指定类型的话默认设定为 Object ，警告并不会影响编译和运行，不用管。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;随着程序越来越复杂，数组已经不能满足数组存储的需要，况且声明数组需要设定长度，不够灵活。Java为开发者提供了内容丰富、功能强大的集合类，处于 java.util 包中，分为 Collection 和 Map 两个根接口，接下来详细讲解 Collection 接口。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java集合" scheme="http://www.mggblog.ink/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十二）——Log日志记录</title>
    <link href="http://www.mggblog.ink/2020/02/25/javabase42-log/"/>
    <id>http://www.mggblog.ink/2020/02/25/javabase42-log/</id>
    <published>2020-02-25T01:04:58.000Z</published>
    <updated>2020-02-25T02:46:28.993Z</updated>
    
    <content type="html"><![CDATA[<p><em>程序在部署运行时，不可能时时有人盯着会发生什么异常，这时候需要一个记录程序运行过程的工具，方便程序员查找关键信息，本篇介绍Java自带的日志工具类——java.util.logging。</em></p><a id="more"></a><hr><p>初学Java时经常用控制台打印 System.out.println() 来观察代码运行情况，随着代码越来越复杂，程序中就会出现很多这种代码，没有问题后再删去，非常麻烦，Java 为开发者提供了日志工具包 java.util.logging ，方便程序员快速定位问题所在。</p><p>想要快速生成日志记录，直接调用 Logger 类的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().info(<span class="string">"日志信息"</span>);</span><br></pre></td></tr></table></figure><p>Logging 把日志分为7个安全级别，等级一次降低。</p><table><thead><tr><th>等级</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>SEVERE</td><td>severe()</td><td>严重</td></tr><tr><td>WARNING</td><td>warning()</td><td>警告</td></tr><tr><td>INFO</td><td>info()</td><td>信息</td></tr><tr><td>CONFIG</td><td>config()</td><td>配置</td></tr><tr><td>FINE</td><td>fine()</td><td>良好</td></tr><tr><td>FINER</td><td>finer()</td><td>较好</td></tr><tr><td>FINEST</td><td>finest()</td><td>最好</td></tr></tbody></table><p>Logger 默认安全级别为 INFO ，比 INFO 级别低的日志将不显示。Logger 的默认级别定义在 jre 安装目录的 lib 下面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Limit the message that are printed on the console to INFO and above.</span><br><span class="line">java.util.logging.ConsoleHandler.level = INFO</span><br></pre></td></tr></table></figure><p>默认情况下，日志只显示三个级别，INFO、WARNING、SERVERE。获得 Logger 对象后可以使用 对象.方法 来使用日志，还可以使用 对象.log(Level.INFO,msg) 来调用。<br>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Logger.getGlobal().info(<span class="string">"it is INFO msg"</span>);<span class="comment">// 静态方法</span></span><br><span class="line">Logger logger = Logger.getGlobal();<span class="comment">// 获取 Logger 对象</span></span><br><span class="line">logger.severe(<span class="string">"it is SEVERE msg"</span>);</span><br><span class="line">logger.log(Level.WARNING, <span class="string">"it is WARNING msg"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台：<br><img src="/2020/02/25/javabase42-log/l1.png" alt="三种使用日志的方法"></p><p>可以使用 setLevel 方法设置级别，例如 logger.setLevel(Level.FINE) 可以将 FINE 和更高级别的都记录下来。另外，还可以使用 Level.ALL 开启所有级别的记录，或者使用 Level.OFF 关闭所有级别的记录。</p><p>注意：如果将记录级别设计为 INFO 或者更低，则需要修改日志处理器的配置。默认的日志处理器不会处理低于 INFO 级别的信息。</p><blockquote><h3 id="修改日志管理器配置"><a href="#修改日志管理器配置" class="headerlink" title="修改日志管理器配置"></a>修改日志管理器配置</h3><p>可以通过编辑配置文件来修改日志系统的各种属性。在默认情况下，配置文件存在于 jre 安装目录下“jre/lib/logging.properties”。要想使用另一个配置文件，就要将 java.util.logging.config.file 特性设置为配置文件的存储位置，并用下列命令启动应用程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.util.logging.config.file = configFile MainClass</span><br></pre></td></tr></table></figure><p>日志管理器在 JVM 启动过程中初始化，这在 main 执行之前完成。如果在 main 中调用System.setProperty(“java.util.logging.config.file”,file) ，也会调用LogManager.readConfiguration() 来重新初始化日志管理器。</p><p>要想修改默认的日志记录级别，就需要编辑配置文件，并修改以下命令行。</p><p>.level=INFO</p><p>可以通过添加以下内容来指定自己的日志记录级别</p><p>Test.Test.level=FINE</p><p>也就是说，在日志记录器名后面添加后缀 .level。</p><p>在稍后可以看到，日志记录并不将消息发送到控制台上，这是处理器的任务。另外，处理器也有级别。要想在控制台上看到 FINE 级别的消息，就需要进行下列设置。</p><p>java.util.logging.ConsoleHandler.level=FINE</p><p>注意：在日志管理器配置的属性设置不是系统属性，因此，用-Dcom.mycompany.myapp.level=FINE启动应用程序不会对日志记录器产生任何影响。</p></blockquote><p>在开发项目过程中通常会使用开源的日志记录脚手架 log4j2 ，通过修改简单的配置文件就可以完成日志记录的工作，log4j2 后面单独写博客来说。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;程序在部署运行时，不可能时时有人盯着会发生什么异常，这时候需要一个记录程序运行过程的工具，方便程序员查找关键信息，本篇介绍Java自带的日志工具类——java.util.logging。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java异常处理" scheme="http://www.mggblog.ink/tags/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十一）——异常处理</title>
    <link href="http://www.mggblog.ink/2020/02/24/javabase41-exception/"/>
    <id>http://www.mggblog.ink/2020/02/24/javabase41-exception/</id>
    <published>2020-02-24T13:34:55.000Z</published>
    <updated>2020-02-25T00:51:15.791Z</updated>
    
    <content type="html"><![CDATA[<p><em>在程序执行中难免会遇到一些错误，且难以避免，称为异常，有时候是代码逻辑上的错误，比如用 0 做了除数，有些是物理错误，比如 jvm 内存溢出，本篇内容学习如何处理异常。</em></p><a id="more"></a><hr><h2 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h2><p>异常发生的原因通常分为：</p><ul><li>输入非法数据</li><li>寻找的资源不存在</li><li>通信终端或者 jvm 内存溢出</li></ul><p>有些是用户操作错误，有些是程序 bug ，有些是物理因素影响，通常我们把 java 程序异常分为：</p><ul><li>检查性异常：程序员无法预见用户操作产生的异常，如打开不存在的文件，该异常不可以轻易忽略。</li><li>运行时异常：可以被程序员避免的异常，如常见的空指针异常，可以在编译时被忽略。</li><li>错误：错误不是异常，脱离程序员控制的问题，代码可能会对这些错误产生影响，当栈溢出时会发生错误，编译时检查补到，但是很可能和代码有关系。</li></ul><h3 id="一、Exception-类的层次"><a href="#一、Exception-类的层次" class="headerlink" title="一、Exception 类的层次"></a>一、Exception 类的层次</h3><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p><p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p><p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</p><p>Error 用来指示运行时环境发生的错误。</p><p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p><p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p><p><img src="/2020/02/24/javabase41-exception/ex.png" alt="Exception层次关系"></p><h3 id="二、java内置异常类"><a href="#二、java内置异常类" class="headerlink" title="二、java内置异常类"></a>二、java内置异常类</h3><p>Java 语言定义了一些异常类在 java.lang 标准包中。</p><p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p><p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的<em>非检查性异常</em>。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ArithmeticException</td><td>当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td></tr><tr><td>ArrayStoreException</td><td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td></tr><tr><td>ClassCastException</td><td>当试图将对象强制转换为不是实例的子类时，抛出该异常。</td></tr><tr><td>IllegalArgumentException</td><td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td></tr><tr><td>IllegalMonitorStateException</td><td>抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td></tr><tr><td>IllegalStateException</td><td>在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td></tr><tr><td>IllegalThreadStateException</td><td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td></tr><tr><td>IndexOutOfBoundsException</td><td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td></tr><tr><td>NegativeArraySizeException</td><td>如果应用程序试图创建大小为负的数组，则抛出该异常。</td></tr><tr><td>NullPointerException</td><td>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</td></tr><tr><td>NumberFormatException</td><td>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td></tr><tr><td>SecurityException</td><td>由安全管理器抛出的异常，指示存在安全侵犯。</td></tr><tr><td>StringIndexOutOfBoundsException</td><td>此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</td></tr><tr><td>UnsupportedOperationException</td><td>当不支持请求的操作时，抛出该异常。</td></tr></tbody></table><p>下面的表中列出了 Java 定义在 java.lang 包中的<em>检查性异常类</em>。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>应用程序试图加载类时，找不到相应的类，抛出该异常。</td></tr><tr><td>CloneNotSupportedException</td><td>当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</td></tr><tr><td>IllegalAccessException</td><td>拒绝访问一个类的时候，抛出该异常。</td></tr><tr><td>InstantiationException</td><td>当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td></tr><tr><td>InterruptedException</td><td>一个线程被另一个线程中断，抛出该异常。</td></tr><tr><td>NoSuchFieldException</td><td>请求的变量不存在</td></tr><tr><td>NoSuchMethodException</td><td>请求的方法不存在</td></tr></tbody></table><h3 id="三、异常方法"><a href="#三、异常方法" class="headerlink" title="三、异常方法"></a>三、异常方法</h3><p>下面的列表是 Throwable 类的主要方法:</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td></tr><tr><td>public Throwable getCause()</td><td>返回一个Throwable 对象代表异常原因。</td></tr><tr><td>public String toString()</td><td>使用getMessage()的结果返回类的串级名字。</td></tr><tr><td>public void printStackTrace()</td><td>打印toString()结果和栈层次到System.err，即错误输出流。</td></tr><tr><td>public StackTraceElement [] getStackTrace()</td><td>返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td></tr><tr><td>public Throwable fillInStackTrace()</td><td>用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td></tr></tbody></table><p>这些方法常常在try catch 块中使用。</p><h3 id="四、捕获异常"><a href="#四、捕获异常" class="headerlink" title="四、捕获异常"></a>四、捕获异常</h3><p>在前面博客已有提到 try catch 块，下面单独说一下。</p><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p><p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//Catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p><p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="number">11</span>/<span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace(); <span class="comment">//java.lang.ArithmeticException: / by zero</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获除数为 0 异常，并打印到控制台。<br><img src="/2020/02/24/javabase41-exception/e1.png" alt="捕获异常"></p><h3 id="五、多重捕获串"><a href="#五、多重捕获串" class="headerlink" title="五、多重捕获串"></a>五、多重捕获串</h3><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。<br>多重捕获块的语法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多 catch 的情况下陈旭出现的异常会向下按顺序匹配，直到匹配到对应类型的异常。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String fileName = <span class="string">"d:\\1.txt"</span>;</span><br><span class="line">FileInputStream file = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">Byte x = (<span class="keyword">byte</span>) file.read();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException f) &#123;</span><br><span class="line">f.printStackTrace();</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException i) &#123;</span><br><span class="line">i.printStackTrace();</span><br><span class="line">System.out.println(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/24/javabase41-exception/e2.png" alt="捕获异常"></p><h3 id="六、throws-throw-关键字"><a href="#六、throws-throw-关键字" class="headerlink" title="六、throws\throw 关键字"></a>六、throws\throw 关键字</h3><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p><p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p><p>下面方法的声明抛出一个 RemoteException 异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Method implementation</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p><p>例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException,</span></span><br><span class="line"><span class="function">                              InsufficientFundsException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// Method implementation</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、finally-关键字"><a href="#七、finally-关键字" class="headerlink" title="七、finally 关键字"></a>七、finally 关键字</h3><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。</p><p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p><p>finally 代码块出现在 catch 代码块最后，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="number">11</span> / <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"方法执行完了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/24/javabase41-exception/e3.png" alt="运行结果"></p><p>注意下面事项：</p><ul><li>catch 不能独立于 try 存在。</li><li>在 try/catch 后面添加 finally 块并非强制性要求的。</li><li>try 代码后不能既没 catch 块也没 finally 块。</li><li>try, catch, finally 块之间不能添加任何代码。</li></ul><h3 id="八、声明自定义异常"><a href="#八、声明自定义异常" class="headerlink" title="八、声明自定义异常"></a>八、声明自定义异常</h3><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p><ul><li>所有异常都必须是 Throwable 的子类。</li><li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li><li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li></ul><p>可以像下面这样定义自己的异常类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只继承Exception 类来创建的异常类是检查性异常类。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivisorIsZeroException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> divisor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DivisorIsZeroException</span><span class="params">(<span class="keyword">double</span> divisor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.divisor = divisor;</span><br><span class="line">System.out.print(<span class="string">"divisor is zero "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DivisorIsZeroException</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DivisorIsZeroException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> DivisorIsZeroException(i);</span><br><span class="line">System.out.println(<span class="number">11</span> / i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/24/javabase41-exception/e4.png" alt="运行结果"></p><h3 id="九、通用异常"><a href="#九、通用异常" class="headerlink" title="九、通用异常"></a>九、通用异常</h3><p>在Java中定义了两种类型的异常和错误。</p><ul><li>JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</li><li>程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在程序执行中难免会遇到一些错误，且难以避免，称为异常，有时候是代码逻辑上的错误，比如用 0 做了除数，有些是物理错误，比如 jvm 内存溢出，本篇内容学习如何处理异常。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java异常处理" scheme="http://www.mggblog.ink/tags/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十）——内部类（四种）</title>
    <link href="http://www.mggblog.ink/2020/02/24/javabase40-inner/"/>
    <id>http://www.mggblog.ink/2020/02/24/javabase40-inner/</id>
    <published>2020-02-24T08:22:26.000Z</published>
    <updated>2020-02-24T13:18:14.500Z</updated>
    
    <content type="html"><![CDATA[<p><em>在类的内部可以嵌套一个类，称为内部类，外面的类称为外部类，内部类又可以分为四种，<strong>本篇内容：成员内部类、局部内部类、匿名内部类和静态内部类。</strong></em></p><a id="more"></a><hr><p>内部类可以很好地实现隐藏，一般的非内部类是不允许有 private 与 protected 权限的，但内部类可以。内部类拥有外部类的所有元素的访问权限，接下来分别介绍四种内部类。</p><h2 id="一、成员内部类"><a href="#一、成员内部类" class="headerlink" title="一、成员内部类"></a>一、成员内部类</h2><p>最普通的内部类，定义在一个类的内部，请仔细阅读代码注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"Mgg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Out</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: usrInnerMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 调用内部类成员</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">usrInnerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 想要使用内部类成员需要先创建内部类对象</span></span><br><span class="line">getInnerInstance().print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为创建对象方便创建一个获得内部类对象的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getInnerInstance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获得内部类对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Out.Inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Inner</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 内部类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> Feb 24, 2020</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;<span class="comment">// 内部类私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"内部类的  print 方法"</span>);</span><br><span class="line">System.out.println(num);<span class="comment">// 默认调用内部类成员</span></span><br><span class="line">System.out.println(Out.<span class="keyword">this</span>.num);<span class="comment">// 调用外部类私有成员</span></span><br><span class="line">System.out.println(str); <span class="comment">// 调用外部类静态成员</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个测试类 Test ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Out out = <span class="keyword">new</span> Out(-<span class="number">10</span>);</span><br><span class="line">out.getInnerInstance().print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/24/javabase40-inner/t1.png" alt="通过外部类使用内部类方法"></p><p>通过例子总结成员内部类的特点：</p><ul><li>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</li><li>成员内部类拥有和外部类同名的成员变量或者方法时，默认调用的是内部类成员，外部类成员需要使用 [外部类.this.成员变量/方法] 的方法调用。</li><li>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。</li></ul><blockquote><p>通常外部类不使用 private、protected 修饰，成员内部类则可以使用的四种权限，比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。</p></blockquote><h2 id="二、局部内部类"><a href="#二、局部内部类" class="headerlink" title="二、局部内部类"></a>二、局部内部类</h2><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外部父类eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: eat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: animal eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Animal eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getCat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获得局部内部类的对象的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 局部内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">// 重写了父类 eat方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Cat eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Cat(); <span class="comment">// 向上转型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal anim = Animal.getCat();</span><br><span class="line">anim.eat(); <span class="comment">// Cat eat</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</p></blockquote><h2 id="三、匿名内部类"><a href="#三、匿名内部类" class="headerlink" title="三、匿名内部类"></a>三、匿名内部类</h2><p>匿名内部类形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> &lt;类或接口&gt; ()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名类有两种实现方式：</p><ol><li>继承一个类，重写其方法。</li><li>实现一个接口（可以是多个），实现其方法。</li></ol><p>举个继承类的例子<br>Animal 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外部父类eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: eat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: animal eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Animal eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal ani = <span class="keyword">new</span> Cat() &#123;</span><br><span class="line"><span class="comment">// 重写了eat方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"匿名内部类的 eat方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ani.eat(); <span class="comment">// 匿名内部类的 eat方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/24/javabase40-inner/t2.png" alt="使用继承完成内部匿名类"></p><p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为 Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p><h2 id="四、静态内部类"><a href="#四、静态内部类" class="headerlink" title="四、静态内部类"></a>四、静态内部类</h2><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outstatic</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> String str = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Innerstatic</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(i); //Cannot make a static reference to the non-static field i</span></span><br><span class="line">        System.out.println(str); <span class="comment">// Hello</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Outstatic out = <span class="keyword">new</span> Outstatic();</span><br><span class="line">Outstatic.Innerstatic oi = <span class="keyword">new</span>  Outstatic.Innerstatic();</span><br><span class="line">oi.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/24/javabase40-inner/t.png" alt="运行结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在类的内部可以嵌套一个类，称为内部类，外面的类称为外部类，内部类又可以分为四种，&lt;strong&gt;本篇内容：成员内部类、局部内部类、匿名内部类和静态内部类。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十九）——接口（Interface）</title>
    <link href="http://www.mggblog.ink/2020/02/24/javabase39-interface/"/>
    <id>http://www.mggblog.ink/2020/02/24/javabase39-interface/</id>
    <published>2020-02-24T02:53:16.000Z</published>
    <updated>2020-02-24T04:08:49.043Z</updated>
    
    <content type="html"><![CDATA[<p><em>抽象类中可以有抽象方法也可以有普通方法，Java为我们提供了一个专门收纳抽象方法的抽象类型——接口（interface），接口与类是两种不同的概念。</em></p><a id="more"></a><hr><p>与类对比理解：<br><strong>接口与类相似点：</strong></p><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><p><strong>接口与类的区别：</strong></p><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><p><strong>接口特性</strong></p><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><p><strong>抽象类和接口的区别</strong></p><ol><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口</li></ol><h2 id="一、接口声明"><a href="#一、接口声明" class="headerlink" title="一、接口声明"></a>一、接口声明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[public] interface interface_name [extends interface1_name[, interface2_name,…]] &#123;</span><br><span class="line">    <span class="comment">// 接口体，其中可以包含定义常量和声明方法</span></span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] type constant_name = value;    <span class="comment">// 定义常量</span></span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] <span class="function">returnType <span class="title">method_name</span><span class="params">(parameter_list)</span></span>;    <span class="comment">// 声明方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上语法的说明如下：</p><ul><li>public 表示接口的修饰符，当没有修饰符时，则使用默认的修饰符，此时该接口的访问权限仅局限于所属的包；</li><li>interface_name 表示接口的名称。接口名应与类名采用相同的命名规则，即如果仅从语法角度来看，接口名只要是合法的标识符即可。如果要遵守 Java 可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写，单词与单词之间无需任何分隔符。</li><li>extends 表示接口的继承关系；</li><li>interface1_name 表示要继承的接口名称；</li><li>constant_name 表示变量名称，一般是 static 和 final 型的；</li><li>returnType 表示方法的返回值类型；</li><li>parameter_list 表示参数列表，在接口中的方法是没有方法体的。</li></ul><p>动手创建一个接口 Animal ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">//全局常量动物园名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zoo = <span class="string">"幻想乡动物园"</span>;</span><br><span class="line">    <span class="comment">//饲养员</span></span><br><span class="line">String feeder = <span class="string">"kangkang"</span>; <span class="comment">// 推荐这样定义，因为默认的修饰就是  public static final</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: run   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 run 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 jump 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>;<span class="comment">//推荐这样定义 默认修饰为  public abstract</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: eat   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 eat 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;<span class="comment">//推荐这样定义 默认修饰为  public abstract</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: sleep   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 sleep 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;<span class="comment">//推荐这样定义 默认修饰为  public abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提醒一下：接口中的常量必须有初始值，否则无法通过编译。推荐不使用修饰符修饰，默认即可，保持代码简洁（但是团队开发中需要看规范如何要求）。</p><h2 id="二、接口的实现"><a href="#二、接口的实现" class="headerlink" title="二、接口的实现"></a>二、接口的实现</h2><p>Java允许一个类实现多个接口，以补充类单继承的不足。继承使用 extends 关键字，实现则使用 implements 关键字，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;public&gt; class &lt;class_name&gt; [extends superclass_name] [implements interface1_name[, interface2_name…]] &#123;</span><br><span class="line">    <span class="comment">// 主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上语法的说明如下：</p><ul><li>public：类的修饰符；</li><li>superclass_name：需要继承的父类名称；</li><li>interface1_name：要实现的接口名称。</li></ul><p>实现接口需要注意以下几点：</p><ol><li>实现接口与继承父类相似，一样可以获得所实现接口里定义的常量和方法。如果一个类需要实现多个接口，则多个接口之间以逗号分隔。</li><li>一个类可以继承一个父类，并同时实现多个接口，implements 部分必须放在 extends 部分之后。</li><li>一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。</li></ol><p>Demo：<br>创建 Lion 类 实现 Animal 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion run"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion jump"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion sleep"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</p></blockquote><p>测试类 Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Lion lion = <span class="keyword">new</span> Lion();</span><br><span class="line">lion.eat();</span><br><span class="line">lion.run();</span><br><span class="line">lion.jump();</span><br><span class="line">lion.sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2020/02/24/javabase39-interface/t.png" alt="运行结果"></p><h2 id="三、接口继承"><a href="#三、接口继承" class="headerlink" title="三、接口继承"></a>三、接口继承</h2><p>和类以一样，使用 extends 关键字继承父接口，不同的是接口支持多继承，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Biology</span>,<span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 猫爬树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: climbTree   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">climbTree</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了 Cat 接口继承了 Biology（生物），Animal（动物） 接口，只使用了一个 extends 关键字，后面的多个接口用 “ , “ 隔开。</p><p>当新建类实现 Cat 接口时，这个类就要重写 Cat 接口内的所有抽象方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;抽象类中可以有抽象方法也可以有普通方法，Java为我们提供了一个专门收纳抽象方法的抽象类型——接口（interface），接口与类是两种不同的概念。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十八）—— 抽象类</title>
    <link href="http://www.mggblog.ink/2020/02/24/javabase38-abstract/"/>
    <id>http://www.mggblog.ink/2020/02/24/javabase38-abstract/</id>
    <published>2020-02-24T01:46:42.000Z</published>
    <updated>2020-02-24T02:54:40.777Z</updated>
    
    <content type="html"><![CDATA[<p><em>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</em></p><a id="more"></a><hr><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>Java 中使用 abstract 来定义抽象类，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: run</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 抽象方法 run</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: sleep   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 普通方法 sleep </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zzzzzzzzz...."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获取名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: setName   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 设置名字 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toString</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Animal [name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类是不能直接实例化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal(<span class="string">"huahua"</span>);<span class="comment">//Cannot instantiate the type Animal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是可以通过继承来实例化：<br>创建一个 Dog 类继承 Animal 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.print(<span class="keyword">this</span>.getName()+<span class="string">" dog run!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 Dog 类时，eclipse 会提示重写父类抽象方法，不然在类名字下面有红线。</p><p>所以当继承抽象类时必须重写父类的抽象方法。</p><p>测试类 Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Dog();<span class="comment">// 向上转型</span></span><br><span class="line">animal.setName(<span class="string">"huahua"</span>);</span><br><span class="line">animal.run();</span><br><span class="line">animal.sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2020/02/24/javabase38-abstract/t1.png" alt="重写的run方法"></p><p>通过上面的例子可以看到：abstract 不仅可以修饰类，还可以修饰成员方法，被修饰的方法称为抽象方法，且当抽象类被继承的时候抽象方法必须被重写。</p><p>那普通类里可以有抽象方法吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> </span>&#123;<span class="comment">//The type Sheep must be an abstract class to define abstract methods</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;<span class="comment">//The abstract method eat in type Sheep can only be defined by an abstract class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到分别再类名和方法名出给出了错误提示，说明普通类里不能创建抽象方法，换句话说：<strong>若一个类里有抽象方法，那这个类肯定是抽象类</strong>。</p><p>当 Dog 类也是抽象类时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 Dog 类虽然继承了 Animal 类，但是不需要重写父类中的抽象方法。所以任何类继承抽象类必须重写抽象方法的结论是不准确的，应该是：<strong>除了抽象类外的任何类继承抽象类必须重写父类抽象方法。</strong></p><h3 id="来做个总结："><a href="#来做个总结：" class="headerlink" title="来做个总结："></a>来做个总结：</h3><ol><li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十七）—— instanceof 关键字详解</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase37-instanceof/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase37-instanceof/</id>
    <published>2020-02-23T15:21:41.000Z</published>
    <updated>2020-02-23T16:43:43.512Z</updated>
    
    <content type="html"><![CDATA[<p><em>严格来说 instanceof 是 Java 中的一个双目运算符，由于它是由字母组成的，所以也是 Java 的保留关键字。在 Java 中可以使用 instanceof 关键字判断一个对象是否为一个类（或接口、抽象类、父类）的实例。</em></p><a id="more"></a><hr><p>instanceof 的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj <span class="keyword">instanceof</span> Class;</span><br></pre></td></tr></table></figure><p>obj 代表某个类型的对象，Class 代表某个类或接口，当 obj 是 class 类（或接口）的实例或者子类实例时，结果 result 返回 true，否则返回 false。</p><p>instanceof 三种用法：</p><h3 id="1-判断-obj-是否为某个类对象；"><a href="#1-判断-obj-是否为某个类对象；" class="headerlink" title="1. 判断 obj 是否为某个类对象；"></a>1. 判断 obj 是否为某个类对象；</h3><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.println(cat <span class="keyword">instanceof</span> Cat);<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-判断-obj-是否为接口实现类；"><a href="#2-判断-obj-是否为接口实现类；" class="headerlink" title="2. 判断 obj 是否为接口实现类；"></a>2. 判断 obj 是否为接口实现类；</h3><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">List arrlist1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList arrlist2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(arrlist1 <span class="keyword">instanceof</span> List); <span class="comment">//true</span></span><br><span class="line">System.out.println(arrlist2 <span class="keyword">instanceof</span> List); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List 是 java.util 内的一个接口，ArrayList 是 List 的实现类。（到集合时详细讲讲）</p><h3 id="3-判断-obj-是否是某类的子类或者间接子类；"><a href="#3-判断-obj-是否是某类的子类或者间接子类；" class="headerlink" title="3. 判断 obj 是否是某类的子类或者间接子类；"></a>3. 判断 obj 是否是某类的子类或者间接子类；</h3><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Doctor 类 之前用过的直接拿来用了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String ks;<span class="comment">//科室</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写了父类 work 医生的工作是救人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"healing petients"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getKs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKs</span><span class="params">(String ks)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ks = ks;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Doctor doc = <span class="keyword">new</span> Doctor();</span><br><span class="line">System.out.println(doc <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">System.out.println(doc <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">System.out.println(person <span class="keyword">instanceof</span> Doctor);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Doctor 类继承了 Person 类，Person 是 Object 的子类，Doctor 是 Object 的间接子类。<br>（以上结果都验证过了放心食用。）</p><p>要注意的是 obj 必须为引用类型或者 null，不能是基本类型。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//Incompatible conditional operand types int and Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本类型编译不能通过。</p><p>当 obj = null 时和任何类比都是 false ，因为 null 不代表任何类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(str <span class="keyword">instanceof</span> Object);<span class="comment">//false</span></span><br><span class="line">System.out.println(str <span class="keyword">instanceof</span> String);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="instanceof-三目运算符"><a href="#instanceof-三目运算符" class="headerlink" title="instanceof 三目运算符"></a>instanceof 三目运算符</h3><p>假设有 Dog 类和 Cat 继承了 Animal 类，现在需要判断 obj 对象是否可转型为 Dog 对象，是返回 Dog 对象，否则返回字符串对象，提示不能转型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]  args)</span></span>&#123;</span><br><span class="line">  Animal c = <span class="keyword">new</span> Cat();<span class="comment">//复习向上转型</span></span><br><span class="line">  Animal d = <span class="keyword">new</span> Dog();</span><br><span class="line">  System.out.println(transform(c)); <span class="comment">//不是Dog类型</span></span><br><span class="line">  System.out.println(transform(d)); <span class="comment">//pers.mgg.demo.dt.Dog@15db9742</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">transform</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">  <span class="comment">// true 则向下转型</span></span><br><span class="line">  <span class="keyword">return</span> a <span class="keyword">instanceof</span> Dog ? (Dog)a : <span class="keyword">new</span> String(<span class="string">"不是Dog类型"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;&#125; </span><br></pre></td></tr></table></figure><p>（代码已经验证结果，放心食用）</p></blockquote><p>在类型转换时，食用 instanceof 来做逻辑判断是非常必要的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;严格来说 instanceof 是 Java 中的一个双目运算符，由于它是由字母组成的，所以也是 Java 的保留关键字。在 Java 中可以使用 instanceof 关键字判断一个对象是否为一个类（或接口、抽象类、父类）的实例。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十六）——多态</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase36-dt/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase36-dt/</id>
    <published>2020-02-23T07:12:58.000Z</published>
    <updated>2020-02-24T16:09:52.572Z</updated>
    
    <content type="html"><![CDATA[<p><em>多态性是面向对象编程的又一个重要特征，它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。</em></p><a id="more"></a><hr><p>对面向对象来说，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是大家通常所说的多态性。</p><p>Java 实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。</p><ul><li>继承：在多态中必须存在有继承关系的子类和父类。</li><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法（壳子不变，核心重新写）。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。</li></ul><blockquote><p>向上转型是java中类型转换的知识，这里说一下不再做单独解读<br>java对象的类型转换分为向上转和向下转<br><strong>1. 向上转型</strong><br>父类引用指向子类对象为向上转型，语法格式如下：<br>fatherClass obj = new sonClass();</p><p>如 Cat 类继承了 Animal 类，Cat 类向上转型的方式为：<br>Animal animal = new Cat();</p><p>向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用向上转型可以调用父类类型中的所有成员，不能调用子类类型中特有成员，最终运行效果看子类的具体实现。</p><p><strong>2.向下转型</strong><br>与向上转型相反，子类对象指向父类引用为向下转型，语法格式如下：<br>sonClass obj = (sonClass) fatherClass;</p><p>如通过 Animal 对象创建 Cat 型引用：<br>Animal animal = new Animal();<br>Cat cat = (Cat) animal;</p><p>向下转型可以调用子类类型中所有的成员，不过需要注意的是如果父类引用对象指向的是子类对象，那么在向下转型的过程中是安全的，也就是编译是不会出错误。但是如果父类引用对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现我们开始提到的 Java 强制类型转换异常，一般使用 instanceof 运算符来避免出此类错误。</p><p>在下面的多态例子中会有用到 instanceof ，这里不再举例</p></blockquote><p>继承很好理解，前面也有举过类似的例子，比如，Cat 类和 Dog 类继承 Animal 类，重写了Animal 的run方法，让Cat具有猫的跑动方式，Dog有了狗的跑动方式。</p><p>重写在前面有多次讲解，如<a href="http://www.mggblog.ink/2020/02/21/javabase30-gzff/">构造方法</a>,并且有举重写的例子，在此不再特殊说明。</p><p>举一个多态例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      show(<span class="keyword">new</span> Cat());  <span class="comment">// 以 Cat 对象调用 show 方法</span></span><br><span class="line">      show(<span class="keyword">new</span> Dog());  <span class="comment">// 以 Dog 对象调用 show 方法</span></span><br><span class="line">                </span><br><span class="line">      Animal a = <span class="keyword">new</span> Cat();  <span class="comment">// 向上转型  </span></span><br><span class="line">      a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">      Cat c = (Cat)a;        <span class="comment">// 向下转型  </span></span><br><span class="line">      c.work();        <span class="comment">// 调用的是 Cat 的 work</span></span><br><span class="line">  &#125;  </span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Animal a)</span>  </span>&#123;</span><br><span class="line">      a.eat();  </span><br><span class="line">        <span class="comment">// 类型判断</span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)  &#123;  <span class="comment">// 猫做的事情 </span></span><br><span class="line">            Cat c = (Cat)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123; <span class="comment">// 狗做的事情 </span></span><br><span class="line">            Dog c = (Dog)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类 Animal </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"><span class="comment">//抽象方法吃</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat 类 继承 Animal 并重写抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"吃鱼"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"抓老鼠"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 类 继承 Animal 并重写抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"吃骨头"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"看家"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/23/javabase36-dt/t1.png" alt="实现多态"></p><h3 id="多态有三种实现方法："><a href="#多态有三种实现方法：" class="headerlink" title="多态有三种实现方法："></a>多态有三种实现方法：</h3><p>方式一：重写</p><p>方式二：接口(Interface,后面详细讲)</p><ol><li>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</li><li>java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。</li></ol><p>方式三：抽象类和抽象方法<br>上面例子中 Animal 就是抽象类,类中 eat() 方法为抽象方法，有 abstract 修饰。</p><h3 id="多态的优点："><a href="#多态的优点：" class="headerlink" title="多态的优点："></a>多态的优点：</h3><ol><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;多态性是面向对象编程的又一个重要特征，它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十五）—— super 关键字</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase35-super/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase35-super/</id>
    <published>2020-02-23T03:31:22.000Z</published>
    <updated>2020-02-23T06:46:41.249Z</updated>
    
    <content type="html"><![CDATA[<p><em>由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。</em></p><a id="more"></a><hr><p>super 关键字在讲 this 关键字的时候顺带说了一下，this 代表的是当前基类， super 代表父类，它的功能是：</p><ol><li>在子类的构造方法中显式的调用父类构造方法</li><li>访问父类的成员方法和变量。</li></ol><h2 id="super-调用父类构造方法"><a href="#super-调用父类构造方法" class="headerlink" title="super 调用父类构造方法"></a>super 调用父类构造方法</h2><p>新建 Animal 动物类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">System.out.println(<span class="string">"Animal 无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">System.out.println(<span class="string">"Animal 有参构造  Animal name = "</span>+name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 eclipse 快速生成的两个构造方法时，可以看到方法内部自带 super() ，当前的 super() 是指向父类 Object 的无参构造方法。</p><p>创建 Cat 类继承 Animal 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String type, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test 测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Cat cat1 = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat cat2 = <span class="keyword">new</span> Cat(<span class="string">"狸花猫"</span>, <span class="string">"花花"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase35-super/t1.png" alt="super指向父类构造"></p><p>通过 Cat 两个构造方法，我们看到通过 Super 可以分别调用父类 Animal 的有参和无参构造方法，而且和 this() 一样，要放在方法代码第一行。</p><h2 id="super-访问父类成员"><a href="#super-访问父类成员" class="headerlink" title="super 访问父类成员"></a>super 访问父类成员</h2><p>访问父类成员与 this 访问基类成员的方法一样，就是 super.成员</p><p>我们把上面的 Animal 和 Cat 类改改：</p><p>Animal 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物跳 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.name+<span class="string">" jump"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat 类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写父类 jump 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//其实 this 可以不写</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>.type+<span class="string">" "</span> + <span class="keyword">this</span>.name + <span class="string">" jump"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String type, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line"><span class="comment">// 为父类 属性 name 赋值</span></span><br><span class="line"><span class="keyword">super</span>.name = name;</span><br><span class="line"><span class="comment">// 调用父类 jump 方法</span></span><br><span class="line"><span class="keyword">super</span>.jump();</span><br><span class="line"><span class="comment">// 基类 jump 方法</span></span><br><span class="line"><span class="keyword">this</span>.jump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat 类重写了父类 jump 方法，我们在 Cat 类 有参构造中演示用 super 和 this 分别调用父类和基类属性和方法。</p><p>测试类 Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Cat cat2 = <span class="keyword">new</span> Cat(<span class="string">"狸花猫"</span>, <span class="string">"花花"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase35-super/t2.png" alt="调用成员属性和方法"></p><p>如果是基类中独有的属性和方法，可以省略 this 。</p><blockquote><p>super() 与 this() 都不能在 static 环境中使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十四）——继承</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase34-jc/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase34-jc/</id>
    <published>2020-02-23T02:28:42.000Z</published>
    <updated>2020-02-23T06:47:38.975Z</updated>
    
    <content type="html"><![CDATA[<p><em>继承是面向对象的三大特征之一。继承和现实生活中的“继承”的相似之处是保留一些父辈的特性，从而减少代码冗余，提高程序运行效率。</em></p><a id="more"></a><hr><p>继承需要使用 extends 关键字，用法：基类 extends 父类，extends 直译为“扩展”，其实用扩展来描述基类与父类的关系更加准确。</p><p>基类继承父类后，父类的属性和方法的权限修饰不会变，而且不能继承父类的构造方法。</p><p>举个继承的例子，创建医生 Doctor 类和病人 Patient 类继承 Person 类：</p><p>Person 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">private</span> String gender;<span class="comment">//性别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Doctor 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String ks;<span class="comment">//科室</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写了父类 work 医生的工作是救人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"healing petients"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getKs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKs</span><span class="params">(String ks)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ks = ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Patient 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Patient</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String illness;<span class="comment">//病情</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 看医生</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: seeDoctor   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeDoctor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"see a doctor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIllness</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> illness;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIllness</span><span class="params">(String illness)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.illness = illness;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Patient p = <span class="keyword">new</span> Patient();</span><br><span class="line">p.setAge(<span class="number">20</span>);</span><br><span class="line">p.setGender(<span class="string">"男"</span>);</span><br><span class="line">p.setName(<span class="string">"Tom"</span>);</span><br><span class="line">p.setIllness(<span class="string">"头痛"</span>);</span><br><span class="line">Doctor d = <span class="keyword">new</span> Doctor();</span><br><span class="line">d.setAge(<span class="number">30</span>);</span><br><span class="line">d.setGender(<span class="string">"女"</span>);</span><br><span class="line">d.setName(<span class="string">"Jane"</span>);</span><br><span class="line">d.setKs(<span class="string">"神经内科"</span>);</span><br><span class="line">System.out.print(<span class="string">"病人"</span>+p.getName()+p.getAge()+<span class="string">"岁 "</span>+<span class="string">"因"</span>+p.getIllness()+<span class="string">"  "</span>);</span><br><span class="line">p.seeDoctor();</span><br><span class="line">System.out.print(d.getKs()+<span class="string">"医生"</span>+d.getName()+<span class="string">"  "</span>);</span><br><span class="line">d.work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase34-jc/jc.png" alt="继承了Person类中的属性和方法"></p><blockquote><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>Java 不支持多继承，只允许一个类直接继承另一个类，即子类只能有一个直接父类，extends 关键字后面只能有一个类名，但是一个类可以被多个类继承。<br>还有要注意：</p><ol><li>Object 是所有新定义类的父类，虽然没有 extends 字段。</li><li>父类中的 private 成员在子类中是不可见的，因此在子类中不能直接使用它们。如上面例子中的是通过继承了父类的 getter 和 setter 方法来给父类中的属性赋值的。</li><li>强调单继承的原因是因为 C++ 支持多继承，如果是 C++ 程序员学java很容易不注意。</li></ol></blockquote><p>最后总结继承的优缺点：<br><strong>优点：</strong></p><ol><li>实现代码共享，减少创建类的工作量，使子类可以拥有父类的方法和属性。</li><li>提高代码维护性和可重用性。</li><li>提高代码的可扩展性，更好的实现父类的方法。</li></ol><p><strong>缺点：</strong></p><ol><li>继承是侵入性的。只要继承，就必须拥有父类的属性和方法。</li><li>降低代码灵活性。子类拥有父类的属性和方法后多了些约束。</li><li>增强代码耦合性（开发项目的原则为高内聚低耦合）。当父类的常量、变量和方法被修改时，需要考虑子类的修改，有可能会导致大段的代码需要重构。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;继承是面向对象的三大特征之一。继承和现实生活中的“继承”的相似之处是保留一些父辈的特性，从而减少代码冗余，提高程序运行效率。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十三）——类的封装</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase33-fz/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase33-fz/</id>
    <published>2020-02-23T01:27:36.000Z</published>
    <updated>2020-02-23T06:48:13.835Z</updated>
    
    <content type="html"><![CDATA[<p><em>封装在讲对象和类的时候已经多多少少有说过，接下来的内容会把封装，继承，多态单独说说，有前面的预习，现在看起来就简单多了。</em></p><a id="more"></a><hr><p>封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，只能通过该类提供的方法来实现对隐藏信息的操作和访问。如计算机，内部部件非常复杂，cpu、主板、显卡、电源、内存等等，在外部套一个机箱，使用外部接口供电流流通和人机交互，机箱保护了内部部件的安全。</p><p>封装的特点：</p><ul><li>只能通过规定的方法访问数据。</li><li>隐藏类的实例细节，方便修改和实现。</li></ul><p>类封装一般包含这几步：</p><ol><li>使用 private 修饰类的内部属性；</li><li>设置公有（public）的 setter 和 getter 方法，可以修改 setter 方法对赋值进行定制化修改；</li><li>根据需要确定类方法为私有（private）还是公有（public）；</li><li>根据需要创建有参与无参构造以及 toString 方法。</li></ol><p>举个例子，创建一个 Dog 封装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Dog  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 狗实体类  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MGG  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> Feb 23, 2020</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 跳高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"dog jump !"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的姓名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的姓名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的种类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的种类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toString 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dog [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", type="</span> + type + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age, String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 private 修饰 Dog 类属性意味着外部只能通过公有的 setter 和 getter 方法访问和修改属性，jump 方法可以在任何外部类中访问。当然还可以加入 public 修饰的静态常量和静态方法。</p><p>写一个测试类，新建一个 dog 对象，并赋予属性值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Dog dog1 = <span class="keyword">new</span> Dog();</span><br><span class="line">dog1.setName(<span class="string">"臭蛋"</span>);</span><br><span class="line">dog1.setAge(<span class="number">2</span>);</span><br><span class="line">dog1.setType(<span class="string">"金毛犬"</span>);</span><br><span class="line">Dog dog2 = <span class="keyword">new</span> Dog(<span class="string">"拖孩儿"</span>, <span class="number">3</span>, <span class="string">"哈士奇"</span>);</span><br><span class="line">System.out.println(<span class="string">"dog1的名字："</span> + dog1.getName() + <span class="string">"  年龄："</span> + dog1.getAge());</span><br><span class="line">System.out.println(<span class="string">"dog2的名字："</span> + dog2.getName() + <span class="string">"  年龄："</span> + dog2.getAge());</span><br><span class="line">dog1.jump();</span><br><span class="line">dog2.jump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase33-fz/g.png" alt="封装类的使用"></p><p>可以在 setter 方法中设置限制，比如 age &gt; 3 否则提示超出年龄，不再举例了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;封装在讲对象和类的时候已经多多少少有说过，接下来的内容会把封装，继承，多态单独说说，有前面的预习，现在看起来就简单多了。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十二）——递归算法</title>
    <link href="http://www.mggblog.ink/2020/02/22/javabase32-dg/"/>
    <id>http://www.mggblog.ink/2020/02/22/javabase32-dg/</id>
    <published>2020-02-22T12:02:13.000Z</published>
    <updated>2020-02-22T13:57:23.665Z</updated>
    
    <content type="html"><![CDATA[<p><em>递归算法简单说就是方法调用自己，对递归我也就懂这么一点，学习递归是一个很长的过程，从“学会”、“学好”到“用好”得有很长时间的积累，本篇内容简单说说什么是递归，和什么时候用递归，再深了我也不懂了，以后再补充吧。</em></p><a id="more"></a><hr><h2 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h2><p>我们可以把递归比喻成查词典，查到一个词解释里又有个词不懂，接着去查这个词，然后解释里又有个词不懂，就这样往复往后查，直到弄懂了所涉及到的所有词的意思，问题得以解决。</p><p>在讲<a href="http://www.mggblog.ink/2020/02/17/javabase21-kspx/">快速排序</a>时就已经用到递归算法了。</p><p>阶乘是演示递归算法的一个经典例子，顺带把普通循环的方法也弄上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DgTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归结果和用时</span></span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">int</span> i = jc(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">"10!="</span> + i + <span class="string">" 用时:"</span> + (endTime - startTime) + <span class="string">"ns"</span>);</span><br><span class="line">        <span class="comment">// 循环结果和用时</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">int</span> j = jc_loop(<span class="number">10</span>);</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">"loop_10!="</span> + j + <span class="string">" 用时:"</span> + (endTime - startTime) + <span class="string">"ns"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 阶乘递归示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">result = i * jc(i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jc_loop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 阶乘循环示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jc_loop</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">result *= i;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/22/javabase32-dg/jc.png" alt="10的阶乘"></p><p>从结果中可以看出，递归算法不仅可以用普通循环算法代替，而且普通循环算法在相同结果的情况下所用时间更少。</p><h2 id="递归就是不停地入栈出栈"><a href="#递归就是不停地入栈出栈" class="headerlink" title="递归就是不停地入栈出栈"></a>递归就是不停地入栈出栈</h2><p>当一个方法调用它自身的时候，堆栈就会给新的局部变量和自变量分配内存，方法代码就带着这些新的变量从头执行。递归调用并不产生方法新的拷贝。只有参数是新的。每当递归调用返回时，旧的局部变量和自变量就从堆栈中清除（就这么不停地入栈出栈），运行从方法中的调用点重新开始。递归方法可以说是像“望远镜”一样，可以自由伸缩。</p><p>许多子程序的递归版本执行时会比它们的迭代版本要慢一点，因为它们增加了额外的方法调用的消耗。对一个方法太多的递归调用会引起堆栈崩溃。因为自变量和局部变量的存储都在堆栈中，每次调用都创建这些变量新的拷贝，堆栈有可能被耗尽。如果发生这种情况，Java 的运行时系统就会产生异常。但是，除非递归子程序疯狂运行，否则你大概不会担心这种情况。</p><h2 id="使用递归的好处"><a href="#使用递归的好处" class="headerlink" title="使用递归的好处"></a>使用递归的好处</h2><p>递归的主要优点在于：某些类型的算法采用递归比采用迭代算法要更加清晰和简单。例如快速排序算法按照迭代方法是很难实现的。还有其他一些问题，特别是人工智能问题，就依赖于递归提供解决方案。最后，有些人认为递归要比迭代简单。</p><blockquote><p>当编写递归方法时，你必须使用 if 条件语句在递归调用不执行时来强制方法返回。如果你不这么做，一旦你调用方法，它将永远不会返回。这类错误在使用递归时是很常见的。尽量多地使用 println() 语句，使你可以了解程序的进程。如果发现错误，立即中止程序运行。</p></blockquote><p>递归的学习是循序渐进的，真正完全掌握怕是要很长时间，总的来说，递归与普通循环的不同就是递归把本属于程序员思考的部分内容推给了机器。</p><p>当遇到使用普通循环不好实现的算法时，可以试着使用递归算法。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>我这个程度的写递归知识是真的不太行，在工作中很少用到，唯一用递归的场景就是遍历系统菜单，这个需求凡是数据管理系统大概都得用到，还是很重要的。对递归感兴趣的话多去看看csdn上的博客，这篇博客我以后会再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;递归算法简单说就是方法调用自己，对递归我也就懂这么一点，学习递归是一个很长的过程，从“学会”、“学好”到“用好”得有很长时间的积累，本篇内容简单说说什么是递归，和什么时候用递归，再深了我也不懂了，以后再补充吧。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十一）——析构方法</title>
    <link href="http://www.mggblog.ink/2020/02/22/javabase31-xgff/"/>
    <id>http://www.mggblog.ink/2020/02/22/javabase31-xgff/</id>
    <published>2020-02-22T01:24:13.000Z</published>
    <updated>2020-02-22T14:00:48.690Z</updated>
    
    <content type="html"><![CDATA[<p><em>析构函数的作用和构造函数相反，析构函数被用来在对象不再被使用时销毁对象，释放内存空间（例如用 new 创造出来的空间），而且系统自动执行。</em></p><a id="more"></a><hr><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>Object 类中提供了一个 finalize() 方法，因为 Object 是所有类的父类，所有类都可以重写这个方法。</p><p>finalize 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//具体操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jdk 文档中给出的解释：</p><blockquote><p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 finalize 方法，以配置系统资源或执行其他清除。 </p><p>finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象 或类的终结操作执行了某个操作。finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。 </p><p>Object 类的 finalize 方法执行非特殊性操作；它仅执行一些常规返回。Object 的子类可以重写此定义。 </p><p>Java 编程语言不保证哪个线程将调用某个给定对象的 finalize 方法。但可以保证在调用 finalize 时，调用 finalize 的线程将不会持有任何用户可见的同步锁定。如果 finalize 方法抛出未捕获的异常，那么该异常将被忽略，并且该对象的终结操作将终止。 </p><p>在启用某个对象的 finalize 方法后，将不会执行进一步操作，直到 Java 虚拟机再次确定尚未终止的任何线程无法再通过任何方法访问此对象，其中包括由准备终止的其他对象或类执行的可能操作，在执行该操作时，对象可能被丢弃。 </p><p>对于任何给定对象，Java 虚拟机最多只调用一次 finalize 方法。 </p><p>finalize 方法抛出的任何异常都会导致此对象的终结操作停止，但可以通过其他方法忽略它。 </p></blockquote><p>对象的 finalize 方法具有以下特点：</p><ul><li>垃圾回收器是否会执行该方法以及何时执行该方法，都是不确定的。</li><li>finalize() 方法有可能使用对象复活，使对象恢复到可触及状态。</li><li>垃圾回收器在执行 finalize() 方法时，如果出现异常，垃圾回收器不会报告异常，程序继续正常运行。</li></ul><p>举个例子：</p><p>计数类 Count ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建对象时计数加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟销毁对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 销毁对象是变量计数减一</span></span><br><span class="line">count--;</span><br><span class="line">System.out.println(<span class="string">"对象销毁"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数查询方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getCount</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类 Test ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">Count c = <span class="keyword">new</span> Count();</span><br><span class="line">System.out.println(<span class="string">"创建对象c当前count："</span> + c.getCount());</span><br><span class="line">Count c2 = <span class="keyword">new</span> Count();</span><br><span class="line">System.out.println(<span class="string">"创建对象c2当前count："</span> + c2.getCount());</span><br><span class="line">c.finalize();</span><br><span class="line">System.out.println(<span class="string">"销毁对象c当前count："</span> + c2.getCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/22/javabase31-xgff/c.png" alt="模拟对象销毁"></p><p>finalize 方法具有不确定性，如果需要手动对象回收，使用  System.gc() 或者 Runtime.gc()  更好点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;析构函数的作用和构造函数相反，析构函数被用来在对象不再被使用时销毁对象，释放内存空间（例如用 new 创造出来的空间），而且系统自动执行。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十）——构造方法</title>
    <link href="http://www.mggblog.ink/2020/02/21/javabase30-gzff/"/>
    <id>http://www.mggblog.ink/2020/02/21/javabase30-gzff/</id>
    <published>2020-02-21T07:59:32.000Z</published>
    <updated>2020-02-21T14:17:54.413Z</updated>
    
    <content type="html"><![CDATA[<p><em>构造方法是类的特殊方法，创建类时会默认创建一个没有参数，没有具体方法体的构造方法，称为无参构造，还可以自己写有参数的构造完成类初始化，下面详细说说构造方法的用法。</em></p><a id="more"></a><hr><p>方法名与类名一模一样的方法称为构造方法。</p><p>构造方法有以下特点：</p><ul><li>方法名必须与类名相同</li><li>可以有 0 个、1 个或多个参数</li><li>没有任何返回值，包括 void</li><li>默认返回类型就是对象类型本身</li><li>只能与 new 运算符结合使用</li></ul><p>值得注意的是，如果为构造方法定义了返回值类型或使用 void 声明构造方法没有返回值，编译时不会出错，但 Java 会把这个所谓的构造方法当成普通方法来处理。</p><p>构造方法是在创建对象时使用的，其他任何修饰符对他来说没有意义。</p><p>构造方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String gender;</span><br><span class="line"><span class="keyword">public</span> String addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"mgg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> addr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String gender, String addr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line"><span class="keyword">this</span>.addr = addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//无参构造</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(person.name);</span><br><span class="line">System.out.println(<span class="string">"下面为有参构造："</span>);</span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Person person2 = <span class="keyword">new</span> Person(<span class="string">"kangkang"</span>,<span class="string">"男"</span>,<span class="string">"幻想乡木吉镇比利街001号"</span>);</span><br><span class="line">System.out.println(person2.name);</span><br><span class="line">System.out.println(person2.gender);</span><br><span class="line">System.out.println(person2.addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/21/javabase30-gzff/c.png" alt="两种构造用法"></p><p>提示：无参数的构造方法也被称为 Nullary 构造方法。只有编译程序自动加入的构造方法，才称为默认构造函数。如果自行编写无参数、没有内容的构造函数，就不称为默认构造函数了（只是 Nullary 构造函数）。虽然只是名词定义，不过认证考试时要区别一下两者的不同。</p><p>如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。</p><p>如果类中写了有参数的构造方法，但是还想使用 Person p = new Person() 创建对象，必须手动在 Person 中添加无参构造。</p><p>有参数的构造方法是对无参构造的重载，前面已经多次提到过了，而且根据需要，可以创建任意参数的构造方法。</p><blockquote><p>重载（overload）的含义：方法名相同参数不同，无论是参数的类别，还是参数的个数。<br>区别于重写（overwrite）：在类继承时可以重写父类方法，方法名和参数完全一致，方法体不同。另一个是在实现了类接口必须重写接口中的抽象方法。</p></blockquote><p>举一个重写父类方法的例子：</p><p>父类 Person 类，新添加了 work 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String gender;</span><br><span class="line"><span class="keyword">public</span> String addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"mgg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> addr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String gender, String addr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line"><span class="keyword">this</span>.addr = addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: work   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 普通人工作 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Person work"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类 Doctor 类 重写了父类 work 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写了父类 work 医生的工作是救人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"healing petients"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建父类对象</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"kangkang"</span>, <span class="string">"男"</span>, <span class="string">"幻想乡木吉镇比利街001号"</span>);</span><br><span class="line">p.work();</span><br><span class="line">Doctor doc = <span class="keyword">new</span> Doctor();</span><br><span class="line">doc.work();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/21/javabase30-gzff/cx.png" alt="重写父类 work 方法"></p><p>重写与重载的区别要记牢，虽然没人去抓概念，但是如果在什么场合说混了那就太难堪了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;构造方法是类的特殊方法，创建类时会默认创建一个没有参数，没有具体方法体的构造方法，称为无参构造，还可以自己写有参数的构造完成类初始化，下面详细说说构造方法的用法。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十九）—— main() 方法</title>
    <link href="http://www.mggblog.ink/2020/02/21/javabase29-main/"/>
    <id>http://www.mggblog.ink/2020/02/21/javabase29-main/</id>
    <published>2020-02-21T01:45:43.000Z</published>
    <updated>2020-02-21T02:37:26.484Z</updated>
    
    <content type="html"><![CDATA[<p><em>Java中，mian 方法是所有程序的入口，与其他方法有很大的不同，从开始到现在 main 方法已经用过很多次了，但是从来没有详细说明过 main 方法的特点，本篇内容来补充这个知识点。</em></p><a id="more"></a><hr><h2 id="Java-main-方法"><a href="#Java-main-方法" class="headerlink" title="Java main() 方法"></a>Java main() 方法</h2><p>main 方法有只有一种写法，格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 main 方法代码发现：</p><ul><li>main 方法是公有的；</li><li>main 方法是静态方法；（在当前类的 main 里调用其他方法，那这个方法也必须是 static 修饰）</li><li>main 方法没有返回值；</li><li>main 方法的参数是字符串数组。（用来接收执行 Java 程序的命令行参数。命令行参数作为字符串，按照顺序依次对应字符串数组中的元素。）</li></ul><p>一定要注意，main 方法的定义中只有参数名 args 是可以改变的，其他都是固定格式，不能添不能少。但是我们约定参数名和java规范中的名字一样，所以 args 也是不能改的。</p><p>注意因为 static 修饰，main 方法里调用的所有方法必是静态方法，否者无法调用，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">dogJump();</span><br><span class="line">catJump();<span class="comment">//Cannot make a static reference to the non-static method catJump() from the type Test</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dogJump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Dog jump!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catJump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Cat jump!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个类，下面通过 Windows 命令行工具，查看 main 方法里参数的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = args.length; <span class="comment">// 获取参数数量</span></span><br><span class="line">System.out.println(<span class="string">"一共有 "</span> + n + <span class="string">" 个参数"</span>);</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 判断参数个数是否大于0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">System.out.println(args[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行过程：<br><img src="/2020/02/21/javabase29-main/m.png" alt="通过控制台输入参数"></p><p>可以发现 main 方法可以通过控制台传递字符串参数。</p><p>一个程序只能有一个 main 方法，通常做测试用，比如写了几个类，需要一个入口来测试类中方法是否正确。我们称为单元测试，单元测试在开发中非常重要。</p><p>后面会遇到 Junit ，一个专门用来做单元测试的工具，到时候再详细介绍用法。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Java中，mian 方法是所有程序的入口，与其他方法有很大的不同，从开始到现在 main 方法已经用过很多次了，但是从来没有详细说明过 main 方法的特点，本篇内容来补充这个知识点。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十八）——类中常见关键字（访问权限、static、final）</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase28-lgjz/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase28-lgjz/</id>
    <published>2020-02-20T11:49:51.000Z</published>
    <updated>2020-02-21T02:27:38.571Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇把类中常用的关键字单独拿出来说说，<strong>内容包含：访问权限控制关键字 private、friendly、protected、public，静态关键字 static，完结器 final 关键字</strong></em></p><a id="more"></a><hr><h2 id="一、访问权限控制修饰符（private、friendly、protected、public）"><a href="#一、访问权限控制修饰符（private、friendly、protected、public）" class="headerlink" title="一、访问权限控制修饰符（private、friendly、protected、public）"></a>一、访问权限控制修饰符（private、friendly、protected、public）</h2><p>前面提到，类是对对象的封装，既然是封装，那出发点肯定是不想让箱子外部随机接触箱内，所以设置访问权限，想让你看的给你看，不想的外部怎么都访看不见。</p><ol><li><p>类修饰符：public，default（不用写出来）<br>这四个关键字并不是随处都能用，其中 public 只能用在类声明中，在类声明中，除了使用 public 还可以什么都不写，不写的话权限默认为 default ，两者的不同为：<strong>public 声明的类可以被其他包调用，default（不加修饰符） 权限的类只能在包内使用</strong>。</p></li><li><p>成员变量与成员方法修饰符（private、friendly、protected、public）</p></li></ol><p>四种修饰符权限差异：</p><table><thead><tr><th>访问范围</th><th>private</th><th>friendly(默认)</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类</td><td>可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>同一包中的其他类</td><td>不可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的子类</td><td>不可访问</td><td>不可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的非子类</td><td>不可访问</td><td>不可访问</td><td>不可访问</td><td>可访问</td></tr></tbody></table><p>简短叙述一下（权限大小也按1.2.3.4.排，越往下越大）：</p><ol><li><p>private<br>用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用。</p></li><li><p>friendly<br>如果一个类没有访问控制符，说明它具有默认的访问控制特性。这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，即使其他包中有该类的子类。这种访问特性又称为包访问性（package private）。</p></li><li><p>protected<br>用保护访问控制符 protected 修饰的类成员可以被三种类所访问：该类自身、与它在同一个包中的其他类以及在其他包中的该类的子类。使用 protected 修饰符的主要作用，是允许其他包中它的子类来访问父类的特定属性和方法，否则可以使用默认访问控制符。</p></li><li><p>public<br>当一个类被声明为 public 时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用 import 语句引入 public 类，就可以访问和引用这个类。</p></li></ol><blockquote><p>每个程序的主类必须是 public 。</p></blockquote><p>在讲类的时候里面有提到 private 与 public的用法，其他两个用法实在很少用到，做项目不可能吧权限细分的那么清楚，找很多麻烦。</p><h2 id="二、static-关键字（加一个静态导入的知识）"><a href="#二、static-关键字（加一个静态导入的知识）" class="headerlink" title="二、static 关键字（加一个静态导入的知识）"></a>二、static 关键字（加一个静态导入的知识）</h2><p>类中的属性和方法概括为类成员，带有 static 关键字修饰的称为：静态成员，静态成员为类所有，不依赖与任何对象，只要类被加载，就可以被访问。</p><p>前面有用到了 static 修饰的属性和方法，调用语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.方法/属性;</span><br></pre></td></tr></table></figure><p>再举个例子加深印象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">"kangkang"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: run   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 男孩跑步 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">" is running！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 男孩跳 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">" is jumpping！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//创建两个 boy 对象</span></span><br><span class="line">Boy boy1 = <span class="keyword">new</span> Boy();</span><br><span class="line">Boy boy2 = <span class="keyword">new</span> Boy();</span><br><span class="line">System.out.println(<span class="string">"静态变量 name 值："</span>+Boy.name);</span><br><span class="line">boy1.jump();</span><br><span class="line">boy2.jump();</span><br><span class="line"><span class="comment">// 在这里改变静态变量值</span></span><br><span class="line">Boy.name = <span class="string">"jhon"</span>;</span><br><span class="line">System.out.println(<span class="string">"------静态变量值改变--------"</span>);</span><br><span class="line">System.out.println(<span class="string">"静态变量 name 值："</span>+Boy.name);</span><br><span class="line">boy1.jump();</span><br><span class="line">boy2.jump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/20/javabase28-lgjz/s.png" alt="静态成员不依赖对象"></p><p>我们发现，静态变量值改变时，使用它的每一个对象也会作出相应改变，如果是普通成员变量的话，不同对象的值是没有干扰的。</p><p>静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。</p><p>如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。</p><blockquote><p>除了静态方法静态变量，类中还可以有静态代码块，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticCode</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Boy.i); <span class="comment">//结果为 11</span></span><br></pre></td></tr></table></figure><p>在直接使用时，i 已经自加过了，提高了代码效率？我实在不知道有什么用。</p></blockquote><blockquote><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>在 JDK 1.5 之后增加了一种静态导入的语法，用于导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法。如果一个类中的方法全部是使用 static 声明的静态方法，则在导入时就可以直接使用 import static 的方式导入。</p><p>静态导入使用 import static 语句，静态导入也有两种语法，分别用于导入指定类的单个静态成员变量、方法和全部静态成员变量、方法，其中导入指定类的单个静态成员变量、方法的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.ClassName.fieldName|methodName;</span><br></pre></td></tr></table></figure><p>上面语法导入 package.ClassName 类中名为 fieldName 的静态成员变量或者名为 methodName 的静态方法。例如，可以使用import static java.lang.System.out;语句来导入 java.lang.System 类的 out 静态成员变量。</p><p>导入指定类的全部静态成员变量、方法的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.ClassName.*;</span><br></pre></td></tr></table></figure><p>上面语法中的星号只能代表静态成员变量或方法名。</p><p><strong>说那么多，其实只需与普通 import 对比下就行了，一句话： import 和 import static 的作用，使用 import 可以省略写包名，而使用 import static 可以省略类名。</strong><br>而且在开发过程中，没什么机会让你手动导入。除了遇到大佬自己写的工具类。</p></blockquote><h2 id="三、final-关键字"><a href="#三、final-关键字" class="headerlink" title="三、final 关键字"></a>三、final 关键字</h2><p>final 的意义就是无法再改变，声明为多少就是多少。</p><p>final 有如下限制作用：</p><ul><li><p>如果 final 用在了变量前面，变量就变为常量，无法在改变，</p></li><li><p>如果 final 加在方法前面，表明方法无法被重写，重写的意思就是方法名和参数一样，方法体不一样。</p></li><li><p>如果 final 加在了类前，表明类无法被继承。</p></li></ul><p>但是在使用时应该注意一下几点：</p><ol><li>在变量中，如果使用 final ，成为常量，可以不赋值，但是在使用前必须先赋值，赋值之后就无法改变了。</li><li>对基本类型变量来说是其值不可变，而对对象引用类型变量来说其引用不可再变。</li><li>在开发中我们约定，如果使用 final 定义常量，常量的名字使用全大写字符，如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP = <span class="string">"192.168.1.1"</span>;</span><br></pre></td></tr></table></figure></li><li>如果 final 修饰了类，就不需要在类方法前加 final 操作没有意义。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本篇把类中常用的关键字单独拿出来说说，&lt;strong&gt;内容包含：访问权限控制关键字 private、friendly、protected、public，静态关键字 static，完结器 final 关键字&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十七）——注释</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase27-doc/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase27-doc/</id>
    <published>2020-02-20T07:24:38.000Z</published>
    <updated>2020-02-21T01:14:44.977Z</updated>
    
    <content type="html"><![CDATA[<p><em>学过了类的各种东西，现在说一个很简单但是很重要的东西，就是注释——javadoc，简单是因为只需要按几下按键就出来了，重要是因为，有注释会给予看程序的其他人极大的方便，其他人不用去猜你写这个类做啥用，这个方法干嘛用。大大提高了程序的可读性，维护起来容易多了。</em></p><a id="more"></a><hr><p>虽然从事开发工作时间不长，但是从我敲第一行代码开始就养成写注释的习惯了，几乎每个方法和类都会写注释，毕竟写个注释用不了几秒。也有遇到大佬不写注释的，类也不写，方法也不写，用到时都要去猜去试，浪费不少时间，大概这就是大佬把，哈哈哈。下面演示一下在 Eclipse 下如何快速生成注释。</p><p>生成注释前必须要先做配置，默认的注释过于简单，配置流程如下：<br><img src="/2020/02/20/javabase27-doc/s1.png" alt="步骤1"><br><img src="/2020/02/20/javabase27-doc/s2.png" alt="步骤2"><br><img src="/2020/02/20/javabase27-doc/s3.png" alt="步骤3"><br><img src="/2020/02/20/javabase27-doc/s4.png" alt="步骤4"><br><img src="/2020/02/20/javabase27-doc/s5.png" alt="步骤5"></p><p>我把我的配置写出来，我就配置了三个，你也可以去百度搜“eclipse 注释模板”挑选自己喜欢的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Files 文件</span></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * All rights Reserved, Designed By www.mggblog.ink</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>:  $&#123;file_name&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> $&#123;package_name&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:Description  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: mgg     </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:   $&#123;date&#125; $&#123;time&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Types   类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: $&#123;type_name&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;todo&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $&#123;user&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> $&#123;date&#125;  </span></span><br><span class="line"><span class="comment"> * $&#123;tags&#125;  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods  方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: $&#123;enclosing_method&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;todo&#125; </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: $&#123;user&#125;  </span></span><br><span class="line"><span class="comment"> * $&#123;tags&#125;        </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>下面说如何用，上图：<br><img src="/2020/02/20/javabase27-doc/demo.gif" alt="/**+回车"></p><p>然后编辑 Description ,描述作用。方法上生成注释的操作也是一样的，不举例了。</p><p>最后效果</p><p><img src="/2020/02/20/javabase27-doc/sl.png" alt="注释示例"></p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>一定要养成写注释的好习惯啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;学过了类的各种东西，现在说一个很简单但是很重要的东西，就是注释——javadoc，简单是因为只需要按几下按键就出来了，重要是因为，有注释会给予看程序的其他人极大的方便，其他人不用去猜你写这个类做啥用，这个方法干嘛用。大大提高了程序的可读性，维护起来容易多了。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十六）——创建对象（显式、隐式）</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase26-newobj/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase26-newobj/</id>
    <published>2020-02-20T03:09:14.000Z</published>
    <updated>2020-02-21T01:14:43.609Z</updated>
    
    <content type="html"><![CDATA[<p><em>把对象创建的过程称为类的实例化，如果类没有实例化，无论是类属性还是方法都无法使用（除了 static 修饰的），本篇内容学习如何创建对象，<strong>主要内容有：三种显式、一种隐式创建方法</strong></em></p><a id="more"></a><hr><h2 id="一、显式创建对象"><a href="#一、显式创建对象" class="headerlink" title="一、显式创建对象"></a>一、显式创建对象</h2><p>显式创建对象有四种：new 、java.lang.Class 类方法创建、对象 clone 方法、 java.io.ObjectlnputStream 对象的 readObject() 方法。</p><h3 id="1-new-关键字创建对象"><a href="#1-new-关键字创建对象" class="headerlink" title="1.new 关键字创建对象"></a>1.new 关键字创建对象</h3><p>这个是最常用的方式，前面也多次使用，这里不再多叙述，new 的语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型 对象名 = <span class="keyword">new</span> 类型();</span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line">String str = <span class="keyword">new</span> String();</span><br><span class="line"><span class="comment">// 有时候用不着对象名 ——匿名对象</span></span><br><span class="line">System.out.print(<span class="keyword">new</span> String(<span class="string">"This is kangkang!!"</span>));</span><br></pre></td></tr></table></figure><blockquote><p><strong>匿名对象</strong><br>没有明确给出对象名，普通对象需要同时在栈和堆中开辟空间，匿名对象只占用堆空间，而且匿名对象时一次性的，如果当前方法里值与需要用到一次对象，可以采用这种写法，通常作为参数使用。</p></blockquote><h3 id="2-使用-newlnstance-方法"><a href="#2-使用-newlnstance-方法" class="headerlink" title="2.使用 newlnstance() 方法"></a>2.使用 newlnstance() 方法</h3><p>借助了 java.lang.Class 类提供的 newInstance 方法，首先创建 Class 对象（注意区分 Class 与 class，Class是一个具体的类，class 是类的概念，一个关键字），Class 对象无法通过 new 新建，需要借助静态方法 .forName 完成对象创建。Class 类功能很强大，支持了 java 中很重要的 “反射机制” ，反射机制后面单独讲。</p><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class</span></span><br><span class="line">Class 类对象名称 = Class.forName(要实例化的类全称);</span><br><span class="line">类名 对象名 = (类名)Class类对象名称.newInstance();</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// forname 中参数 一定是类的完整路径，要带包名</span></span><br><span class="line">Class cls = Class.forName(<span class="string">"demo_class.Student"</span>);</span><br><span class="line">Student stu = (Student) cls.newInstance();</span><br><span class="line">stu.study();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到了昨天建的 Student 类，要提醒的是，使用 forName 时，参数是类的完整路径，一定要带包名。</p><blockquote><p>提到包名就要说说包命名规范，通常为 com.公司.项目.[package]…. 这个 com 是 company 的缩写，说明是公司项目，那个人项目呢？</p><p>包命名有如下规范：</p><ol><li>个人的项目命名：</li></ol><ul><li>indi ： 个体项目（individual），指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。 包名为“indi.发起者名.项目名.模块名……”</li><li>onem ： 单人项目（one-man），推荐用indi，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。 包名为“onem.发起者名.项目名.模块名……”</li><li>pers ： 个人项目（personal），指个人发起，独自完成，可分享的项目，copyright主要属于个人。 包名为“pers.个人名.项目名.模块名.……”</li><li>priv ： 私有项目（private），指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。 包名为“priv.个人名.项目名.模块名.……”</li></ul><ol start="2"><li>团体的项目命名:</li></ol><ul><li>team： 团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有。 包名为“team.团队名.项目名.模块名.……”</li><li>com ： 公司项目，copyright由项目发起的公司所有。 包名为“com.公司名.项目名.模块名.……”</li></ul><p>比如上面的测试类所处的包正确的包名为：pers.mgg.demo.test </p></blockquote><p>Student 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do homework"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现接口后 重写 clone方法  右击→ Source → Override/Implement Methods</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/2020/02/20/javabase26-newobj/gi.png" alt="使用 newInstance 创建 Student 对象"></p><h3 id="3-使用-clone-方法"><a href="#3-使用-clone-方法" class="headerlink" title="3.使用 clone() 方法"></a>3.使用 clone() 方法</h3><p>该方法很少用，使用该方法创建对象时，要实例化的类必须继承 java.lang.Cloneable 接口。 调用对象的 clone() 方法创建对象的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名对象名 = (类名)已创建好的类对象名.clone();</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">Student stu2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stu2 = (Student) stu1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">stu2.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/20/javabase26-newobj/gi.png" alt="异常处理"></p><blockquote><p>代码中的 try  catch  是异常处理，详细内容到后面异常处理再说，这里稍微提一下：</p><p><img src="/2020/02/20/javabase26-newobj/yc.png" alt="异常处理"></p><p><img src="/2020/02/20/javabase26-newobj/yc2.png" alt="两种不同的异常处理"></p><p>在实际开发中用 try catch 比较多</p></blockquote><h2 id="二、隐式创建"><a href="#二、隐式创建" class="headerlink" title="二、隐式创建"></a>二、隐式创建</h2><p>隐式创建其实前面经常用了，举个例子就是 String str = “oh! awesome!!” 。</p><p>以及当使用字符串拼接时  str = str+”come on”  也会隐式创建对象，str 已经不是原来的 str 了。</p><p>最后 java 虚拟机在加载 .class 文件时，都会创建一个上面说到的 java.lang.Class 对象，用来封装类在方法区内的数据结构。</p><blockquote><p>垃圾回收（jvm gc）<br>每个对象都是相互独立的，在内存中占有独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成了垃圾，由 Java 虚拟机自带的垃圾回收机制处理。</p></blockquote><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>显式的三种方法，前两种要掌握，clone 方法要了解，隐式就没什么可说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;把对象创建的过程称为类的实例化，如果类没有实例化，无论是类属性还是方法都无法使用（除了 static 修饰的），本篇内容学习如何创建对象，&lt;strong&gt;主要内容有：三种显式、一种隐式创建方法&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
