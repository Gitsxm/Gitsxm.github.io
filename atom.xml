<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MggBlog</title>
  
  <subtitle>MggBlog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gitsxm.github.io/"/>
  <updated>2020-02-28T13:21:42.584Z</updated>
  <id>https://gitsxm.github.io/</id>
  
  <author>
    <name>Mgg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA零基础筑基到修仙（五十六）——转换流</title>
    <link href="https://gitsxm.github.io/2020/02/28/javabase56-transtream/"/>
    <id>https://gitsxm.github.io/2020/02/28/javabase56-transtream/</id>
    <published>2020-02-28T12:37:23.000Z</published>
    <updated>2020-02-28T13:21:42.584Z</updated>
    
    <content type="html"><![CDATA[<p><em>正常情况下，字节流可以对所有的数据进行操作，但是有些时候在处理一些文本时我们要用到字符流，比如，查看文本的中文时就是需要采用字符流更为方便。所以 Java IO 流中提供了两种用于将字节流转换为字符流的转换流。</em></p><a id="more"></a><hr><p>InputStreamReader 用于将字节输入流转换为字符输入流，其中 OutputStreamWriter 用于将字节输出流转换为字符输出流。使用转换流可以在一定程度上避免乱码，还可以指定输入输出所使用的字符集。</p><p>举个例子：<br>将 eclipse 编码环境设置为 gbk ，新建 .txt 文件中存储中文，然后读取。正常情况下是乱码，使用转换流让它正常输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String path = <span class="string">"d:\\"</span>;</span><br><span class="line">File file = <span class="keyword">new</span> File(path + <span class="string">"testjava.txt"</span>);</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">int</span> i, b;</span><br><span class="line"><span class="comment">// 使用转换流</span></span><br><span class="line"><span class="keyword">while</span> ((b = isr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不使用转换流</span></span><br><span class="line"><span class="comment">//while((i=fis.read())!=-1) &#123;</span></span><br><span class="line"><span class="comment">//System.out.print((char)i);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">isr.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/28/javabase56-transtream/t1.png" alt="使用转换流输出结果正常"></p><p>如果不使用转换流：</p><p><img src="/2020/02/28/javabase56-transtream/t2.png" alt="不使用转换流输出结果乱码"></p><p>输出的转换流就不举例，大同小异。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;正常情况下，字节流可以对所有的数据进行操作，但是有些时候在处理一些文本时我们要用到字符流，比如，查看文本的中文时就是需要采用字符流更为方便。所以 Java IO 流中提供了两种用于将字节流转换为字符流的转换流。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（五十五）——字符流</title>
    <link href="https://gitsxm.github.io/2020/02/28/javabase55-charstream/"/>
    <id>https://gitsxm.github.io/2020/02/28/javabase55-charstream/</id>
    <published>2020-02-28T03:48:45.000Z</published>
    <updated>2020-02-28T13:25:44.063Z</updated>
    
    <content type="html"><![CDATA[<p><em>虽然字节流十分强大，但是当需要使用流处理 16 位 Unicode 码时就必须使用字符流了，本篇详细介绍字符流的使用。</em></p><a id="more"></a><hr><h2 id="一、字符输入、输出流"><a href="#一、字符输入、输出流" class="headerlink" title="一、字符输入、输出流"></a>一、字符输入、输出流</h2><p><strong>1. 输入</strong><br>Reader 类是所有字符流输入类的父类，该类定义了许多方法，这些方法对所有子类都是有效的。</p><p>Reader 类的常用子类如下。</p><ul><li>CharArrayReader 类：将字符数组转换为字符输入流，从中读取字符。</li><li>StringReader 类：将字符串转换为字符输入流，从中读取字符。</li><li>BufferedReader 类：为其他字符输入流提供读缓冲区。</li><li>PipedReader 类：连接到一个 PipedWriter。</li><li>InputStreamReader 类：将字节输入流转换为字符输入流，可以指定字符编码。</li></ul><p>与 InputStream 类相同，在 Reader 类中也包含 close()、mark()、skip() 和 reset() 等方法，这些方法可以参考 InputStream 类的方法。下面主要介绍 Reader 类中的 read() 方法，如下表所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int read()</td><td>从输入流中读取一个字符，并把它转换为 0~65535 的整数。如果返回 -1， 则表示已经到了输入流的末尾。为了提高 I/O 操作的效率，建议尽量使用下面两种 read()方法</td></tr><tr><td>int read(char[] cbuf)</td><td>从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。 该方法返回读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td></tr><tr><td>int read(char[] cbuf,int off,int len)</td><td>从输入流中读取若干个字符，并把它们保存到参数 cbuf 指定的字符数组中。其中，off 指定在字符数组中开始保存数据的起始下标，len 指定读取的字符数。该方法返回实际读取的字符数，如果返回 -1，则表示已经到了输入流的末尾</td></tr></tbody></table><p><strong>2. 输出</strong><br>与 Reader 类相反，Writer 类是所有字符输出流的父类，该类中有许多方法，这些方法对继承该类的所有子类都是有效的。</p><p>Writer 类的常用子类如下。</p><ul><li>CharArrayWriter 类：向内存缓冲区的字符数组写数据。</li><li>StringWriter 类：向内存缓冲区的字符串（StringBuffer）写数据。</li><li>BufferedWriter 类：为其他字符输出流提供写缓冲区。</li><li>PipedWriter 类：连接到一个 PipedReader。</li><li>OutputStreamReader 类：将字节输出流转换为字符输出流，可以指定字符编码。</li></ul><p>与 OutputStream 类相同，Writer 类也包含 close()、flush() 等方法，这些方法可以参考 OutputStream 类的方法。下面主要介绍 Writer 类中的 write() 方法和 append() 方法，如下表所示</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void write(int c)</td><td>向输出流中写入一个字符</td></tr><tr><td>void write(char[] cbuf)</td><td>把参数 cbuf 指定的字符数组中的所有字符写到输出流中</td></tr><tr><td>void write(char[] cbuf,int off,int len)</td><td>把参数 cbuf 指定的字符数组中的若干字符写到输出流中。其中，off 指定字符数组中的起始下标，len 表示元素个数</td></tr><tr><td>void write(String str)</td><td>向输出流中写入一个字符串</td></tr><tr><td>void write(String str, int off,int len)</td><td>向输出流中写入一个字符串中的部分字符。其中，off 指定字符串中的起始偏移量，len 表示字符个数</td></tr><tr><td>append(char c)</td><td>将参数 c 指定的字符添加到输出流中</td></tr><tr><td>append(charSequence esq)</td><td>将参数 esq 指定的字符序列添加到输出流中</td></tr><tr><td>append(charSequence esq,int start,int end)</td><td>将参数 esq 指定的字符序列的子序列添加到输出流中。其中，start 指定子序列的第一个字符的索引，end 指定子序列中最后一个字符后面的字符的索引，也就是说子序列的内容包含 start 索引处的字符，但不包括 end索引处的字符</td></tr></tbody></table><blockquote><p>注意：Writer 类所有的方法在出错的情况下都会引发 IOException 异常。关闭一个流后，再对其进行任何操作都会产生错误。</p></blockquote><p>接下来详解介绍，文件字符输入、输出流和字符缓冲区输入、输出流。</p><h2 id="二、字符文件输入、输出流"><a href="#二、字符文件输入、输出流" class="headerlink" title="二、字符文件输入、输出流"></a>二、字符文件输入、输出流</h2><p><strong>1. 输入</strong><br>为了读取方便，Java 提供了用来读取字符文件的便捷类——FileReader。该类的构造方法有如下两种重载形式。</p><ul><li>FileReader(File file)：在给定要读取数据的文件的情况下创建一个新的 FileReader 对象。其中，file 表示要从中读取数据的文件。</li><li>FileReader(String fileName)：在给定从中读取数据的文件名的情况下创建一个新 FileReader 对象。其中，fileName 表示要从中读取数据的文件的名称，表示的是一个文件的完整路径。</li></ul><p>在用该类的构造方法创建 FileReader 读取对象时，默认的字符编码及字节缓冲区大小都是由系统设定的。要自己指定这些值，可以在 FilelnputStream 上构造一个 InputStreamReader。</p><blockquote><p>注意：在创建 FileReader 对象时可能会引发一个 FileNotFoundException 异常，因此需要使用 try catch 语句捕获该异常。</p></blockquote><p><strong>2.输出</strong><br>Java 提供了写入字符文件的便捷类——FileWriter，该类的构造方法有如下 4 种重载形式。</p><ul><li>FileWriter(File file)：在指定 File 对象的情况下构造一个 FileWriter 对象。其中，file 表示要写入数据的 File 对象。</li><li>FileWriter(File file,boolean append)：在指定 File 对象的情况下构造一个 FileWriter 对象，如果 append 的值为 true，则将字节写入文件末尾，而不是写入文件开始处。</li><li>FileWriter(String fileName)：在指定文件名的情况下构造一个 FileWriter 对象。其中，fileName 表示要写入字符的文件名，表示的是完整路径。</li><li>FileWriter(String fileName,boolean append)：在指定文件名以及要写入文件的位置的情况下构造 FileWriter 对象。其中，append 是一个 boolean 值，如果为 true，则将数据写入文件末尾，而不是文件开始处。</li></ul><p>在创建 FileWriter 对象时，默认字符编码和默认字节缓冲区大小都是由系统设定的。要自己指定这些值，可以在 FileOutputStream 上构造一个 OutputStreamWriter 对象。</p><p><em>FileWriter 类的创建不依赖于文件存在与否，如果关联文件不存在，则会自动生成一个新的文件。在创建文件之前，FileWriter 将在创建对象时打开它作为输出。如果试图打开一个只读文件，将引发一个 IOException 异常。</em></p><blockquote><p>注意：在创建 FileWriter 对象时可能会引发 IOException 或 SecurityException 异常，因此需要使用 try catch 语句捕获该异常。</p></blockquote><p>字符流和字节流的操作步骤相同，都是首先创建输入流或输出流对象，即建立连接管道，建立完成后进行读或写操作，最后关闭输入/输出流通道。</p><p>举个例子，从文件中读取字符串，然后存到另一个文件中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">String path = <span class="string">"d:\\"</span>;</span><br><span class="line">File file = <span class="keyword">new</span> File(path + <span class="string">"poem.txt"</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(path + <span class="string">"poem-copy.txt"</span>);</span><br><span class="line">FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">fw = <span class="keyword">new</span> FileWriter(file2);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span> ((i = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">String poe = String.valueOf((<span class="keyword">char</span>) i);</span><br><span class="line">                <span class="comment">//读</span></span><br><span class="line">System.out.print(poe);</span><br><span class="line">                <span class="comment">//写</span></span><br><span class="line"><span class="keyword">if</span> (!file2.exists())</span><br><span class="line">file2.createNewFile();</span><br><span class="line">fw.write(poe);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"\npoem-copy.txt 写入完成"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fr.close();</span><br><span class="line">fw.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/28/javabase55-charstream/t1.png" alt="文件字符读写"><br><img src="/2020/02/28/javabase55-charstream/t11.png" alt="npoem-copy.txt"></p><blockquote><p>读文件的时候注意字符编码要一致，文本里的编码为”utf-8”，java 运行环境也要一样，出现乱码的话，点击工具栏 window→perference→搜索 workspace 设置编码，eclipse 默认编码为 GBK，编码只是比较简单，百度了解一下就行了，一般都用 utf-8。</p></blockquote><h2 id="三、字符缓冲区输入输出流"><a href="#三、字符缓冲区输入输出流" class="headerlink" title="三、字符缓冲区输入输出流"></a>三、字符缓冲区输入输出流</h2><p><strong>1. 输入</strong><br>BufferedReader 类主要用于辅助其他字符输入流，它带有缓冲区，可以先将一批数据读到内存缓冲区。接下来的读操作就可以直接从缓冲区中获取数据，而不需要每次都从数据源读取数据并进行字符编码转换，这样就可以提高数据的读取效率。</p><p>BufferedReader 类的构造方法有如下两种重载形式。</p><ul><li>BufferedReader(Reader in)：创建一个 BufferedReader 来修饰参数 in 指定的字符输入流。</li><li>BufferedReader(Reader in,int size)：创建一个 BufferedReader 来修饰参数 in 指定的字符输入流，参数 size 则用于指定缓冲区的大小，单位为字符。</li></ul><p>除了可以为字符输入流提供缓冲区以外，BufferedReader 还提供了 readLine() 方法，该方法返回包含该行内容的字符串，但该字符串中不包含任何终止符，如果已到达流末尾，则返回 null。readLine() 方法表示每次读取一行文本内容，当遇到换行（\n）、回车（\r）或回车后直接跟着换行标记符即可认为某行已终止。</p><p><strong>2. 输出</strong><br>BufferedWriter 类主要用于辅助其他字符输出流，它同样带有缓冲区，可以先将一批数据写入缓冲区，当缓冲区满了以后，再将缓冲区的数据一次性写到字符输出流，其目的是为了提高数据的写效率。</p><p>BufferedWriter 类的构造方法有如下两种重载形式。</p><ul><li>BufferedWriter(Writer out)：创建一个 BufferedWriter 来修饰参数 out 指定的字符输出流。</li><li>BufferedWriter(Writer out,int size)：创建一个 BufferedWriter 来修饰参数 out 指定的字符输出流，参数 size 则用于指定缓冲区的大小，单位为字符。</li></ul><p>该类除了可以给字符输出流提供缓冲区之外，还提供了一个新的方法 newLine()，该方法用于写入一个行分隔符。行分隔符字符串由系统属性 line.separator 定义，并且不一定是单个新行（\n）符。</p><p>举个例子，完成上面例子的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">String path = <span class="string">"d:\\"</span>;</span><br><span class="line">File file = <span class="keyword">new</span> File(path + <span class="string">"poem.txt"</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(path + <span class="string">"poem-copy.txt"</span>);</span><br><span class="line">FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">BufferedReader sbr = <span class="keyword">null</span>;</span><br><span class="line">BufferedWriter sbw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">fw = <span class="keyword">new</span> FileWriter(file2);</span><br><span class="line">sbr = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">sbw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = sbr.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//读 这边要换行</span></span><br><span class="line">System.out.println(line);</span><br><span class="line"><span class="keyword">if</span> (!file2.exists())</span><br><span class="line">file2.createNewFile();</span><br><span class="line"><span class="comment">//写这边没得选 写进去没换行</span></span><br><span class="line">sbw.write(line);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"\npoem-copy.txt 写入完成"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//先关缓冲区</span></span><br><span class="line">sbr.close();</span><br><span class="line">sbw.close();</span><br><span class="line">fr.close();</span><br><span class="line">fw.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子的目的是介绍怎么用，实际需求用不到这么麻烦，适合哪个用哪个，Buffer 的好处就是可以按照行来进行读取和存储，有写数据处理很方便，起到辅助作用。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;虽然字节流十分强大，但是当需要使用流处理 16 位 Unicode 码时就必须使用字符流了，本篇详细介绍字符流的使用。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（五十四）——字节流</title>
    <link href="https://gitsxm.github.io/2020/02/28/javabase54-bytestream/"/>
    <id>https://gitsxm.github.io/2020/02/28/javabase54-bytestream/</id>
    <published>2020-02-28T01:22:59.000Z</published>
    <updated>2020-02-28T13:26:40.631Z</updated>
    
    <content type="html"><![CDATA[<p><em>将数据以字节码的形式输入输出，InputStream 是所有字节输入流的父类，OutStream 是所有字节输出流的父类，两者同为抽象方法，继承的子类重写这些抽象方法，本篇将介绍如何使用输出输入流。</em></p><a id="more"></a><hr><h2 id="一、字节输入流"><a href="#一、字节输入流" class="headerlink" title="一、字节输入流"></a>一、字节输入流</h2><p>InputStream 类及其子类的对象表示字节输入流，InputStream 类的常用子类如下。</p><ul><li>ByteArrayInputStream 类：将字节数组转换为字节输入流，从中读取字节。</li><li>FileInputStream 类：从文件中读取数据。</li><li>PipedInputStream 类：连接到一个 PipedOutputStream（管道输出流）。</li><li>SequenceInputStream 类：将多个字节输入流串联成一个字节输入流。</li><li>ObjectInputStream 类：将对象反序列化。</li></ul><p>使用 InputStream 类的方法可以从流中读取一个或一批字节。</p><p>常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int read()</td><td>从输入流中读取一个 8 位的字节，并把它转换为 0~255 的整数，最后返回整数。如果返回 -1，则表示已经到了输入流的末尾。为了提高 I/O 操作的效率，建议尽量使用 read() 方法的另外两种形式</td></tr><tr><td>int read(byte[] b)</td><td>从输入流中读取若干字节，并把它们保存到参数 b 指定的字节数组中。 该方法返回读取的字节数。如果返回 -1，则表示已经到了输入流的末尾</td></tr><tr><td>int read(byte[] b, int off, int len)</td><td>从输入流中读取若干字节，并把它们保存到参数 b 指定的字节数组中。其中，off 指定在字节数组中开始保存数据的起始下标；len 指定读取的字节数。该方法返回实际读取的字节数。如果返回 -1，则表示已经到了输入流的末尾</td></tr><tr><td>void close()</td><td>关闭输入流。在读操作完成后，应该关闭输入流，系统将会释放与这个输入流相关的资源。注意，InputStream 类本身的 close() 方法不执行任何操作，但是它的许多子类重写了 close() 方法</td></tr><tr><td>int available()</td><td>返回可以从输入流中读取的字节数</td></tr><tr><td>long skip(long n)</td><td>从输入流中跳过参数 n 指定数目的字节。该方法返回跳过的字节数</td></tr><tr><td>void mark(int readLimit)</td><td>在输入流的当前位置开始设置标记，参数 readLimit 则指定了最多被设置标记的字节数</td></tr><tr><td>boolean markSupported()</td><td>判断当前输入流是否允许设置标记，是则返回 true，否则返回 false</td></tr><tr><td>void reset()</td><td>将输入流的指针返回到设置标记的起始处</td></tr></tbody></table><blockquote><p>注意：在使用 mark() 方法和 reset() 方法之前，需要判断该文件系统是否支持这两个方法，以避免对程序造成影响。</p></blockquote><h2 id="二、字节输出流"><a href="#二、字节输出流" class="headerlink" title="二、字节输出流"></a>二、字节输出流</h2><p>OutputStream 类及其子类的对象表示一个字节输出流。OutputStream 类的常用子类如下。</p><ul><li>ByteArrayOutputStream 类：向内存缓冲区的字节数组中写数据。</li><li>FileOutputStream 类：向文件中写数据。</li><li>PipedOutputStream 类：连接到一个 PipedlntputStream（管道输入流）。</li><li>ObjectOutputStream 类：将对象序列化。</li></ul><p>利用 OutputStream 类的方法可以从流中写入一个或一批字节。</p><p>常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void write(int b)</td><td>向输出流写入一个字节。这里的参数是 int 类型，但是它允许使用表达式，而不用强制转换成 byte 类型。为了提高 I/O 操作的效率，建议尽量使用write() 方法的另外两种形式</td></tr><tr><td>void write(byte[] b)</td><td>把参数 b 指定的字节数组中的所有字节写到输出流中</td></tr><tr><td>void write(byte[] b,int off,int len)</td><td>把参数 b 指定的字节数组中的若干字节写到输出流中。其中，off 指定字节数组中的起始下标，len 表示元素个数</td></tr><tr><td>void close()</td><td>关闭输出流。写操作完成后，应该关闭输出流。系统将会释放与这个输出流相关的资源。注意，OutputStream 类本身的 close() 方法不执行任何操作，但是它的许多子类重写了 close() 方法</td></tr><tr><td>void flush()</td><td>为了提高效率，在向输出流中写入数据时，数据一般会先保存到内存缓冲区中，只有当缓冲区中的数据达到一定程度时，缓冲区中的数据才会被写入输出流中。使用 flush() 方法则可以强制将缓冲区中的数据写入输出流，并清空缓冲区</td></tr></tbody></table><h2 id="三、字节数组输入输出流"><a href="#三、字节数组输入输出流" class="headerlink" title="三、字节数组输入输出流"></a>三、字节数组输入输出流</h2><p><strong>1. 输入</strong><br>ByteArrayInputStream 类可以从内存的字节数组中读取数据，该类有如下两种构造方法重载形式。</p><ul><li>ByteArrayInputStream(byte[] buf)：创建一个字节数组输入流，字节数组类型的数据源由参数 buf 指定。</li><li>ByteArrayInputStream(byte[] buf,int offse,int length)：创建一个字节数组输入流，其中，参数 buf 指定字节数组类型的数据源，offset 指定在数组中开始读取数据的起始下标位置，length 指定读取的元素个数。</li></ul><p><strong>2. 输出</strong><br>ByteArrayOutputStream 类可以向内存的字节数组中写入数据，该类的构造方法有如下两种重载形式。</p><ul><li>ByteArrayOutputStream()：创建一个字节数组输出流，输出流缓冲区的初始容量大小为 32 字节。</li><li>ByteArrayOutputStream(int size)：创建一个字节数组输出流，输出流缓冲区的初始容量大小由参数 size 指定。</li></ul><p>ByteArrayOutputStream 类中除了有前面介绍的字节输出流中的常用方法以外，还有如下两个方法。<br>intsize()：返回缓冲区中的当前字节数。<br>byte[] toByteArray()：以字节数组的形式返回输出流中的当前内容。</p><p>举个例子，从一个字节数组中读取数据然后存入到另一个字节数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">byte</span>[] byteData = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">6</span>, <span class="number">0</span>, <span class="number">22</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">55</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">99</span> &#125;; <span class="comment">// 声明一个字节数组</span></span><br><span class="line"><span class="keyword">byte</span>[] newByteArr = <span class="keyword">new</span> <span class="keyword">byte</span>[byteData.length];</span><br><span class="line">ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(byteData);</span><br><span class="line">ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="comment">// 读取字节数组</span></span><br><span class="line"><span class="keyword">int</span> i = bais.read();</span><br><span class="line">System.out.println(<span class="string">"byteData:"</span>);</span><br><span class="line"><span class="keyword">while</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 向输入流写数据</span></span><br><span class="line">baos.write(i);</span><br><span class="line">i = bais.read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输入流转为数组</span></span><br><span class="line">newByteArr = baos.toByteArray();</span><br><span class="line">System.out.println(<span class="string">"\nnewByteArr:"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">byte</span> b : newByteArr)</span><br><span class="line">System.out.print(b + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/28/javabase54-bytestream/t1.png" alt="字节数组输入输出流"></p><h2 id="四、文件输入输出流"><a href="#四、文件输入输出流" class="headerlink" title="四、文件输入输出流"></a>四、文件输入输出流</h2><p><strong>1. 输入</strong><br>FileInputStream 是 Java 流中比较常用的一种，它表示从文件系统的某个文件中获取输入字节。通过使用 FileInputStream 可以访问文件中的一个字节、一批字节或整个文件。</p><p>在创建 FileInputStream 类的对象时，如果找不到指定的文件将拋出 FileNotFoundException 异常，该异常必须捕获或声明拋出。</p><p>FileInputStream 常用的构造方法主要有如下两种重载形式。</p><ul><li>FileInputStream(File file)：通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定。</li><li>FileInputStream(String name)：通过打开一个到实际文件的链接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。</li></ul><p><strong>2. 输出</strong><br>FileOutputStream 类继承自 OutputStream 类，重写和实现了父类中的所有方法。FileOutputStream 类的对象表示一个文件字节输出流，可以向流中写入一个字节或一批字节。在创建 FileOutputStream 类的对象时，如果指定的文件不存在，则创建一个新文件；如果文件已存在，则清除原文件的内容重新写入。</p><p>FileOutputStream 类的构造方法主要有如下 4 种重载形式。</p><ul><li>FileOutputStream(File file)：创建一个文件输出流，参数 file 指定目标文件。</li><li>FileOutputStream(File file,boolean append)：创建一个文件输出流，参数 file 指定目标文件，append 指定是否将数据添加到目标文件的内容末尾，如果为 true，则在末尾添加；如果为 false，则覆盖原有内容；其默认值为 false。</li><li>FileOutputStream(String name)：创建一个文件输出流，参数 name 指定目标文件的文件路径信息。</li><li>FileOutputStream(String name,boolean append)：创建一个文件输出流，参数 name 和 append 的含义同上。</li></ul><blockquote><p>注意：使用构造方法 FileOutputStream(String name,boolean append) 创建一个文件输出流对象，它将数据附加在现有文件的末尾。该字符串 name 指明了原文件，如果只是为了附加数据而不是重写任何已有的数据，布尔类型参数 append 的值应为 true。</p></blockquote><p>对文件输出流有如下四点说明：</p><ol><li>在 FileOutputStream 类的构造方法中指定目标文件时，目标文件可以不存在。</li><li>目标文件的名称可以是任意的，例如 D:\\abc、D:\\abc.de 和 D:\\abc.de.fg 等都可以，可以使用记事本等工具打开并浏览这些文件中的内容。</li><li>目标文件所在目录必须存在，否则会拋出 java.io.FileNotFoundException 异常。</li><li>目标文件的名称不能是已存在的目录。例如 D 盘下已存在 Java 文件夹，那么就不能使用 Java 作为文件名，即不能使用 D:\\Java，否则抛出 java.io.FileNotFoundException 异常。</li></ol><p>举个例子：读取一个文件内容，并输出到另一文件中（用到了之前创建过的文件，没有的话自己手动创建一个）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String path = <span class="string">"d:\\"</span>;</span><br><span class="line">File f = <span class="keyword">new</span> File(path + <span class="string">"filetest.txt"</span>);</span><br><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写入</span></span><br><span class="line">File f2 = <span class="keyword">new</span> File(path + <span class="string">"filetest2.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (!f2.exists())</span><br><span class="line">f2.createNewFile();</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fis = <span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(f2);</span><br><span class="line"><span class="comment">// 创建数组接收每次读取字节</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 每次读取字节数</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span> ((i = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 字节转为字符串输出</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, i));</span><br><span class="line"><span class="comment">// 写入filetest2.txt</span></span><br><span class="line">fos.write(b, <span class="number">0</span>, i);</span><br><span class="line">System.out.println(<span class="string">"filetest2.txt写入成功"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 文件输入输出流一定记着关闭</span></span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/28/javabase54-bytestream/t2.png" alt="文件读取与写入"></p><p>可以去 D 盘看看有没有操作成功。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;将数据以字节码的形式输入输出，InputStream 是所有字节输入流的父类，OutStream 是所有字节输出流的父类，两者同为抽象方法，继承的子类重写这些抽象方法，本篇将介绍如何使用输出输入流。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（五十三）——File 文件操作类</title>
    <link href="https://gitsxm.github.io/2020/02/27/javabase53-file/"/>
    <id>https://gitsxm.github.io/2020/02/27/javabase53-file/</id>
    <published>2020-02-27T14:18:54.000Z</published>
    <updated>2020-02-27T15:33:58.145Z</updated>
    
    <content type="html"><![CDATA[<p><em>在 Java 中，File 类是 java.io 包中唯一代表磁盘文件本身的对象，也就是说，如果希望在程序中操作文件和目录，则都可以通过 File 类来完成。File 类定义了一些方法来操作文件，如新建、删除、重命名文件和目录等。</em></p><a id="more"></a><hr><p>File 类提供了如下三种形式构造方法。</p><ol><li>File(String path)：如果 path 是实际存在的路径，则该 File 对象表示的是目录；如果 path 是文件名，则该 File 对象表示的是文件。</li><li>File(String path, String name)：path 是路径名，name 是文件名。</li><li>File(File dir, String name)：dir 是路径对象，name 是文件名。</li></ol><p>常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean createNewFile</td><td>当且仅当具有该名称的文件尚不存在时，原子地创建一个由该抽象路径名命名的新的空文件。</td></tr><tr><td>boolean canRead()</td><td>测试应用程序是否能从指定的文件中进行读取</td></tr><tr><td>boolean canWrite()</td><td>测试应用程序是否能写当前文件</td></tr><tr><td>boolean delete()</td><td>删除当前对象指定的文件</td></tr><tr><td>boolean exists()</td><td>测试当前 File 是否存在</td></tr><tr><td>String getAbsolutePath()</td><td>返回由该对象表示的文件的绝对路径名</td></tr><tr><td>String getName()</td><td>返回表示当前对象的文件名或路径名（如果是路径，则返回最后一级子路径名）</td></tr><tr><td>String getParent()</td><td>返回当前 File 对象所对应目录（最后一级子目录）的父目录名</td></tr><tr><td>boolean isAbsolute()</td><td>测试当前 File 对象表示的文件是否为一个绝对路径名。该方法消除了不同平台的差异，可以直接判断 file 对象是否为绝对路径。在 UNIX/Linux/BSD 等系统上，如果路径名开头是一条斜线/，则表明该 File 对象对应一个绝对路径；在 Windows 等系统上，如果路径开头是盘符，则说明它是一个绝对路径。</td></tr><tr><td>boolean isDirectory()</td><td>测试当前 File 对象表示的文件是否为一个路径</td></tr><tr><td>boolean isFile()</td><td>测试当前 File 对象表示的文件是否为一个“普通”文件</td></tr><tr><td>long lastModified()</td><td>返回当前 File 对象表示的文件最后修改的时间</td></tr><tr><td>long length()</td><td>返回当前 File 对象表示的文件长度</td></tr><tr><td>String[] list()</td><td>返回当前 File 对象指定的路径文件列表</td></tr><tr><td>String[] list(FilenameFilter)</td><td>返回当前 File 对象指定的目录中满足指定过滤器的文件列表</td></tr><tr><td>boolean mkdir()</td><td>创建一个目录，它的路径名由当前 File 对象指定</td></tr><tr><td>boolean mkdirs()</td><td>创建一个目录，它的路径名由当前 File 对象指定，包括任何必需但不存在的父目录。</td></tr><tr><td>boolean renameTo(File)</td><td>将当前 File 对象指定的文件更名为给定参数 File 指定的路径名</td></tr></tbody></table><p>File 类中有以下两个常用常量：<br>public static final String pathSeparator：指的是分隔连续多个路径字符串的分隔符，Windows 下指;。例如 java -cp test.jar;abc.jar HelloWorld。<br>public static final String separator：用来分隔同一个路径字符串中的目录的，Windows 下指/。例如 C:/Program Files/Common Files。</p><p>注意：可以看到 File 类的常量定义的命名规则不符合标准命名规则，常量名没有全部大写，这是因为 Java 的发展经过了一段相当长的时间，而命名规范也是逐步形成的，File 类出现较早，所以当时并没有对命名规范有严格的要求，这些都属于 Java 的历史遗留问题。</p><blockquote><p>Windows 的路径分隔符使用反斜线“\”，而 Java 程序中的反斜线表示转义字符，所以如果需要在 Windows 的路径下包括反斜线，则应该使用两条反斜线或直接使用斜线“/”也可以。Java 程序支持将斜线当成平台无关的路径分隔符。</p></blockquote><p>假设在 Windows 操作系统中有一文件 D:\javaspace\hello.java，在 Java 中使用的时候，其路径的写法应该为 D:/javaspace/hello.java 或者 D:\\javaspace\\hello.java。</p><h2 id="获取文件属性"><a href="#获取文件属性" class="headerlink" title="获取文件属性"></a>获取文件属性</h2><p>获取路径： D:\file.txt  文件的各种属性<br>步骤直接上代码看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:/filetest.txt"</span>);<span class="comment">//也可以使用其他构造，路径与文件分开</span></span><br><span class="line">        System.out.println(<span class="string">"d:/filetest.txt文件信息如下："</span>);</span><br><span class="line">        System.out.println(<span class="string">"============================================"</span>);</span><br><span class="line">        System.out.println(<span class="string">"文件长度："</span> + file.length() + <span class="string">"字节"</span>);</span><br><span class="line">        System.out.println(<span class="string">"文件或者目录："</span> + (file.isFile() ? <span class="string">"是文件"</span> : <span class="string">"不是文件"</span>));</span><br><span class="line">        System.out.println(<span class="string">"文件或者目录："</span> + (file.isDirectory() ? <span class="string">"是目录"</span> : <span class="string">"不是目录"</span>));</span><br><span class="line">        System.out.println(<span class="string">"是否可读："</span> + (file.canRead() ? <span class="string">"可读取"</span> : <span class="string">"不可读取"</span>));</span><br><span class="line">        System.out.println(<span class="string">"是否可写："</span> + (file.canWrite() ? <span class="string">"可写入"</span> : <span class="string">"不可写入"</span>));</span><br><span class="line">        System.out.println(<span class="string">"是否隐藏："</span> + (file.isHidden() ? <span class="string">"是隐藏文件"</span> : <span class="string">"不是隐藏文件"</span>));</span><br><span class="line">        System.out.println(<span class="string">"最后修改日期："</span> + <span class="keyword">new</span> Date(file.lastModified()));</span><br><span class="line">        System.out.println(<span class="string">"文件名称："</span> + file.getName());</span><br><span class="line">        System.out.println(<span class="string">"文件路径："</span> + file.getPath());</span><br><span class="line">        System.out.println(<span class="string">"绝对路径："</span> + file.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/27/javabase53-file/f1.png" alt="文件属性"></p><h2 id="创建和删除文件"><a href="#创建和删除文件" class="headerlink" title="创建和删除文件"></a>创建和删除文件</h2><p>创建使用 createNewFile() ；</p><p>删除使用 delete()；</p><p>创建和删除前都要判断是否存在：exists()；</p><p>例如在 D:\  目录下创建 test.txt，然后在删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:/test.txt"</span>);</span><br><span class="line"><span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">file.createNewFile();</span><br><span class="line">System.out.println(<span class="string">"创建成功"</span>);</span><br><span class="line">System.out.println(<span class="string">"创建时间："</span>+<span class="keyword">new</span> Date(file.lastModified()));<span class="comment">//获得到更新日期 说明创建成功</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">file.delete();</span><br><span class="line">System.out.println(<span class="string">"删除成功"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/27/javabase53-file/cd.png" alt="文件创建和删除"></p><p>重命名使用 renameTo(File dest) 方法。</p><p>Linux 与 Windows  中文件路径的 斜杠是不一样的：</p><ul><li>Windows 中使用反斜杠\表示目录的分隔符。</li><li>Linux 中使用正斜杠/表示目录的分隔符。</li></ul><p>但是既然 java 程序有点就是跨平台，不能因为文件路径不同就得做两种系统，这时候就需要用上面提到的常量 File.separator<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"C:"</span> + File.separator + <span class="string">"test.txt"</span>; <span class="comment">// 拼凑出可以适应操作系统的路径</span></span><br><span class="line">File f = <span class="keyword">new</span> File(path);</span><br></pre></td></tr></table></figure><p>注意：在操作文件时一定要使用 File.separator 表示分隔符。在程序的开发中，往往会使用 Windows 开发环境，因为在 Windows 操作系统中支持的开发工具较多，使用方便，而在程序发布时往往是直接在 Linux 或其它操作系统上部署，所以这时如果不使用 File.separator，则程序运行就有可能存在问题。关于这一点我们在以后的开发中一定要有所警惕。</p><h2 id="创建和删除目录"><a href="#创建和删除目录" class="headerlink" title="创建和删除目录"></a>创建和删除目录</h2><p>创建目录要用 mkdir 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"d:/testjava/"</span>);</span><br><span class="line"><span class="keyword">if</span>(file.exists()) &#123;</span><br><span class="line">file.delete();</span><br><span class="line">&#125;</span><br><span class="line">file.mkdir();</span><br><span class="line">System.out.println(<span class="string">"更新时间："</span>+<span class="keyword">new</span> Date(file.lastModified()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出更新时间说明创建成功了，删除依旧使用 delete 方法。</p><h2 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h2><p>使用方法： file.list 。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[]  list = file.list()</span><br><span class="line"><span class="comment">// 以及重载形式</span></span><br><span class="line">String[]  list = file.list(FilenameFilter filter)</span><br></pre></td></tr></table></figure><p>例如查看 D 盘目录 下所有的文件，并显示文件或目录名称、类型及大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String path = <span class="string">"D:/"</span>;</span><br><span class="line">File file = <span class="keyword">new</span> File(path);</span><br><span class="line">String[] list = file.list();</span><br><span class="line"><span class="keyword">for</span>(String str:list) &#123;</span><br><span class="line">String type = <span class="string">"文件夹"</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">new</span> File(path,str).isFile())</span><br><span class="line">type = <span class="string">"文件"</span>;</span><br><span class="line">System.out.println(<span class="string">"文件名："</span>+str+<span class="string">"----类型："</span>+type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/27/javabase53-file/bl.png" alt="遍历目录"></p><p>至于带过滤器的构造方法用法，这里提一下不再举例：</p><p>新建一个过滤器类实现 FilenameFilter 接口 ，在类中重写 accept 方法，然后将该类作为 list 重载方法的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageFilter</span> <span class="keyword">implements</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现 FilenameFilter 接口</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 指定允许的文件类型</span></span><br><span class="line">        <span class="keyword">return</span> name.endsWith(<span class="string">".sys"</span>) || name.endsWith(<span class="string">".txt"</span>) || name.endsWith(<span class="string">".bak"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String fileList[] = f.list(<span class="keyword">new</span> ImageFilter());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在 Java 中，File 类是 java.io 包中唯一代表磁盘文件本身的对象，也就是说，如果希望在程序中操作文件和目录，则都可以通过 File 类来完成。File 类定义了一些方法来操作文件，如新建、删除、重命名文件和目录等。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（五十二）——输入、输出流简介</title>
    <link href="https://gitsxm.github.io/2020/02/27/javabase52-stream1/"/>
    <id>https://gitsxm.github.io/2020/02/27/javabase52-stream1/</id>
    <published>2020-02-27T13:27:08.000Z</published>
    <updated>2020-02-27T14:24:13.551Z</updated>
    
    <content type="html"><![CDATA[<p><em>在 Java 中所有数据都是使用流读写的。流是一组有序的数据序列，将数据从一个地方带到另一个地方。根据数据流向的不同，可以分为输入（Input）流和输出（Output）流两种。</em></p><a id="more"></a><p>使用程序的目的就是要解决凭个人能力无法完成的数据处理工作，比如说 Excel ，录入数据，处理存储，读取数据，再处理存储。当需要把数据放到计算机上时，就需要用到输出流，读取计算机上的数据是需要输入流，我们将输入（IN）、输出（OUT）概括称为 I/O ,就好像计算机的硬件也有 I/O 部分一样。</p><p>简单介绍一下 Java 中的 I/O 操作：</p><ul><li>按照流的方向主要分为输入流和输出流两大类。</li><li>数据流按照数据单位的不同分为字节流和字符流。</li><li>按照功能可以划分为节点流和处理流。</li></ul><p>接下来首先从输入流开始。</p><h2 id="一、输入流"><a href="#一、输入流" class="headerlink" title="一、输入流"></a>一、输入流</h2><p>Java 流相关的类都封装在 java.io 包中，而且每个数据流都是一个对象。所有输入流类都是 InputStream 抽象类（字节输入流）和 Reader 抽象类（字符输入流）的子类。其中 InputStream 类是字节输入流的抽象类，是所有字节输入流的父类，其层次结构如下图所示。<br><img src="/2020/02/27/javabase52-stream1/s1.png" alt="Inputstream类的层次结构图"></p><p>InputStream 类中所有方法遇到错误时都会引发 IOException 异常。如下是该类中包含的常用方法。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int read()</td><td>从输入流读入一个 8 字节的数据，将它转换成一个 0~ 255 的整数，返回一个整数，如果遇到输入流的结尾返回 -1</td></tr><tr><td>int read(byte[] b)</td><td>从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，返回的字节数表示读取的字节数，如果遇到输入流的结尾返回 -1</td></tr><tr><td>int read(byte[] b,int off,int len)</td><td>从输入流读取若干字节的数据保存到参数 b 指定的字节数组中，其中 off 是指在数组中开始保存数据位置的起始下标，len 是指读取字节的位数。返回的是实际读取的字节数，如果遇到输入流的结尾则返回 -1</td></tr><tr><td>void close()</td><td>关闭数据流，当完成对数据流的操作之后需要关闭数据流</td></tr><tr><td>int available()</td><td>返回可以从数据源读取的数据流的位数。</td></tr><tr><td>skip(long n)</td><td>从输入流跳过参数 n 指定的字节数目</td></tr><tr><td>boolean markSupported()</td><td>判断输入流是否可以重复读取，如果可以就返回 true</td></tr><tr><td>void mark(int readLimit)</td><td>如果输入流可以被重复读取，从流的当前位置开始设置标记，readLimit 指定可以设置标记的字节数</td></tr><tr><td>void reset()</td><td>使输入流重新定位到刚才被标记的位置，这样可以重新读取标记过的数据</td></tr></tbody></table><p>上述最后 3 个方法一般会结合在一起使用，首先使用 markSupported() 判断，如果可以重复读取，则使用 mark(int readLimit) 方法进行标记，标记完成之后可以使用 read() 方法读取标记范围内的字节数，最后使用 reset() 方法使输入流重新定位到标记的位置，继而完成重复读取操作。</p><p>Java 中的字符是 Unicode 编码，即双字节的，而 InputerStream 是用来处理单字节的，在处理字符文本时不是很方便。这时可以使用 Java 的文本输入流 Reader 类，该类是字符输入流的抽象类，即所有字符输入流的实现都是它的子类，该类的方法与 InputerSteam 类的方法类似，这里不再介绍。</p><h2 id="二、输出流"><a href="#二、输出流" class="headerlink" title="二、输出流"></a>二、输出流</h2><p>在 Java 中所有输出流类都是 OutputStream 抽象类（字节输出流）和 Writer 抽象类（字符输出流）的子类。其中 OutputStream 类是字节输出流的抽象类，是所有字节输出流的父类，其层次结构如下图所示。</p><p><img src="/2020/02/27/javabase52-stream1/s2.png" alt="Outputstream类的层次结构图"></p><p>OutputStream 类是所有字节输出流的超类，用于以二进制的形式将数据写入目标设备，该类是抽象类，不能被实例化。OutputStream 类提供了一系列跟数据输出有关的方法，如下所示。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int write(b)</td><td>将指定字节的数据写入到输出流</td></tr><tr><td>int write (byte[] b)</td><td>将指定字节数组的内容写入输出流</td></tr><tr><td>int write (byte[] b,int off,int len)</td><td>将指定字节数组从 off 位置开始的 len 字节的内容写入输出流</td></tr><tr><td>close()</td><td>关闭数据流，当完成对数据流的操作之后需要关闭数据流</td></tr><tr><td>flush()</td><td>刷新输出流，强行将缓冲区的内容写入输出流</td></tr></tbody></table><p>由于读写还要用到 File 文件系统，我们将在后面一起举例介绍。</p><p>补充个系统流的知识，我们频繁使用的控制台输出语句 System.out.print 就是系统输出流的一部分。</p><blockquote><h3 id="系统流"><a href="#系统流" class="headerlink" title="系统流"></a>系统流</h3><p>每个 Java 程序运行时都带有一个系统流，系统流对应的类为 java.lang.System。Sytem 类封装了 Java 程序运行时的 3 个系统流，分别通过 in、out 和 err 变量来引用。这 3 个系统流如下所示：</p><ul><li>System.in：标准输入流，默认设备是键盘。</li><li>System.out：标准输出流，默认设备是控制台。</li><li>System.err：标准错误流，默认设备是控制台。<br>以上变量的作用域为 public 和 static，因此在程序的任何部分都不需引用 System 对象就可以使用它们。<br>举个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] byteData = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span>]; <span class="comment">// 声明一个字节数组</span></span><br><span class="line">       System.out.println(<span class="string">"请输入英文："</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.in.read(byteData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"您输入的内容如下："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; byteData.length; i++) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) byteData[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2020/02/27/javabase52-stream1/s3.png" alt="系统流输入输出"></li></ul><p>System.in 是 InputStream 类的一个对象，因此上述代码的 System.in.read() 方法实际是访问 InputStream 类定义的 read() 方法。该方法可以从键盘读取一个或多个字符。对于 System.out 输出流主要用于将指定内容输出到控制台。</p><p>System.out 和 System.error 是 PrintStream 类的对象。因为 PrintStream 是一个从 OutputStream 派生的输出流，所以它还执行低级别的 write() 方法。因此，除了 print() 和 println() 方法可以完成控制台输出以外，System.out 还可以调用 write() 方法实现控制台输出。<br>write() 方法的简单形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> byteval)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p>该方法通过 byteval 参数向文件写入指定的字节。在实际操作中，print() 方法和 println() 方法比 write() 方法更常用。</p><p>注意：尽管它们通常用于对控制台进行读取和写入字符，但是这些都是字节流。因为预定义流是没有引入字符流的 Java 原始规范的一部分，所以它们不是字符流而是字节流，但是在 Java 中可以将它们打包到基于字符的流中使用。</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在 Java 中所有数据都是使用流读写的。流是一组有序的数据序列，将数据从一个地方带到另一个地方。根据数据流向的不同，可以分为输入（Input）流和输出（Output）流两种。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（五十一）——反射机制实操</title>
    <link href="https://gitsxm.github.io/2020/02/27/javabase51-reflect2/"/>
    <id>https://gitsxm.github.io/2020/02/27/javabase51-reflect2/</id>
    <published>2020-02-27T06:28:28.000Z</published>
    <updated>2020-02-27T08:44:09.552Z</updated>
    
    <content type="html"><![CDATA[<p><em>上篇博客对Java反射机制做了一个简单的介绍，接下来将详细讲述如何通过反射来访问类的各种成员。本篇内容包括:<strong>通过反射访问构造方法，成员方法和成员变量</strong>。</em></p><a id="more"></a><hr><p>访问类成员之前首先要了解 Java 反射机制的两个重要 API 分别是 java.lang.reflect 包和 java.lang.Class 。</p><p>java.lang.reflect 提供了实现反射机制的类，java.lang.Class 类是 Java 反射机制 API 的核心类。</p><h3 id="java-lang-Class-类"><a href="#java-lang-Class-类" class="headerlink" title="java.lang.Class 类"></a>java.lang.Class 类</h3><p>java.lang.Class 类是实现反射的关键所在，Class 类的一个实例表示 Java 的一种数据类型，包括类、接口、枚举、注解（Annotation）、数组、基本数据类型和 void。Class 没有公有的构造方法，Class 实例是由 JVM 在类加载时自动创建的。</p><p>每一种类型包括类和接口等，都有一个 class 静态变量可以获得 Class 实例。另外，每一个对象都有 getClass() 方法可以获得 Class 实例，该方法是由 Object 类提供的实例方法。</p><h3 id="java-lang-reflect-包"><a href="#java-lang-reflect-包" class="headerlink" title="java.lang.reflect 包"></a>java.lang.reflect 包</h3><ul><li>java.lang.reflect 包提供了反射中用到类，主要的类说明如下：</li><li>Constructor 类：提供类的构造方法信息。</li><li>Field 类：提供类或接口中成员变量信息。</li><li>Method 类：提供类或接口成员方法信息。</li><li>Array 类：提供了动态创建和访问 Java 数组的方法。</li><li>Modifier 类：提供类和成员访问修饰符信息</li></ul><p>接下来结合 Java API 文档（也叫 JDK 帮助文档）谈谈反射机制的使用。</p><h2 id="一、通过反射访问构造方法"><a href="#一、通过反射访问构造方法" class="headerlink" title="一、通过反射访问构造方法"></a>一、通过反射访问构造方法</h2><p>一个类可能有多个构造方法，为了能够动态获取对象构造方法的信息，首先需要通过下列方法之一创建一个 Constructor 类型的对象或者数组。</p><ul><li>getConstructors()</li><li></li><li>getConstructor(Class&lt;?&gt;…parameterTypes)</li><li></li><li>getDeclaredConstructors()</li><li></li><li>getDeclaredConstructor(Class&lt;?&gt;…parameterTypes)</li><li>如果是访问指定的构造方法，需要根据该构造方法的入口参数的类型来访问。例如，访问一个入口参数类型依次为 int 和 String 类型的构造方法，下面的两种方式均可以实现。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectClass.getDeclaredConstructor(<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">objectClass.getDeclaredConstructor(<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>&#125;)</span>;</span><br></pre></td></tr></table></figure></li></ul><p>创建的每个 Constructor 对象表示一个构造方法，然后利用 Constructor 对象的方法操作构造方法。Constructor 类的常用方法如下：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>isVarArgs()</td><td>查看该构造方法是否允许带可变数量的参数，如果允许，返回 true，否则返回false</td></tr><tr><td>getParameterTypes()</td><td>按照声明顺序以 Class 数组的形式获取该构造方法各个参数的类型</td></tr><tr><td>getExceptionTypes()</td><td>以 Class 数组的形式获取该构造方法可能抛出的异常类型</td></tr><tr><td>newInstance(Object … initargs)</td><td>通过该构造方法利用指定参数创建一个该类型的对象，如果未设置参数则表示采用默认无参的构造方法</td></tr><tr><td>setAccessiable(boolean flag)</td><td>如果该构造方法的权限为 private，默认为不允许通过反射利用 netlnstance()方法创建对象。如果先执行该方法，并将入口参数设置为 true，则允许创建对象</td></tr><tr><td>getModifiers()</td><td>获得可以解析出该构造方法所采用修饰符的整数</td></tr></tbody></table><p>通过 java.lang.reflect.Modifier 类可以解析出 getMocMers() 方法的返回值所表示的修饰符信息。在该类中提供了一系列用来解析的静态方法，既可以查看是否被指定的修饰符修饰，还可以字符串的形式获得所有修饰符。下表列出了 Modifier 类的常用静态方法。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>isStatic(int mod)</td><td>如果使用 static 修饰符修饰则返回 true，否则返回 false</td></tr><tr><td>isPublic(int mod)</td><td>如果使用 public 修饰符修饰则返回 true，否则返回 false</td></tr><tr><td>isProtected(int mod)</td><td>如果使用 protected 修饰符修饰则返回 true，否则返回 false</td></tr><tr><td>isPrivate(int mod)</td><td>如果使用 private 修饰符修饰则返回 true，否则返回 false</td></tr><tr><td>isFinal(int mod)</td><td>如果使用 final 修饰符修饰则返回 true，否则返回 false</td></tr><tr><td>toString(int mod)</td><td>以字符串形式返回所有修饰符</td></tr></tbody></table><p>例如，下列代码判断对象 con 所代表的构造方法是否被 public 修饰，以及以字符串形式获取该构造方法的所有修饰符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> modifiers = con.getModifiers();    <span class="comment">// 获取构造方法的修饰符整数</span></span><br><span class="line"><span class="keyword">boolean</span> isPublic = Modifier.isPublic(modifiers);    <span class="comment">// 判断修饰符整数是否为public </span></span><br><span class="line">string allModifiers = Modifier.toString(modifiers);</span><br></pre></td></tr></table></figure><p>下面通过一个案例来演示如何调用 Constructor 类的方法获取构造方法的信息。</p><p>创建 Dog 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 跳高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"dog jump !"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的姓名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的姓名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的种类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的种类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toString 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dog [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", type="</span> + type + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age, String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可变参数构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> strings</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age,String...strings)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">if</span>(strings.length==<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = strings[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(strings.length==<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = strings[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">this</span>.type = strings[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Class dog = Dog<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor[] declaredConstructors = dog.getDeclaredConstructors();</span><br><span class="line"><span class="comment">//遍历构造方法</span></span><br><span class="line"><span class="keyword">for</span>(Constructor c: declaredConstructors) &#123;</span><br><span class="line">System.out.println(c);</span><br><span class="line">System.out.println(<span class="string">"查看是否允许带可变数量的参数："</span> + c.isVarArgs());</span><br><span class="line"><span class="comment">//获取所有参数类型</span></span><br><span class="line">Class[] paramTypes = c.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span>(Class cls : paramTypes) &#123;</span><br><span class="line">System.out.println(<span class="string">"参数类型"</span>+cls);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用构造方法创建对象</span></span><br><span class="line">Dog dogg= <span class="keyword">null</span>;</span><br><span class="line">dogg = (Dog) declaredConstructors[<span class="number">0</span>].newInstance(<span class="string">"kk"</span>,<span class="number">10</span>,<span class="string">"金毛"</span>);</span><br><span class="line">System.out.println(dogg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/27/javabase51-reflect2/t1.png" alt="遍历构造方法并通过构造方法创建对象"></p><h2 id="二、通过反射执行方法"><a href="#二、通过反射执行方法" class="headerlink" title="二、通过反射执行方法"></a>二、通过反射执行方法</h2><p>要动态获取一个对象方法的信息，首先需要通过下列方法之一创建一个 Method 类型的对象或者数组</p><ul><li>getMethods()</li><li>getMethods(String name,Class&lt;?&gt; …parameterTypes)</li><li>getDeclaredMethods()</li><li>getDeclaredMethods(String name,Class&lt;?&gt;…parameterTypes)</li></ul><p>如果是访问指定的构造方法，需要根据该方法的入口参数的类型来访问。例如，访问一个名称为 max，入口参数类型依次为 int 和 String 类型的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectClass.getDeclaredConstructor(<span class="string">"max"</span>,<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">objectClass.getDeclaredConstructor(<span class="string">"max"</span>,<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>&#125;)</span>;</span><br></pre></td></tr></table></figure><p>Method 类常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getName()</td><td>获取该方法的名称</td></tr><tr><td>getParameterType()</td><td>按照声明顺序以 Class 数组的形式返回该方法各个参数的类型</td></tr><tr><td>getReturnType()</td><td>以 Class 对象的形式获得该方法的返回值类型</td></tr><tr><td>getExceptionTypes()</td><td>以 Class 数组的形式获得该方法可能抛出的异常类型</td></tr><tr><td>invoke(Object obj,Object…args)</td><td>利用 args 参数执行指定对象 obj 中的该方法，返回值为 Object 类型</td></tr><tr><td>isVarArgs()</td><td>查看该方法是否允许带有可变数量的参数，如果允许返回 true，否则返回 false</td></tr><tr><td>getModifiers()</td><td>获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p>举个例子：</p><p>把 Dog 改掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 跳高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"dog jump !"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"dog eat "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">eat();<span class="comment">//这只狗在睡前会吃东西</span></span><br><span class="line">System.out.println(<span class="string">"dog "</span>+name+<span class="string">" sleep"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"dog run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Class dog = Dog<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//获取所有类方法</span></span><br><span class="line">Method methods[] = dog.getDeclaredMethods();</span><br><span class="line"><span class="comment">//遍历所有方法</span></span><br><span class="line"><span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">System.out.println(method);</span><br><span class="line">Class paramType[] = method.getParameterTypes();</span><br><span class="line"><span class="keyword">for</span> (Class type : paramType) &#123;</span><br><span class="line">System.out.println(<span class="string">"参数类型："</span> + type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取指定方法</span></span><br><span class="line">Method method = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">method = dog.getDeclaredMethod(<span class="string">"sleep"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(method != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Dog dog1 = <span class="keyword">new</span> Dog();</span><br><span class="line">method.invoke(dog1, <span class="string">"huahua"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/27/javabase51-reflect2/t2.png" alt="通过反射使用成员方法"></p><h2 id="三、访问成员变量"><a href="#三、访问成员变量" class="headerlink" title="三、访问成员变量"></a>三、访问成员变量</h2><p>通过下列任意一个方法访问成员变量时将返回 Field 类型的对象或数组。</p><ul><li>getFields()</li><li>getField(String name)</li><li>getDeclaredFields()</li><li>getDeclaredField(String name)</li></ul><p>上述方法返回的 Field 对象代表一个成员变量。例如，要访问一个名称为 price 的成员变量，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.getDeciaredField(<span class="string">"price"</span>);</span><br></pre></td></tr></table></figure><p>Field 类常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getName()</td><td>获得该成员变量的名称</td></tr><tr><td>getType()</td><td>获取表示该成员变量的 Class 对象</td></tr><tr><td>get(Object obj)</td><td>获得指定对象 obj 中成员变量的值，返回值为 Object 类型</td></tr><tr><td>set(Object obj, Object value)</td><td>将指定对象 obj 中成员变量的值设置为 value</td></tr><tr><td>getlnt(0bject obj)</td><td>获得指定对象 obj 中成员类型为 int 的成员变量的值</td></tr><tr><td>setlnt(0bject obj, int i)</td><td>将指定对象 obj 中成员变量的值设置为 i</td></tr><tr><td>setFloat(Object obj, float f)</td><td>将指定对象 obj 中成员变量的值设置为 f</td></tr><tr><td>getBoolean(Object obj)</td><td>获得指定对象 obj 中成员类型为 boolean 的成员变量的值</td></tr><tr><td>setBoolean(Object obj, boolean b)</td><td>将指定对象 obj 中成员变量的值设置为 b</td></tr><tr><td>getFloat(Object obj)</td><td>获得指定对象 obj 中成员类型为 float 的成员变量的值</td></tr><tr><td>setAccessible(boolean flag)</td><td>此方法可以设置是否忽略权限直接访问 private 等私有权限的成员变量</td></tr><tr><td>getModifiers()</td><td>获得可以解析出该方法所采用修饰符的整数</td></tr></tbody></table><p>举个例子：<br>访问设置 Dog 类的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dog 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dog [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", type="</span> + type + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Class dog = Dog<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Field[] fields = dog.getDeclaredFields();</span><br><span class="line">Dog dogg = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">Class fieldType = field.getType();</span><br><span class="line">String fieldName = field.getName();</span><br><span class="line">System.out.println(<span class="string">"属性名："</span> + field.getName());</span><br><span class="line">System.out.println(<span class="string">"属性类型："</span> + field.getType());</span><br><span class="line"><span class="comment">// 为属性赋值</span></span><br><span class="line">if (fieldType.equals(String.class) &amp;&amp; fieldName.equals("name")) &#123;</span><br><span class="line">field.set(dogg, <span class="string">"huahua"</span>);</span><br><span class="line">&#125;</span><br><span class="line">if (fieldType.equals(String.class) &amp;&amp; fieldName.equals("type")) &#123;</span><br><span class="line">field.set(dogg, <span class="string">"金毛犬"</span>);</span><br><span class="line">&#125;</span><br><span class="line">if (fieldType.equals(int.class) &amp;&amp; fieldName.equals("age")) &#123;</span><br><span class="line">field.setInt(dogg, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(dogg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/27/javabase51-reflect2/t3.png" alt="通过反射访问并设置属性"></p><hr><p>反射的基本用法都有提了，但是但凡是开发中用到的都不会这么简单，还是要在实际开发中积累经验啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;上篇博客对Java反射机制做了一个简单的介绍，接下来将详细讲述如何通过反射来访问类的各种成员。本篇内容包括:&lt;strong&gt;通过反射访问构造方法，成员方法和成员变量&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（五十）——认识反射机制</title>
    <link href="https://gitsxm.github.io/2020/02/27/javabase50-reflect1/"/>
    <id>https://gitsxm.github.io/2020/02/27/javabase50-reflect1/</id>
    <published>2020-02-27T03:13:00.000Z</published>
    <updated>2020-02-27T06:38:46.358Z</updated>
    
    <content type="html"><![CDATA[<p><em>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。</em></p><a id="more"></a><hr><p>Java 反射机制是 Java 语言的一个重要特性。在学习 Java 反射机制前，大家应该先了解两个概念，编译期和运行期。</p><p>编译期是指把源码交给编译器编译成计算机可以执行的文件的过程。在 Java 中也就是把 Java 代码编成 class 文件的过程。编译期只是做了一些翻译功能，并没有把代码放在内存中运行起来，而只是把代码当成文本进行操作，比如检查错误。</p><p>运行期是把编译后的文件交给计算机执行，直到程序运行结束。所谓运行期就把在磁盘中的代码放到内存中执行起来。</p><p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><p>Java 反射机制在服务器程序和中间件程序中得到了广泛运用。在服务器端，往往需要根据客户的请求，动态调用某一个对象的特定方法。此外，在 ORM 中间件的实现中，运用 Java 反射机制可以读取任意一个 JavaBean 的所有属性，或者给这些属性赋值。</p><p>Java 反射机制主要提供了以下功能，这些功能都位于java.lang.reflect包。</p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li><li>生成动态代理。</li></ul><p>要想知道一个类的属性和方法，必须先获取到该类的字节码文件对象。获取类的信息时，使用的就是 Class 类中的方法。所以先要获取到每一个字节码文件（.class）对应的 Class 类型的对象.</p><p>通过 Object 类提供的 getClass() 方法获取 Class 类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class labelCls = label1.getClass();    <span class="comment">// label1为 JLabel 类的对象</span></span><br></pre></td></tr></table></figure><p>利用 Class 类的对象 labelCls 可以访问 labelCls 对象的描述信息、JLabel 类的信息以及基类 Object 的信息。下表列出了通过反射可以访问的信息。</p><table><thead><tr><th>类型</th><th>访问方法</th><th>返回值类型</th><th>说明</th></tr></thead><tbody><tr><td>包路径</td><td>getPackage()</td><td>Package 对象</td><td>获取该类的存放路径</td></tr><tr><td>类名称</td><td>getName()</td><td>String 对象</td><td>获取该类的名称</td></tr><tr><td>继承类</td><td>getSuperclass()</td><td>Class 对象</td><td>获取该类继承的类</td></tr><tr><td>实现接口</td><td>getlnterfaces()</td><td>Class 型数组</td><td>获取该类实现的所有接口</td></tr><tr><td>构造方法</td><td>getConstructors()</td><td>Constructor 型数组</td><td>获取所有权限为 public 的构造方法</td></tr><tr><td>构造方法</td><td>getDeclaredContruectors()</td><td>Constructor 对象</td><td>获取当前对象的所有构造方法</td></tr><tr><td>方法</td><td>getMethods()</td><td>Methods 型数组</td><td>获取所有权限为 public 的方法</td></tr><tr><td>方法</td><td>getDeclaredMethods()</td><td>Methods 对象</td><td>获取当前对象的所有方法</td></tr><tr><td>成员变量</td><td>getFields()</td><td>Field 型数组</td><td>获取所有权限为 public 的成员变量</td></tr><tr><td>成员变量</td><td>getDeclareFileds()</td><td>Field 对象</td><td>获取当前对象的所有成员变量</td></tr><tr><td>内部类</td><td>getClasses()</td><td>Class 型数组</td><td>获取所有权限为 public 的内部类</td></tr><tr><td>内部类</td><td>getDeclaredClasses()</td><td>Class 型数组</td><td>获取所有内部类</td></tr><tr><td>内部类的声明类</td><td>getDeclaringClass()</td><td>Class 对象</td><td>如果该类为内部类，则返回它的成员类，否则返回 null</td></tr></tbody></table><p>在调用 getFields() 和 getMethods() 方法时将会依次获取权限为 public 的字段和变量，然后将包含从超类中继承到的成员变量和方法。而通过 getDeclareFields() 和 getDeclareMethod() 只是获取在本类中定义的成员变量和方法。</p><p>Java 反射机制的优缺点<br>优点：</p><ul><li>能够运行时动态获取类的实例，大大提高系统的灵活性和扩展性。</li><li>与 Java 动态编译相结合，可以实现无比强大的功能。</li><li>对于 Java 这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</li></ul><p>缺点：</p><ul><li>反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</li><li>反射调用方法时可以忽略权限检查，获取这个类的私有方法和属性，因此可能会破坏类的封装性而导致安全问题。</li></ul><p>Java 反射机制在一般的 Java 应用开发中很少使用，即便是 Java EE 阶段也很少使用。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十九）——枚举</title>
    <link href="https://gitsxm.github.io/2020/02/27/javabase49-enum/"/>
    <id>https://gitsxm.github.io/2020/02/27/javabase49-enum/</id>
    <published>2020-02-27T01:43:43.000Z</published>
    <updated>2020-02-27T02:46:30.381Z</updated>
    
    <content type="html"><![CDATA[<p><em>枚举是一个被命名的整型常数的集合，用于声明一组带标识符的常数。枚举在曰常生活中很常见，例如一个人的性别只能是“男”或者“女”，一周的星期只能是 7 天中的一个等。类似这种当一个变量有几种固定可能的取值时，就可以将它定义为枚举类型。</em></p><a id="more"></a><hr><h2 id="一、声明枚举"><a href="#一、声明枚举" class="headerlink" title="一、声明枚举"></a>一、声明枚举</h2><p>声明枚举时必须使用 enum 关键字，然后定义枚举的名称、可访问性、基础类型和成员等。枚举声明的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>-modifiers <span class="keyword">enum</span> enumname:<span class="keyword">enum</span>-base &#123;</span><br><span class="line">    <span class="keyword">enum</span>-body,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，enum-modifiers 表示枚举的修饰符主要包括 public、private 和 internal；enumname 表示声明的枚举名称；enum-base 表示基础类型；enum-body 表示枚举的成员，它是枚举类型的命名常数</p><p><strong>提示：如果没有显式地声明基础类型的枚举，那么意味着它所对应的基础类型是 int。</strong></p><p>举个例子，定义表示性别和颜色的枚举类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"男："</span>+Sex.famale);</span><br><span class="line">System.out.println(<span class="string">"女："</span>+Sex.male);</span><br><span class="line">System.out.println(<span class="string">"红色："</span>+Color.red);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Sex&#123;</span><br><span class="line">male,famale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color&#123;</span><br><span class="line">red,orange,yellow,green,cyan,blue,purple;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/javabase49-enum/e1.png" alt="运行结果"></p><h2 id="二、枚举类"><a href="#二、枚举类" class="headerlink" title="二、枚举类"></a>二、枚举类</h2><p>Java 中的每一个枚举都继承自 java.lang.Enum 类。当定义一个枚举类型时，每一个枚举类型成员都可以看作是 Enum 类的实例，这些枚举成员默认都被 final、public, static 修饰，当使用枚举类型成员时，直接使用枚举名称调用成员即可。</p><p>所有枚举实例都可以调用 Enum 类的方法，常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>values()</td><td>以数组形式返回枚举类型的所有成员</td></tr><tr><td>valueOf()</td><td>将普通字符串转换为枚举实例</td></tr><tr><td>compareTo()</td><td>比较两个枚举成员在定义时的顺序</td></tr><tr><td>ordinal()</td><td>获取枚举成员的索引位置</td></tr></tbody></table><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Object obj[] = Color.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obj.length; i++)</span><br><span class="line">System.out.println(obj[i]);</span><br><span class="line"><span class="comment">//将字符串转为枚举并与已有的枚举类型比较 相等返回 0</span></span><br><span class="line">System.out.println(Color.valueOf(<span class="string">"YELLOW"</span>).compareTo(Color.YELLOW));</span><br><span class="line"><span class="comment">//获得索引</span></span><br><span class="line">System.out.println(<span class="string">"BLUE索引："</span>+Color.BLUE.ordinal());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------枚举类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    RED,ORANGE,YELLOW,GREEN,CYAN,BLUE,PURPLE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/javabase49-enum/e2.png" alt="运行结果"></p><h2 id="三、为枚举类添加方法"><a href="#三、为枚举类添加方法" class="headerlink" title="三、为枚举类添加方法"></a>三、为枚举类添加方法</h2><p>Java 为枚举类型提供了一些内置的方法，同时枚举常量也可以有自己的方法。此时要注意必须在枚举实例的最后一个成员后添加分号，而且必须先定义枚举实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> WeekDay &#123;</span><br><span class="line">Mon(<span class="string">"Monday"</span>), Tue(<span class="string">"Tuesday"</span>), Wed(<span class="string">"Wednesday"</span>), Thu(<span class="string">"Thursday"</span>), Fri(<span class="string">"Friday"</span>), Sat(<span class="string">"Saturday"</span>), Sun(<span class="string">"Sunday"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上是枚举的成员，必须先定义，而且使用分号结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String day;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WeekDay</span><span class="params">(String day)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.day = day;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printDay</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(WeekDay.Mon);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">System.out.println(WeekDay.Tue);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">System.out.println(WeekDay.Wed);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">System.out.println(WeekDay.Thu);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">System.out.println(WeekDay.Fri);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">System.out.println(WeekDay.Sat);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">System.out.println(WeekDay.Sun);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"wrong number!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码创建了 WeekDay 枚举类型，下面遍历该枚举中的所有成员，并调用 printDay() 方法。示例代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (WeekDay day : WeekDay.values()) &#123;</span><br><span class="line">System.out.println(day + <span class="string">"====&gt;"</span> + day.getDay());</span><br><span class="line">&#125;</span><br><span class="line">WeekDay.printDay(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/27/javabase49-enum/e3.png" alt="运行结果"></p><h2 id="EnumMap-与-EnumSet"><a href="#EnumMap-与-EnumSet" class="headerlink" title="EnumMap 与 EnumSet"></a>EnumMap 与 EnumSet</h2><p>为了更好地支持枚举类型，java.util 中添加了两个新类：EnumMap 和 EnumSet。使用它们可以更高效地操作枚举类型。</p><h3 id="EnumMap-类"><a href="#EnumMap-类" class="headerlink" title="EnumMap 类"></a>EnumMap 类</h3><p>EnumMap 是专门为枚举类型量身定做的 Map 实现。虽然使用其他的 Map（如 HashMap）实现也能完成枚举类型实例到值的映射，但是使用 EnumMap 会更加高效。</p><p>HashMap 只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 EnumMap 使用数组来存放与枚举类型对应的值，使得 EnumMap 的效率非常高。</p><h3 id="EnumSet-类"><a href="#EnumSet-类" class="headerlink" title="EnumSet 类"></a>EnumSet 类</h3><p>EnumSet 是枚举类型的高性能 Set 实现，它要求放入它的枚举常量必须属于同一枚举类型。EnumSet 提供了许多工厂方法以便于初始化。</p><p>这两个枚举集合没用过，不好说。具体用法还是要看 Java API 文档。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;枚举是一个被命名的整型常数的集合，用于声明一组带标识符的常数。枚举在曰常生活中很常见，例如一个人的性别只能是“男”或者“女”，一周的星期只能是 7 天中的一个等。类似这种当一个变量有几种固定可能的取值时，就可以将它定义为枚举类型。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java集合" scheme="https://Gitsxm.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十八）——泛型</title>
    <link href="https://gitsxm.github.io/2020/02/26/javabase48-fx/"/>
    <id>https://gitsxm.github.io/2020/02/26/javabase48-fx/</id>
    <published>2020-02-26T12:01:46.000Z</published>
    <updated>2020-02-27T04:55:03.542Z</updated>
    
    <content type="html"><![CDATA[<p><em>Java中泛型的作用是给类一个类型参数，泛型可以在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高了代码的重用率。</em></p><a id="more"></a><hr><p>集合学习时不使用泛型的话无论存入什么类型取出时都会转为 Object 类型，这样的设计可以让集合可以存储各种类型的数据，但是也会出现问题，存入的对象不统一也是允许的，如本来要存 Dog 类，结果 Cat 类也可以放进去，造成异常，而且使用时需要对 Object 对象进行强制类型转化处理，很麻烦，还容易出现不能转换异常。</p><p>Java 在 1.5 版本加入了泛型，解决了类的类型问题，下面详细介绍。</p><h2 id="一、泛型集合"><a href="#一、泛型集合" class="headerlink" title="一、泛型集合"></a>一、泛型集合</h2><p>泛型本质上是提供类型的“类型参数”，也就是参数化类型。我们可以为类、接口或方法指定一个类型参数，通过这个参数限制操作的数据类型，从而保证类型转换的绝对安全。</p><p>在集合部分有使用到泛型，在这里举个 List、Map 综合使用泛型的例子，其他的也没什么好说的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试类 将 Map 中的 Dog 对象放入 List</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Map&lt;Integer, Dog&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Dog&gt;();</span><br><span class="line">map.put(<span class="number">1001</span>, <span class="keyword">new</span> Dog(<span class="string">"阿花"</span>, <span class="number">2</span>, <span class="string">"金毛犬"</span>));</span><br><span class="line">map.put(<span class="number">1002</span>, <span class="keyword">new</span> Dog(<span class="string">"阿好"</span>, <span class="number">2</span>, <span class="string">"田园犬"</span>));</span><br><span class="line">map.put(<span class="number">1003</span>, <span class="keyword">new</span> Dog(<span class="string">"阿月"</span>, <span class="number">2</span>, <span class="string">"松狮犬"</span>));</span><br><span class="line">map.put(<span class="number">1004</span>, <span class="keyword">new</span> Dog(<span class="string">"阿圆"</span>, <span class="number">2</span>, <span class="string">"细犬"</span>));</span><br><span class="line"><span class="comment">// 手动创建List 来放入 Dog</span></span><br><span class="line">ArrayList&lt;Dog&gt; arr = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">Iterator&lt;Integer&gt; itr = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line">arr.add(map.get(itr.next()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历 ArrayList</span></span><br><span class="line"><span class="keyword">for</span> (Dog dog : arr)</span><br><span class="line">System.out.println(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------Dog 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age, String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toString</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dog [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", type="</span> + type + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本次举例中，不仅集合有使用到泛型，迭代器 Iterator 也有用到泛型，体会泛型的在集合中的使用，可以自己试一试不使用泛型的情况下如何调整代码。</p><h2 id="二、泛型类"><a href="#二、泛型类" class="headerlink" title="二、泛型类"></a>二、泛型类</h2><p>除了可以定义泛型集合之外，还可以直接限定泛型类的类型参数。语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">class_name</span>&lt;<span class="title">data_type1</span>,<span class="title">data_type2</span>,…&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>其中，class_name 表示类的名称，data_ type1 等表示类型参数。Java 泛型支持声明一个以上的类型参数，只需要将类型用逗号隔开即可。</p><p>泛型类一般用于类中的属性类型不确定的情况下。在声明属性时，使用下面的语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> data_type1 property_name1;</span><br><span class="line"><span class="keyword">private</span> data_type2 property_name2;</span><br></pre></td></tr></table></figure><p>该语句中的 data_type1 与类声明中的 data_type1 表示的是同一种数据类型。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">// 名字使用字符串，id使用整型，类型使用整型</span></span><br><span class="line">Animal&lt;String,Integer,Integer&gt; anim = <span class="keyword">new</span> Animal&lt;String,Integer,Integer&gt;();</span><br><span class="line">anim.setId(<span class="number">1001</span>);<span class="comment">//id 假设为纯数字</span></span><br><span class="line">anim.setName(<span class="string">"van"</span>);</span><br><span class="line">anim.setType(<span class="number">2</span>);<span class="comment">//type 中 2 代表 狗</span></span><br><span class="line"><span class="comment">// 名字使用字符串，id使用字符串，类型使用字符串</span></span><br><span class="line">Animal&lt;String,String,String&gt; anim2 = <span class="keyword">new</span> Animal&lt;&gt;();</span><br><span class="line">anim2.setId(<span class="string">"2001-c"</span>); <span class="comment">//id 需要使用字符串</span></span><br><span class="line">anim2.setName(<span class="string">"jack"</span>); </span><br><span class="line">anim2.setType(<span class="string">"猫"</span>);<span class="comment">// type 假设要求使用具体类型。</span></span><br><span class="line">System.out.println(anim);</span><br><span class="line">System.out.println(anim2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------Animal 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&lt;<span class="title">N</span>,<span class="title">T</span>,<span class="title">ID</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> N name;<span class="comment">//名字</span></span><br><span class="line"><span class="keyword">private</span> T type;<span class="comment">//类型</span></span><br><span class="line"><span class="keyword">private</span> ID id;<span class="comment">//编号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> N <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(N name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(T type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ID <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(ID id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Animal [name="</span> + name + <span class="string">", type="</span> + type + <span class="string">", id="</span> + id + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/26/javabase48-fx/t.png" alt="同一个类不同的数据类型"><br>使用泛型让类的使用更加灵活，适应不同的开发规范。</p><h2 id="三、泛型方法"><a href="#三、泛型方法" class="headerlink" title="三、泛型方法"></a>三、泛型方法</h2><p>无论是泛型集合，还是泛型类，上面讨论的都处于类层次，方法也可以使用泛型，而且泛型方法，与其所在的类是不是泛型没有关系。</p><p>泛型方法使得该方法能够独立于类而产生变化。如果使用泛型方法可以取代类泛型化，那么就应该只使用泛型方法。另外，对一个 static 的方法而言，无法访问泛型类的类型参数。因此，如果 static 方法需要使用泛型能力，就必须使其成为泛型方法。</p><p>定义泛型方法的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[访问权限修饰符][<span class="keyword">static</span>][<span class="keyword">final</span>]&lt;类型参数列表&gt;返回值类型方法名([形式参数列表])</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;T&gt; <span class="title">find</span><span class="params">(Class&lt;T&gt;class,<span class="keyword">int</span> userId)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说编写 Java 泛型方法，其返回值类型至少有一个参数类型应该是泛型，而且类型应该是一致的，如果只有返回值类型或参数类型之一使用了泛型，那么这个泛型方法的使用就被限制了。下面就来定义一个泛型方法，具体介绍泛型方法的创建和使用。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog(<span class="string">"kk"</span>,<span class="number">2</span>,<span class="string">"金毛犬"</span>);</span><br><span class="line">        <span class="comment">//前面测试用到的 Animal 类</span></span><br><span class="line">Animal&lt;String,String,String&gt; anim = <span class="keyword">new</span> Animal&lt;&gt;();</span><br><span class="line">anim.setId(<span class="string">"1001"</span>);</span><br><span class="line">anim.setName(<span class="string">"hh"</span>);</span><br><span class="line">anim.setType(<span class="string">"dog"</span>);</span><br><span class="line">print(dog);</span><br><span class="line">print(anim);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型参数 打印对象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T dog)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dog != <span class="keyword">null</span>)</span><br><span class="line">System.out.println(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/26/javabase48-fx/t1.png" alt="输出两种不同的类"></p><h2 id="四、泛型的高级用法"><a href="#四、泛型的高级用法" class="headerlink" title="四、泛型的高级用法"></a>四、泛型的高级用法</h2><p>泛型的用法非常灵活，除在集合、类和方法中使用外，本节将从三个方面介绍泛型的高级用法，包括限制泛型可用类型、使用类型通配符、继承泛型类和实现泛型接口。</p><h3 id="1-限制泛型可用类型"><a href="#1-限制泛型可用类型" class="headerlink" title="1.限制泛型可用类型"></a>1.限制泛型可用类型</h3><p>在 Java 中默认可以使用任何类型来实例化一个泛型类对象。当然也可以对泛型类实例的类型进行限制，语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">anyClass</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中，anyClass 指某个接口或类。使用泛型限制后，泛型类的类型必须实现或继承 anyClass 这个接口或类。无论 anyClass 是接口还是类，在进行泛型限制时都必须使用 extends 关键字。</p><p>例如，在下面的示例代码中创建了一个 ListClass 类，并对该类的类型限制为只能是实现 List 接口的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListClass</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">List</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化使用ArrayList的泛型类ListClass，正确</span></span><br><span class="line">        ListClass&lt;ArrayList&gt; lc1 = <span class="keyword">new</span> ListClass&lt;ArrayList&gt;();</span><br><span class="line">        <span class="comment">// 实例化使用LinkedList的泛型类LlstClass，正确</span></span><br><span class="line">        ListClass&lt;LinkedList&gt; lc2 = <span class="keyword">new</span> ListClass&lt;LinkedList&gt;();</span><br><span class="line">        <span class="comment">// 实例化使用HashMap的泛型类ListClass，错误，因为HasMap没有实现List接口</span></span><br><span class="line">        <span class="comment">// ListClass&lt;HashMap&gt; lc3=new ListClass&lt;HashMap&gt;();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，定义 ListClass 类时设置泛型类型必须实现 List 接口。例如，ArrayList 和 LinkedList 都实现了 List 接口，所以可以实例化 ListClass 类。而 HashMap 没有实现 List 接口，所以在实例化 ListClass 类时会报错。</p><p>当没有使用 extends 关键字限制泛型类型时，其实是默认使用 Object 类作为泛型类型。因此，Object 类下的所有子类都可以实例化泛型类对象，如下图所示的这两种情况。</p><p><img src="/2020/02/26/javabase48-fx/fx.png" alt="两个等价的泛型类"></p><h3 id="2-使用类型通配符"><a href="#2-使用类型通配符" class="headerlink" title="2.使用类型通配符"></a>2.使用类型通配符</h3><p>Java 中的泛型还支持使用类型通配符，它的作用是在创建一个泛型类对象时限制这个泛型类的类型必须实现或继承某个接口或类。</p><p>使用泛型类型通配符的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">泛型类名称&lt;? extends List&gt;a = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>其中，“&lt;? extends List&gt;”作为一个整体表示类型未知，当需要使用泛型对象时，可以单独实例化。</p><p>例如，下面的示例代码演示了类型通配符的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A&lt;? extends List&gt;a = <span class="keyword">null</span>;</span><br><span class="line">a = <span class="keyword">new</span> A&lt;ArrayList&gt; ();    <span class="comment">// 正确</span></span><br><span class="line">b = <span class="keyword">new</span> A&lt;LinkedList&gt; ();    <span class="comment">// 正确</span></span><br><span class="line">c = <span class="keyword">new</span> A&lt;HashMap&gt; ();    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>在上述代码中，同样由于 HashMap 类没有实现 List 接口，所以在编译时会报错。</p><h3 id="3-继承泛型类和实现泛型接口"><a href="#3-继承泛型类和实现泛型接口" class="headerlink" title="3.继承泛型类和实现泛型接口"></a>3.继承泛型类和实现泛型接口</h3><p>定义为泛型的类和接口也可以被继承和实现。例如下面的示例代码演示了如何继承泛型类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FatherClass</span>&lt;<span class="title">T1</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SonClass</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>,<span class="title">T3</span>&gt; <span class="title">extents</span> <span class="title">FatherClass</span>&lt;<span class="title">T1</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果要在 SonClass 类继承 FatherClass 类时保留父类的泛型类型，需要在继承时指定，否则直接使用 extends FatherClass 语句进行继承操作，此时 T1、T2 和 T3 都会自动变为 Object，所以一般情况下都将父类的泛型类型保留。</p><p>下面的示例代码演示了如何在泛型中实现接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">interface1</span>&lt;<span class="title">T1</span>&gt;</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SubClass</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>,<span class="title">T3</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">Interface1</span>&lt;<span class="title">T2</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Java中泛型的作用是给类一个类型参数，泛型可以在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高了代码的重用率。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java集合" scheme="https://Gitsxm.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十七）——Collections 集合工具类</title>
    <link href="https://gitsxm.github.io/2020/02/26/javabase47-collections/"/>
    <id>https://gitsxm.github.io/2020/02/26/javabase47-collections/</id>
    <published>2020-02-26T09:09:49.000Z</published>
    <updated>2020-02-26T13:16:00.221Z</updated>
    
    <content type="html"><![CDATA[<p><em>Collections 类是 Java 提供的一个集合工具类，可以对 List、Set 和 Map 进行排序、变换、查找和复制等操作。</em></p><a id="more"></a><hr><h2 id="一、排序（正向，逆向）"><a href="#一、排序（正向，逆向）" class="headerlink" title="一、排序（正向，逆向）"></a>一、排序（正向，逆向）</h2><p>相关方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void reverse(List list)</td><td>对指定 List 集合元素进行逆向排序。</td></tr><tr><td>void shuffle(List list)</td><td>对 List 集合元素进行随机排序（shuffle 方法模拟了“洗牌”动作）。</td></tr><tr><td>void sort(List list)</td><td>根据元素的自然顺序对指定 List 集合的元素按升序进行排序。</td></tr><tr><td>void sort(List list, Comparator c)</td><td>根据指定 Comparator 产生的顺序对 List 集合元素进行排序。</td></tr><tr><td>void swap(List list, int i, int j)</td><td>将指定 List 集合中的 i 处元素和 j 处元素进行交换。</td></tr><tr><td>void rotate(List list, int distance)</td><td>当 distance 为正数时，将 list 集合的后 distance 个元素“整体”移到前面；当 distance 为负数时，将 list 集合的前 distance 个元素“整体”移到后面。该方法不会改变集合的长度。</td></tr></tbody></table><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arr.add(<span class="number">4</span>);</span><br><span class="line">arr.add(<span class="number">13</span>);</span><br><span class="line">arr.add(<span class="number">1</span>);</span><br><span class="line">arr.add(<span class="number">10</span>);</span><br><span class="line">arr.add(<span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">"未排序遍历："</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : arr)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n由低到高排序遍历："</span>);</span><br><span class="line">Collections.sort(arr);</span><br><span class="line"><span class="keyword">for</span> (Integer i : arr)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n逆向排序遍历："</span>);</span><br><span class="line">Collections.reverse(arr);</span><br><span class="line"><span class="keyword">for</span> (Integer i : arr)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n首尾元素交换："</span>);</span><br><span class="line">Collections.swap(arr, <span class="number">0</span>, arr.size() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : arr)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n后三个元素移到前面："</span>);</span><br><span class="line">Collections.rotate(arr, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : arr)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/26/javabase47-collections/t1.png" alt="Collections排序移动操作"></p><h2 id="二、查找、替换操作"><a href="#二、查找、替换操作" class="headerlink" title="二、查找、替换操作"></a>二、查找、替换操作</h2><p>相关方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int binarySearch(List list, Object key)</td><td>使用二分搜索法搜索指定的 List 集合，以获得指定对象在 List 集合中的索引。如果要使该方法可以正常工作，则必须保证 List 中的元素已经处于有序状态。</td></tr><tr><td>Object max(Collection coll)</td><td>根据元素的自然顺序，返回给定集合中的最大元素。</td></tr><tr><td>Object max(Collection coll, Comparator comp)</td><td>根据 Comparator 指定的顺序，返回给定集合中的最大元素。</td></tr><tr><td>Object min(Collection coll)</td><td>根据元素的自然顺序，返回给定集合中的最小元素。</td></tr><tr><td>Object min(Collection coll, Comparator comp)</td><td>根据 Comparator 指定的顺序，返回给定集合中的最小元素。</td></tr><tr><td>void fill(List list, Object obj)</td><td>使用指定元素 obj 替换指定 List 集合中的所有元素。</td></tr><tr><td>int frequency(Collection c, Object o)</td><td>返回指定集合中指定元素的出现次数。</td></tr><tr><td>int indexOfSubList(List source, List target)</td><td>返回子 List 对象在父 List 对象中第一次出现的位置索引；如果父 List 中没有出现这样的子 List，则返回 -1。</td></tr><tr><td>int lastIndexOfSubList(List source, List target)</td><td>返回子 List 对象在父 List 对象中最后一次出现的位置索引；如果父 List 中没有岀现这样的子 List，则返回 -1。</td></tr><tr><td>boolean replaceAll(List list, Object oldVal, Object newVal)</td><td>使用一个新值 newVal 替换 List 对象的所有旧值 oldVal。</td></tr></tbody></table><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arr.add(<span class="number">4</span>);</span><br><span class="line">arr.add(<span class="number">13</span>);</span><br><span class="line">arr.add(<span class="number">1</span>);</span><br><span class="line">arr.add(<span class="number">10</span>);</span><br><span class="line">arr.add(<span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">"未排序遍历："</span>);</span><br><span class="line">printList(arr);</span><br><span class="line">System.out.println(<span class="string">"最大值："</span>+Collections.max(arr));</span><br><span class="line">System.out.println(<span class="string">"最小值："</span>+Collections.min(arr));</span><br><span class="line">System.out.println(<span class="string">"10 的索引："</span>+Collections.binarySearch(arr, <span class="number">10</span>));</span><br><span class="line">System.out.println(<span class="string">"全部替换为0："</span>);</span><br><span class="line">Collections.fill(arr,<span class="number">0</span>);</span><br><span class="line">printList(arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: printList   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Integer i : list)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/26/javabase47-collections/t2.png" alt="查找替换操作"></p><h2 id="三、复制"><a href="#三、复制" class="headerlink" title="三、复制"></a>三、复制</h2><p>Collections 类的 copy() 静态方法用于将指定集合中的所有元素复制到另一个集合中，较短的 list 会按照存入顺序替换较长 list 的元素。<br>copy方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List &lt;? <span class="keyword">super</span> T&gt; dest,List&lt;? extends T&gt; src)</span></span></span><br></pre></td></tr></table></figure><p>dest 表示目标集合对象，src 表示源集合对象。</p><p>注意：目标集合的长度至少和源集合的长度相同，如果目标集合的长度更长，则不影响目标集合中的其余元素。如果目标集合长度不够而无法包含整个源集合元素，程序将抛出 IndexOutOfBoundsException 异常</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arr.add(<span class="number">4</span>);</span><br><span class="line">arr.add(<span class="number">13</span>);</span><br><span class="line">arr.add(<span class="number">1</span>);</span><br><span class="line">arr.add(<span class="number">10</span>);</span><br><span class="line">arr.add(<span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">"arr遍历："</span>);</span><br><span class="line">printList(arr);</span><br><span class="line">ArrayList&lt;Integer&gt; arr2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">arr2.add(<span class="number">100</span>);</span><br><span class="line">arr2.add(<span class="number">99</span>);</span><br><span class="line">System.out.println(<span class="string">"arr2遍历 ："</span>);</span><br><span class="line">printList(arr2);</span><br><span class="line">Collections.copy(arr, arr2);</span><br><span class="line">System.out.println(<span class="string">"arr2内容 copy 到 arr 后遍历 arr："</span>);</span><br><span class="line">printList(arr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: printList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(ArrayList&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Integer i : list)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/26/javabase47-collections/t3.png" alt="cpoy方法"></p><p>两个元素的 arr2 往 5 个元素的 arr 中 copy ，覆盖了 arr 的前两个元素。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Collections 类是 Java 提供的一个集合工具类，可以对 List、Set 和 Map 进行排序、变换、查找和复制等操作。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java集合" scheme="https://Gitsxm.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十六）——Map 集合</title>
    <link href="https://gitsxm.github.io/2020/02/26/javabase46-map/"/>
    <id>https://gitsxm.github.io/2020/02/26/javabase46-map/</id>
    <published>2020-02-26T02:26:04.000Z</published>
    <updated>2020-02-26T13:16:05.797Z</updated>
    
    <content type="html"><![CDATA[<p><em>Map 的结构就像学校的学生，每个学号对应一个学生，它存储的 key→value 键值对，key 与 value 一一对应， key 不可重复，value 值没有限制。本期内容介绍 Map 接口的两个实现类 <strong>HashMap</strong> 和 <strong>TreeMap</strong>。LinkedHashMap 是可以保证存入和读取顺序的链式存储，看过 LinkedList 后很容易理解，不再单独介绍。</em></p><a id="more"></a><hr><p>HashMap 通过 hash 算法来存取键值对象，存入和读取没有顺序。TreeMap可对键值对象进行排序（自然排序）。</p><h2 id="一、HashMap-类"><a href="#一、HashMap-类" class="headerlink" title="一、HashMap 类"></a>一、HashMap 类</h2><p>HashMap 类是 Map 接口最常用的实现类，创建对象语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不指定类型</span></span><br><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="comment">//使用泛型，指定键值对的类型。</span></span><br><span class="line">HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br></pre></td></tr></table></figure><p>HashMap 类方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void clear()</td><td>从这张地图中删除所有的映射。</td></tr><tr><td>Object clone()</td><td>返回此 HashMap实例的浅拷贝：键和值本身不被克隆。</td></tr><tr><td>V compute(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</td><td>尝试计算用于指定键和其当前映射的值的映射（或 null如果没有当前映射）。</td></tr><tr><td>V computeIfAbsent(K key, Function&lt;? super K,? extends V&gt; mappingFunction)</td><td>如果指定的键尚未与值相关联（或映射到 null ），则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非 null 。</td></tr><tr><td>V computeIfPresent(K key, BiFunction&lt;? super K,? super V,? extends V&gt; remappingFunction)</td><td>如果指定的密钥的值存在且非空，则尝试计算给定密钥及其当前映射值的新映射。</td></tr><tr><td>boolean containsKey(Object key)</td><td>如果此映射包含指定键的映射，则返回 true 。</td></tr><tr><td>boolean containsValue(Object value)</td><td>如果此地图将一个或多个键映射到指定值，则返回 true 。</td></tr><tr><td>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</td><td>返回此地图中包含的映射的Set视图。</td></tr><tr><td>void forEach(BiConsumer&lt;? super K,? super V&gt; action)</td><td>对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。</td></tr><tr><td>V get(Object key)</td><td>返回到指定键所映射的值，或 null如果此映射包含该键的映射。</td></tr><tr><td>V getOrDefault(Object key, V defaultValue)</td><td>返回到指定键所映射的值，或 defaultValue如果此映射包含该键的映射。</td></tr><tr><td>boolean isEmpty()</td><td>如果此地图不包含键值映射，则返回 true 。</td></tr><tr><td>Set&lt;K&gt; keySet()</td><td>返回此地图中包含的键的Set视图。</td></tr><tr><td>V merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction)</td><td>如果指定的键尚未与值相关联或与null相关联，则将其与给定的非空值相关联。</td></tr><tr><td>V put(K key, V value)</td><td>将指定的值与此映射中的指定键相关联。</td></tr><tr><td>void putAll(Map&lt;? extends K,? extends V&gt; m)</td><td>将指定地图的所有映射复制到此地图。</td></tr><tr><td>V putIfAbsent(K key, V value)</td><td>如果指定的键尚未与某个值相关联（或映射到 null ），则将其与给定值相关联并返回 null ，否则返回当前值。</td></tr><tr><td>V remove(Object key)</td><td>从该地图中删除指定键的映射（如果存在）。</td></tr><tr><td>boolean remove(Object key, Object value)</td><td>仅当指定的密钥当前映射到指定的值时删除该条目。</td></tr><tr><td>V replace(K key, V value)</td><td>只有当目标映射到某个值时，才能替换指定键的条目。</td></tr><tr><td>boolean replace(K key, V oldValue, V newValue)</td><td>仅当当前映射到指定的值时，才能替换指定键的条目。</td></tr><tr><td>void replaceAll(BiFunction&lt;? super K,? super V,? extends V&gt; function)</td><td>将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或该函数抛出异常。</td></tr><tr><td>int size()</td><td>返回此地图中键值映射的数量。</td></tr><tr><td>Collection&lt;V&gt; values()</td><td>返回此地图中包含的值的Collection视图。</td></tr></tbody></table><p>挑一些常用的方法举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">24</span>, <span class="string">"kangkang"</span>);</span><br><span class="line">map.put(<span class="number">15</span>, <span class="string">"jane"</span>);</span><br><span class="line">map.put(<span class="number">13</span>, <span class="string">"jhon"</span>);</span><br><span class="line">map.put(<span class="number">5</span>, <span class="string">"emma"</span>);</span><br><span class="line">map.put(<span class="number">10</span>, <span class="string">"lihua"</span>);</span><br><span class="line">map.put(<span class="number">19</span>, <span class="string">"xiaoming"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"HashMap 长度："</span> + map.size());</span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line"><span class="comment">// 使用Iterator遍历</span></span><br><span class="line">System.out.println(<span class="string">"Iterator 遍历："</span>);</span><br><span class="line">Iterator&lt;Integer&gt; itr = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line"><span class="keyword">int</span> key = itr.next();</span><br><span class="line">System.out.println(key + <span class="string">" : "</span> + map.get(key) + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line"><span class="comment">// 使用foreach遍历</span></span><br><span class="line">System.out.println(<span class="string">"foreach 遍历："</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : map.keySet())</span><br><span class="line">System.out.println(i + <span class="string">" : "</span> + map.get(i) + <span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line"><span class="comment">// 是否存在 key=13 并获取值</span></span><br><span class="line"><span class="keyword">if</span> (map.containsKey(<span class="number">13</span>))</span><br><span class="line">System.out.println(<span class="string">"key=13 的值："</span> + map.get(<span class="number">13</span>));</span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line"><span class="comment">// 删除 key = 13 的值</span></span><br><span class="line">map.remove(<span class="number">13</span>);</span><br><span class="line">System.out.println(<span class="string">"移除key=13 的值后遍历："</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : map.keySet())</span><br><span class="line">System.out.println(i + <span class="string">" : "</span> + map.get(i) + <span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line"><span class="comment">// 复制map 到 map2</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map2 = (HashMap) map.clone();</span><br><span class="line">System.out.println(<span class="string">"map 复制到 map2遍历："</span>);</span><br><span class="line"><span class="keyword">for</span> (Integer i : map2.keySet())</span><br><span class="line">System.out.println(i + <span class="string">" : "</span> + map2.get(i) + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/26/javabase46-map/t1.png" alt="hashmap常用方法"></p><blockquote><p>在添加键值对的过程中，如果 map 中已经有了该 key 值，添加时新 value 值会覆盖 旧 value 值。</p></blockquote><h2 id="二、TreeMap-类"><a href="#二、TreeMap-类" class="headerlink" title="二、TreeMap 类"></a>二、TreeMap 类</h2><p>TreeMap 可以对键值对进行自然排序，类方法与 TreeSet 内的方法用法大致相同，这里不再一一列举，可以查看 JDK 帮助文档。</p><p>写个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">TreeMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">24</span>, <span class="string">"kangkang"</span>);</span><br><span class="line">map.put(<span class="number">15</span>, <span class="string">"jane"</span>);</span><br><span class="line">map.put(<span class="number">13</span>, <span class="string">"jhon"</span>);</span><br><span class="line">map.put(<span class="number">5</span>, <span class="string">"emma"</span>);</span><br><span class="line">map.put(<span class="number">10</span>, <span class="string">"lihua"</span>);</span><br><span class="line">map.put(<span class="number">19</span>, <span class="string">"xiaoming"</span>);</span><br><span class="line"><span class="comment">// 使用Iterator遍历</span></span><br><span class="line">System.out.println(<span class="string">"Iterator 遍历："</span>);</span><br><span class="line">Iterator&lt;Integer&gt; itr = map.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext()) &#123;</span><br><span class="line"><span class="keyword">int</span> key = itr.next();</span><br><span class="line">System.out.println(key + <span class="string">" : "</span> + map.get(key) + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/26/javabase46-map/t2.png" alt="对键值对进行排序"></p><p>发现 TreeMap 按照 key 值进行了自然排序，既然有了顺序，就可以使用方法获得：头部、尾部键值对，某个 key 值前面或者后面的键值对。</p><p>根据 jdk 帮助文档提供的方法结合在 TreeSet 中相应的方法用法的体会，很好理解，就不再举例了。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Map 的结构就像学校的学生，每个学号对应一个学生，它存储的 key→value 键值对，key 与 value 一一对应， key 不可重复，value 值没有限制。本期内容介绍 Map 接口的两个实现类 &lt;strong&gt;HashMap&lt;/strong&gt; 和 &lt;strong&gt;TreeMap&lt;/strong&gt;。LinkedHashMap 是可以保证存入和读取顺序的链式存储，看过 LinkedList 后很容易理解，不再单独介绍。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java集合" scheme="https://Gitsxm.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十五）——Set 集合</title>
    <link href="https://gitsxm.github.io/2020/02/25/javabase45-set/"/>
    <id>https://gitsxm.github.io/2020/02/25/javabase45-set/</id>
    <published>2020-02-25T14:30:39.000Z</published>
    <updated>2020-02-26T13:16:11.609Z</updated>
    
    <content type="html"><![CDATA[<p><em>Set 集合存储的数据无序且独一无二，可以有 null ，但是只能有一个。它实现了 Collection 接口，本篇介绍： <strong>HashSet 和 TreeSet</strong> 两个实现类。 LinkedHashSet 可自行了解，与 HashSet 区别为 LinkedHashSet 内元素按添加顺序排序。</em></p><a id="more"></a><hr><p>开篇提醒：通常说的 Set 无序是不准确的，顺序通常指：按添加的顺序排列 和 按自然顺序a-z排列。</p><ul><li><p>传统说的Set无序是指 HashSet ，它不能保证元素的添加顺序，更不能保证自然顺序；</p></li><li><p>LinkedHashSet可以保证元素添加的顺序；</p></li><li><p>TreeSet可以保证元素自然的顺序。</p></li></ul><h2 id="一、HashSet-类"><a href="#一、HashSet-类" class="headerlink" title="一、HashSet 类"></a>一、HashSet 类</h2><p>HashSet 是 Set 接口的典型实现，使用 Hash 算法存储数据，具有很好的读写性能。</p><p>HashSet具有以下特点：</p><ol><li>无序</li><li>线程不同步，多线程访问需要手动同步数据。</li><li>元素可为 null ，但只能有一个。</li></ol><p>通过对象的 hashCode() 方法获得 hashCode 值，根据 hashCode 值确定存储位置，即使两个对象使用 equals 比较结果为 true ，只要 hashCode 值不同就可以存储。所以 <strong>HashSet 通过判断 equals 方法返回值和 hashCode 值是否完全一致来确定元素是否相等</strong>。</p><p>在 HashSet 类中实现了 Collection 接口中的所有方法。HashSet 类的常用构造方法重载形式如下。</p><ul><li>HashSet()：构造一个新的空的 Set 集合。</li><li>HashSet(Collection&lt;? extends E&gt;c)：构造一个包含指定 Collection 集合元素的新 Set 集合。其中，“&lt; &gt;”中的 extends 表示 HashSet 的父类，即指明该 Set 集合中存放的集合元素类型。c 表示其中的元素将被存放在此 Set 集合中。</li></ul><p>创建 HashSet 对象的两种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashSet hs = <span class="keyword">new</span> HashSet();    <span class="comment">// 调用无参的构造函数创建HashSet对象</span></span><br><span class="line">HashSet&lt;String&gt; hss = <span class="keyword">new</span> HashSet&lt;String&gt;();    <span class="comment">// 创建泛型的 HashSet 集合对象</span></span><br></pre></td></tr></table></figure><p>使用 foreach 或者 Iterator 迭代器遍历</p><blockquote><h3 id="关于-Iterator-迭代器"><a href="#关于-Iterator-迭代器" class="headerlink" title="关于 Iterator 迭代器"></a>关于 Iterator 迭代器</h3><p>Iterator 接口可以说是专门用来迭代遍历集合用的</p><p>提供了四个方法：</p><ol><li>forEachRemaining(Consumer&lt;? super E&gt; action)  对每个剩余元素执行给定的操作，直到所有元素都被处理或动作引发异常。</li><li>hasNext()  如果迭代具有更多元素，则返回 true 。</li><li>next()  返回迭代中的下一个元素。</li><li>remove()  从底层集合中删除此迭代器返回的最后一个元素（可选操作）。 </li></ol><p>比如上篇List只讲了用 foreach 遍历，其实还可以用 Iterator 遍历。<br>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Iterator itr = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(itr.hasNext()) </span><br><span class="line">  System.out.println(itr.next()); <span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure></blockquote><p>举个HashSet用法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">HashSet&lt;String&gt; hs = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">hs.add(<span class="string">"one"</span>);</span><br><span class="line">hs.add(<span class="string">"two"</span>);</span><br><span class="line">hs.add(<span class="string">"three"</span>);</span><br><span class="line">hs.add(<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// foreach 遍历</span></span><br><span class="line">System.out.println(<span class="string">"foreach 遍历"</span>);</span><br><span class="line"><span class="keyword">for</span> (String str : hs)</span><br><span class="line">System.out.print(str + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// Iterator 遍历</span></span><br><span class="line">System.out.println(<span class="string">"\nIterator 遍历"</span>);</span><br><span class="line">Iterator itr = hs.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext())</span><br><span class="line">System.out.print(itr.next() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="/2020/02/25/javabase45-set/t1.png" alt="创建带泛型set并遍历"></p><p>注意：如果向 Set 集合中添加两个相同的元素，则后添加的会覆盖前面添加的元素，即在 Set 集合中不会出现相同的元素。</p><h2 id="二、TreeSet-类"><a href="#二、TreeSet-类" class="headerlink" title="二、TreeSet 类"></a>二、TreeSet 类</h2><p>TreeSet 类同时实现了 Set 接口和 SortedSet 接口。SortedSet 接口是 Set 接口的子接口，可以实现对集合进行自然排序，因此使用 TreeSet 类实现的 Set 接口默认情况下是自然排序的，这里的自然排序指的是升序排序。</p><p>TreeSet 只能对实现了 Comparable 接口的类对象进行排序，因为 Comparable 接口中有一个 compareTo(Object o) 方法用于比较两个对象的大小。例如 a.compareTo(b)，如果 a 和 b 相等，则该方法返回 0；如果 a 大于 b，则该方法返回大于 0 的值；如果 a 小于 b，则该方法返回小于 0 的值。</p><p>Comparable 的三种比较大小方式：</p><ol><li>包装类（BigDecimal、Biglnteger、 Byte、Double、Float、Integer、Long 及 Short) ：按照数字大小比较。</li><li>Character ：按字符的 Unicode 值的数字大小比较</li><li>String ：按字符串中字符的 Unicode 值的数字大小比较</li></ol><p>TreeSet 常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>E first()</td><td>返回此集合中的第一个元素。其中，E 表示集合中元素的数据类型</td></tr><tr><td>E last()</td><td>返回此集合中的最后一个元素</td></tr><tr><td>E poolFirst()</td><td>获取并移除此集合中的第一个元素</td></tr><tr><td>E poolLast()</td><td>获取并移除此集合中的最后一个元素</td></tr><tr><td>SortedSet<E> subSet(E fromElement,E toElement)</E></td><td>返回一个新的集合，新集合包含原集合中 fromElement 对象与 toElement对象之间的所有对象。包含 fromElement 对象，不包含 toElement 对象</td></tr><tr><td>SortedSet<E> headSet(E toElement)</E></td><td>返回一个新的集合，新集合包含原集合中 toElement 对象之前的所有对象。不包含 toElement 对象</td></tr><tr><td>SortedSet<E> tailSet(E fromElement)</E></td><td>返回一个新的集合，新集合包含原集合中 fromElement 对象之后的所有对象。包含 fromElement 对象</td></tr></tbody></table><p>注意：表面上看起来这些方法很多，其实很简单。因为 TreeSet 中的元素是有序的，所以增加了访问第一个、前一个、后一个、最后一个元素的方法，并提供了 3 个从 TreeSet 中截取子 TreeSet 的方法。</p><p>用法举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">TreeSet&lt;Integer&gt; ts = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">ts.add(<span class="number">88</span>);</span><br><span class="line">ts.add(<span class="number">46</span>);</span><br><span class="line">ts.add(<span class="number">99</span>);</span><br><span class="line">ts.add(<span class="number">11</span>);</span><br><span class="line">ts.add(<span class="number">6</span>);</span><br><span class="line">ts.add(<span class="number">56</span>);</span><br><span class="line">Iterator itr = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 遍历原set</span></span><br><span class="line">System.out.println(<span class="string">"遍历原set："</span>);</span><br><span class="line">itr = ts.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext())</span><br><span class="line">System.out.print(itr.next() + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// subSet截取子set 11-88</span></span><br><span class="line">TreeSet&lt;Integer&gt; ts2 = (TreeSet&lt;Integer&gt;) ts.subSet(<span class="number">11</span>, <span class="number">88</span>);</span><br><span class="line"><span class="comment">// Iterator 遍历</span></span><br><span class="line">System.out.println(<span class="string">"\nsubSet截取子set后遍历set："</span>);</span><br><span class="line">itr = ts2.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext())</span><br><span class="line">System.out.print(itr.next() + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// headSet截取子set from56</span></span><br><span class="line">TreeSet&lt;Integer&gt; ts3 = (TreeSet&lt;Integer&gt;) ts.headSet(<span class="number">56</span>);</span><br><span class="line"><span class="comment">// Iterator 遍历</span></span><br><span class="line">System.out.println(<span class="string">"\nheadSet截取子set后遍历set："</span>);</span><br><span class="line">itr = ts3.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext())</span><br><span class="line">System.out.print(itr.next() + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// tailSet截取子set from56</span></span><br><span class="line">TreeSet&lt;Integer&gt; ts4 = (TreeSet&lt;Integer&gt;) ts.tailSet(<span class="number">56</span>);</span><br><span class="line"><span class="comment">// Iterator 遍历</span></span><br><span class="line">System.out.println(<span class="string">"\ntailSet截取子set后遍历set："</span>);</span><br><span class="line">itr = ts4.iterator();</span><br><span class="line"><span class="keyword">while</span> (itr.hasNext())</span><br><span class="line">System.out.print(itr.next() + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/25/javabase45-set/t2.png" alt="获取子set"></p><p>（这些元素的范围可以概括为：参数在头部就包含，在尾部就不包含，java中的使用范围参数的方法大多都这样。）</p><p>jdk 文档中还有众多方法，用法基本和list一样，不再举例了。</p><p>无论是 TreeSet 还是 LinkedHashSet 几乎都很少会用到，最常用的还是 HashSet 。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Set 集合存储的数据无序且独一无二，可以有 null ，但是只能有一个。它实现了 Collection 接口，本篇介绍： &lt;strong&gt;HashSet 和 TreeSet&lt;/strong&gt; 两个实现类。 LinkedHashSet 可自行了解，与 HashSet 区别为 LinkedHashSet 内元素按添加顺序排序。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java集合" scheme="https://Gitsxm.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十四）——List 集合</title>
    <link href="https://gitsxm.github.io/2020/02/25/javabase44-list/"/>
    <id>https://gitsxm.github.io/2020/02/25/javabase44-list/</id>
    <published>2020-02-25T10:39:54.000Z</published>
    <updated>2020-02-26T13:16:16.837Z</updated>
    
    <content type="html"><![CDATA[<p><em>List是一个有序、可重复的集合，与数组相似，通过索引访问元素，且索引从 0 开始，list实现了 Collection 接口，两个主要的常用类：<strong>ArrayList 类和 LinkedList 类</strong>。</em></p><a id="more"></a><hr><h2 id="一、ArrayList-类"><a href="#一、ArrayList-类" class="headerlink" title="一、ArrayList 类"></a>一、ArrayList 类</h2><p>ArrayList 类实现了可变数组大小，靠索引访问元素，对尾部成员的增加和删除支持较好。</p><p>ArrayList 类常用的构造方法有如下形式：</p><ul><li>ArrayList():构造一个出容量为 10 的空列表。</li><li>ArrayList(Collection &lt;? extends E&gt; c):构造一个包含指定 Collection 元素的列表，这些元素是按照该 Collection 的迭代器返回它们的顺序排列的。</li></ul><p>List 接口 为 ArrayList 提供的方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>E get(int index)</td><td>获取此集合中指定索引位置的元素，E 为集合中元素的数据类型</td></tr><tr><td>int index(Object o)</td><td>返回此集合中第一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</td></tr><tr><td>int lastIndexOf(Object o)</td><td>返回此集合中最后一次出现指定元素的索引，如果此集合不包含该元素，则返回 -1</td></tr><tr><td>E set(int index, Eelement)</td><td>将此集合中指定索引位置的元素修改为 element 参数指定的对象。此方法返回此集合中指定索引位置的原元素</td></tr><tr><td>List<E> subList(int fromlndex, int tolndex)</E></td><td>返回一个新的集合，新集合中包含 fromlndex 和 tolndex 索引之间的所有元素。包含 fromlndex 处的元素，不包含 tolndex 索引处的元素</td></tr></tbody></table><p>注意：当调用 List 的 set(int index, Object element) 方法来改变 List 集合指定索引处的元素时，指定的索引必须是 List 集合的有效索引。例如集合长度为 4，就不能指定替换索引为 4 处的元素，也就是说这个方法不会改变 List 集合的长度。</p><p>举个例子：<br>例1，使用 ArrayList 存储 Dog 对象：<br>Dog 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age, String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toString</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dog [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", type="</span> + type + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">List&lt;Dog&gt; list = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">Dog dog1 = <span class="keyword">new</span> Dog(<span class="string">"阿旺"</span>,<span class="number">2</span>, <span class="string">"金毛犬"</span>);</span><br><span class="line">Dog dog2 = <span class="keyword">new</span> Dog(<span class="string">"阿喵"</span>,<span class="number">3</span>, <span class="string">"拉布拉多犬"</span>);</span><br><span class="line">Dog dog3 = <span class="keyword">new</span> Dog(<span class="string">"阿哈"</span>,<span class="number">2</span>, <span class="string">"哈士奇"</span>);</span><br><span class="line">list.add(dog1);</span><br><span class="line">list.add(dog2);</span><br><span class="line">list.add(dog3);</span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">for</span>(Dog dog:list) System.out.println(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2020/02/25/javabase44-list/t1.png" alt="输出结果"></p><p>测试类代码中，&lt;Dog&gt; 就是使用了泛型，在这里先预习一下，表示当前 List 内的元素对象类型为 Dog ，如果不用泛型在 forEach 内部就要用 Object 类型来遍历。使用for循环需要强制转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dog dog = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line"><span class="comment">// 如果不使用泛型 这里要强制转型</span></span><br><span class="line">dog = (Dog) list.get(i);</span><br><span class="line">System.out.println(dog);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2，indexOf 和 lastIndexOf 方法：<br>indexOf() 方法是查询元素的索引，lastIndexOf() 方法查询元素在 list 中最后一次出现的索引，使用时要注意区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"kangkang"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"jhon"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"jane"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"amy"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"lucy"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"amy"</span>));</span><br><span class="line"><span class="keyword">int</span> i = list.indexOf(<span class="string">"jhon"</span>);</span><br><span class="line">System.out.println(<span class="string">"jhon 的位置为"</span> + (i + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">int</span> j = list.lastIndexOf(<span class="string">"amy"</span>);</span><br><span class="line">System.out.println(<span class="string">"amy 的最后位置为"</span> + (j + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="/2020/02/25/javabase44-list/t2.png" alt="输出结果"></p><p>例3，subList 方法：<br>使用subList() 方法截取 List 部分元素，注意参数索引，subList(1,4),截取 1-3 的三个元素，和字符串截取方法 substring 是一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"kangkang"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"jhon"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"jane"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"amy"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"lucy"</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> String(<span class="string">"amy"</span>));</span><br><span class="line">List list2 = list.subList(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (Object str : list2)</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br><img src="/2020/02/25/javabase44-list/t3.png" alt="输出结果"></p><h2 id="二、LinkedList-类"><a href="#二、LinkedList-类" class="headerlink" title="二、LinkedList 类"></a>二、LinkedList 类</h2><p>链表结构，当需要频繁向集合中插入数据的话使用 LinkedList 要比 ArrayList 效率要高。相对的，按照索引检索时就比较慢了。</p><p>LinkedList 类方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void addFirst(E e)</td><td>将指定元素添加到此集合的开头</td></tr><tr><td>void addLast(E e)</td><td>将指定元素添加到此集合的末尾</td></tr><tr><td>E getFirst()</td><td>返回此集合的第一个元素</td></tr><tr><td>E getLast()</td><td>返回此集合的最后一个元素</td></tr><tr><td>E removeFirst()</td><td>删除此集合中的第一个元素</td></tr><tr><td>E removeLast()</td><td>删除此集合中的最后一个元素</td></tr></tbody></table><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">list.add(<span class="number">10</span>);</span><br><span class="line">list.add(<span class="number">9</span>);</span><br><span class="line">list.add(<span class="number">8</span>);</span><br><span class="line">list.add(<span class="number">7</span>);</span><br><span class="line">list.add(<span class="number">6</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 第一个元素</span></span><br><span class="line">System.out.println(<span class="string">"第一个元素为："</span> + list.getFirst());</span><br><span class="line"><span class="comment">// 最后一个元素</span></span><br><span class="line">System.out.println(<span class="string">"最后一个元素为："</span> + list.getLast());</span><br><span class="line">System.out.println(<span class="string">"遍历链表："</span>);</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (Object i : list)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 删去索引为 2的元素</span></span><br><span class="line">list.remove(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"\n删去索引为2的元素后遍历链表："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 在向2处插入8</span></span><br><span class="line">list.add(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">"\n在索引为2处插入8后遍历链表："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 删除第一个元素</span></span><br><span class="line">list.removeFirst();</span><br><span class="line"><span class="comment">// 删除最后一个元素</span></span><br><span class="line">list.removeLast();</span><br><span class="line">System.out.println(<span class="string">"\n掐头去尾后遍历链表："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/25/javabase44-list/t4.png" alt="输出结果"></p><h2 id="三、ArrayList-与-LinkedList-区别"><a href="#三、ArrayList-与-LinkedList-区别" class="headerlink" title="三、ArrayList 与 LinkedList 区别"></a>三、ArrayList 与 LinkedList 区别</h2><p>ArrayList 与 LinkedList 都是 List 接口的实现类，因此都实现了 List 的所有未实现的方法，只是实现的方式有所不同。</p><p>ArrayList 是基于动态数组数据结构的实现，访问元素速度优于 LinkedList。LinkedList 是基于链表数据结构的实现，占用的内存空间比较大，但在批量插入或删除数据时优于 ArrayList。</p><p>对于快速访问对象的需求，使用 ArrayList 实现执行效率上会比较好。需要频繁向集合中插入和删除元素时，使用 LinkedList 类比 ArrayList 类效果高。</p><p>不同的结构对应于不同的算法，有的考虑节省占用空间，有的考虑提高运行效率，对于程序员而言，它们就像是“熊掌”和“鱼肉”，不可兼得。高运行速度往往是以牺牲空间为代价的，而节省占用空间往往是以牺牲运行速度为代价的。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;List是一个有序、可重复的集合，与数组相似，通过索引访问元素，且索引从 0 开始，list实现了 Collection 接口，两个主要的常用类：&lt;strong&gt;ArrayList 类和 LinkedList 类&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java集合" scheme="https://Gitsxm.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十三）——集合、Collection 接口</title>
    <link href="https://gitsxm.github.io/2020/02/25/javabase43-collection/"/>
    <id>https://gitsxm.github.io/2020/02/25/javabase43-collection/</id>
    <published>2020-02-25T07:47:16.000Z</published>
    <updated>2020-02-26T13:16:23.511Z</updated>
    
    <content type="html"><![CDATA[<p><em>随着程序越来越复杂，数组已经不能满足数组存储的需要，况且声明数组需要设定长度，不够灵活。Java为开发者提供了内容丰富、功能强大的集合类，处于 java.util 包中，分为 Collection 和 Map 两个根接口，接下来详细讲解 Collection 接口。</em></p><a id="more"></a><hr><h2 id="一、集合简介"><a href="#一、集合简介" class="headerlink" title="一、集合简介"></a>一、集合简介</h2><p>Java 集合类型分为 Collection 和 Map，同为Java集合根接口，集合的众多功能来源于两个接口的子接口和实现类。<br><img src="/2020/02/25/javabase43-collection/jh.gif" alt="集合结构"></p><p>下面对集合的接口和实现类分别做个简单的介绍：</p><h3 id="集合接口："><a href="#集合接口：" class="headerlink" title="集合接口："></a>集合接口：</h3><table><thead><tr><th>接口</th><th>说明</th></tr></thead><tbody><tr><td>Iterator 接口</td><td>集合的输出接口，主要用于遍历输出（即迭代访问）Collection 集合中的元素，Iterator 对象被称之为迭代器。迭代器接口是集合接口的父接口，实现类实现 Collection 时就必须实现 Iterator 接口。</td></tr><tr><td>Collection 接口</td><td>是 List、Set 和 Queue 的父接口，是存放一组单值的最大接口。所谓的单值是指集合中的每个元素都是一个对象。一般很少直接使用此接口直接操作。</td></tr><tr><td>Queue 接口</td><td>Queue 是 Java 提供的队列实现，有点类似于 List。</td></tr><tr><td>Dueue 接口</td><td>是 Queue 的一个子接口，为双向队列。</td></tr><tr><td>List 接口</td><td>是最常用的接口。是有序集合，允许有相同的元素。使用 List 能够精确地控制每个元素插入的位置，用户能够使用索引（元素在 List 中的位置，类似于数组下标）来访问 List 中的元素，与数组类似。</td></tr><tr><td>Set 接口</td><td>不能包含重复的元素。</td></tr><tr><td>Map 接口</td><td>是存放一对值的最大接口，即接口中的每个元素都是一对，以 key→value 的形式保存。</td></tr></tbody></table><p>对于 Set、List、Queue 和 Map 这 4 种集合，Java 最常用的实现类分别是 HashSet、TreeSet、ArrayList、ArrayDueue、LinkedList 和 HashMap、TreeMap 等。</p><h3 id="集合实现类"><a href="#集合实现类" class="headerlink" title="集合实现类"></a>集合实现类</h3><table><thead><tr><th>类名称</th><th>说明</th></tr></thead><tbody><tr><td>HashSet</td><td>为优化査询速度而设计的 Set。它是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，实现比较简单</td></tr><tr><td>TreeSet</td><td>实现了 Set 接口，是一个有序的 Set，这样就能从 Set 里面提取一个有序序列</td></tr><tr><td>ArrayList</td><td>一个用数组实现的 List，能进行快速的随机访问，效率高而且实现了可变大小的数组</td></tr><tr><td>ArrayDueue</td><td>是一个基于数组实现的双端队列，按“先进先出”的方式操作集合元素</td></tr><tr><td>LinkedList</td><td>对顺序访问进行了优化，但随机访问的速度相对较慢。此外它还有 addFirst()、addLast()、getFirst()、getLast()、removeFirst() 和 removeLast() 等方法，能把它当成栈（Stack）或队列（Queue）来用</td></tr><tr><td>HsahMap</td><td>按哈希算法来存取键对象</td></tr><tr><td>TreeMap</td><td>可以对键对象进行排序</td></tr></tbody></table><h2 id="二、Collection-接口详解"><a href="#二、Collection-接口详解" class="headerlink" title="二、Collection 接口详解"></a>二、Collection 接口详解</h2><p>Collection 接口是 List、Set 和 Queue 的父接口，通常不直接使用，通过 Collection 接口中的一些通用方法，可以实现集对集合的基本操作。</p><p>Collection 接口中的常用方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>向集合中添加一个元素，如果集合对象被添加操作改变了，则返回 true。E 是元素的数据类型</td></tr><tr><td>boolean addAll(Collection c)</td><td>向集合中添加集合 c 中的所有元素，如果集合对象被添加操作改变了，则返回 true。</td></tr><tr><td>void clear()</td><td>清除集合中的所有元素，将集合长度变为 0。</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否存在指定元素</td></tr><tr><td>boolean containsAll(Collection c)</td><td>判断集合中是否包含集合 c 中的所有元素</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>Iterator<E>iterator()</E></td><td>返回一个 Iterator 对象，用于遍历集合中的元素</td></tr><tr><td>boolean remove(Object o)</td><td>从集合中删除一个指定元素，当集合中包含了一个或多个元素 o 时，该方法只删除第一个符合条件的元素，该方法将返回 true。</td></tr><tr><td>boolean removeAll(Collection c)</td><td>从集合中删除所有在集合 c 中出现的元素（相当于把调用该方法的集合减去集合 c）。如果该操作改变了调用该方法的集合，则该方法返回 true。</td></tr><tr><td>boolean retainAll(Collection c)</td><td>从集合中删除集合 c 里不包含的元素（相当于把调用该方法的集合变成该集合和集合 c 的交集），如果该操作改变了调用该方法的集合，则该方法返回 true。</td></tr><tr><td>int size()</td><td>返回集合中元素的个数</td></tr><tr><td>Object[] toArray()</td><td>把集合转换为一个数组，所有的集合元素变成对应的数组元素。</td></tr></tbody></table><p>这些方法源于 jdk 帮助文档，只需记住 Collection 为我们提供了操作集合的常用方法就可以，例如判断非空，存在，遍历，长度，新增，删减等方法，有需要但是不会用的话直接去查文档即可。</p><p>用法举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">List list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">List list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">// 为集合添加元素</span></span><br><span class="line">list1.add(<span class="number">3</span>);</span><br><span class="line">list1.add(<span class="number">2</span>);</span><br><span class="line">list1.add(<span class="number">22</span>);</span><br><span class="line">list1.add(<span class="number">33</span>);</span><br><span class="line">list1.add(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 判断集合是否为空</span></span><br><span class="line">System.out.println(<span class="string">"list1 if empty? "</span> + list1.isEmpty());</span><br><span class="line"><span class="comment">// 获取长度</span></span><br><span class="line">System.out.println(<span class="string">"list1 长度： "</span> + list1.size());</span><br><span class="line"><span class="comment">// 判断是否存在指定元素</span></span><br><span class="line">System.out.println(<span class="string">"list1 exist 11? "</span> + list1.contains(<span class="number">11</span>));</span><br><span class="line"><span class="comment">// 遍历集合list1</span></span><br><span class="line">System.out.print(<span class="string">"list1 中元素："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list1)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// 通过list1 为list2 赋值</span></span><br><span class="line">list2.addAll(list1);</span><br><span class="line"><span class="comment">// 遍历list2</span></span><br><span class="line">System.out.print(<span class="string">"list1为list2赋值后 list2包含元素："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list2)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// 通过索引获取元素</span></span><br><span class="line">System.out.println(<span class="string">"list2 索引为3的元素："</span> + list2.get(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// 为list2 添加元素</span></span><br><span class="line">list2.add(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 移除 list2 中 在list1中没有的元素 10</span></span><br><span class="line">list2.retainAll(list1);</span><br><span class="line"><span class="comment">// retainAll后 遍历list2 元素</span></span><br><span class="line">System.out.print(<span class="string">"retainAll后遍历list2 元素："</span>);</span><br><span class="line"><span class="keyword">for</span> (Object i : list2)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// 移除list2 所有元素</span></span><br><span class="line">list2.removeAll(list2);</span><br><span class="line"><span class="comment">// 移除后list2长度</span></span><br><span class="line">System.out.println(<span class="string">"list2移除所有元素后长度："</span> + list2.size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/25/javabase43-collection/jhcz.png" alt="集合一般操作"></p><p>在写代码时会发现在编辑器中会出现大量黄色下划线，这是因为没有为集合指定类型的警告，涉及到了泛型的知识，后面详细讲解。如果不指定类型的话默认设定为 Object ，警告并不会影响编译和运行，不用管。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;随着程序越来越复杂，数组已经不能满足数组存储的需要，况且声明数组需要设定长度，不够灵活。Java为开发者提供了内容丰富、功能强大的集合类，处于 java.util 包中，分为 Collection 和 Map 两个根接口，接下来详细讲解 Collection 接口。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java集合" scheme="https://Gitsxm.github.io/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十二）——Log日志记录</title>
    <link href="https://gitsxm.github.io/2020/02/25/javabase42-log/"/>
    <id>https://gitsxm.github.io/2020/02/25/javabase42-log/</id>
    <published>2020-02-25T01:04:58.000Z</published>
    <updated>2020-02-26T13:16:31.193Z</updated>
    
    <content type="html"><![CDATA[<p><em>程序在部署运行时，不可能时时有人盯着会发生什么异常，这时候需要一个记录程序运行过程的工具，方便程序员查找关键信息，本篇介绍Java自带的日志工具类——java.util.logging。</em></p><a id="more"></a><hr><p>初学Java时经常用控制台打印 System.out.println() 来观察代码运行情况，随着代码越来越复杂，程序中就会出现很多这种代码，没有问题后再删去，非常麻烦，Java 为开发者提供了日志工具包 java.util.logging ，方便程序员快速定位问题所在。</p><p>想要快速生成日志记录，直接调用 Logger 类的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().info(<span class="string">"日志信息"</span>);</span><br></pre></td></tr></table></figure><p>Logging 把日志分为7个安全级别，等级一次降低。</p><table><thead><tr><th>等级</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>SEVERE</td><td>severe()</td><td>严重</td></tr><tr><td>WARNING</td><td>warning()</td><td>警告</td></tr><tr><td>INFO</td><td>info()</td><td>信息</td></tr><tr><td>CONFIG</td><td>config()</td><td>配置</td></tr><tr><td>FINE</td><td>fine()</td><td>良好</td></tr><tr><td>FINER</td><td>finer()</td><td>较好</td></tr><tr><td>FINEST</td><td>finest()</td><td>最好</td></tr></tbody></table><p>Logger 默认安全级别为 INFO ，比 INFO 级别低的日志将不显示。Logger 的默认级别定义在 jre 安装目录的 lib 下面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Limit the message that are printed on the console to INFO and above.</span><br><span class="line">java.util.logging.ConsoleHandler.level = INFO</span><br></pre></td></tr></table></figure><p>默认情况下，日志只显示三个级别，INFO、WARNING、SERVERE。获得 Logger 对象后可以使用 对象.方法 来使用日志，还可以使用 对象.log(Level.INFO,msg) 来调用。<br>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Logger.getGlobal().info(<span class="string">"it is INFO msg"</span>);<span class="comment">// 静态方法</span></span><br><span class="line">Logger logger = Logger.getGlobal();<span class="comment">// 获取 Logger 对象</span></span><br><span class="line">logger.severe(<span class="string">"it is SEVERE msg"</span>);</span><br><span class="line">logger.log(Level.WARNING, <span class="string">"it is WARNING msg"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台：<br><img src="/2020/02/25/javabase42-log/l1.png" alt="三种使用日志的方法"></p><p>可以使用 setLevel 方法设置级别，例如 logger.setLevel(Level.FINE) 可以将 FINE 和更高级别的都记录下来。另外，还可以使用 Level.ALL 开启所有级别的记录，或者使用 Level.OFF 关闭所有级别的记录。</p><p>注意：如果将记录级别设计为 INFO 或者更低，则需要修改日志处理器的配置。默认的日志处理器不会处理低于 INFO 级别的信息。</p><blockquote><h3 id="修改日志管理器配置"><a href="#修改日志管理器配置" class="headerlink" title="修改日志管理器配置"></a>修改日志管理器配置</h3><p>可以通过编辑配置文件来修改日志系统的各种属性。在默认情况下，配置文件存在于 jre 安装目录下“jre/lib/logging.properties”。要想使用另一个配置文件，就要将 java.util.logging.config.file 特性设置为配置文件的存储位置，并用下列命令启动应用程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.util.logging.config.file = configFile MainClass</span><br></pre></td></tr></table></figure><p>日志管理器在 JVM 启动过程中初始化，这在 main 执行之前完成。如果在 main 中调用System.setProperty(“java.util.logging.config.file”,file) ，也会调用LogManager.readConfiguration() 来重新初始化日志管理器。</p><p>要想修改默认的日志记录级别，就需要编辑配置文件，并修改以下命令行。</p><p>.level=INFO</p><p>可以通过添加以下内容来指定自己的日志记录级别</p><p>Test.Test.level=FINE</p><p>也就是说，在日志记录器名后面添加后缀 .level。</p><p>在稍后可以看到，日志记录并不将消息发送到控制台上，这是处理器的任务。另外，处理器也有级别。要想在控制台上看到 FINE 级别的消息，就需要进行下列设置。</p><p>java.util.logging.ConsoleHandler.level=FINE</p><p>注意：在日志管理器配置的属性设置不是系统属性，因此，用-Dcom.mycompany.myapp.level=FINE启动应用程序不会对日志记录器产生任何影响。</p></blockquote><p>在开发项目过程中通常会使用开源的日志记录脚手架 log4j2 ，通过修改简单的配置文件就可以完成日志记录的工作，log4j2 后面单独写博客来说。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;程序在部署运行时，不可能时时有人盯着会发生什么异常，这时候需要一个记录程序运行过程的工具，方便程序员查找关键信息，本篇介绍Java自带的日志工具类——java.util.logging。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java异常处理" scheme="https://Gitsxm.github.io/tags/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十一）——异常处理</title>
    <link href="https://gitsxm.github.io/2020/02/24/javabase41-exception/"/>
    <id>https://gitsxm.github.io/2020/02/24/javabase41-exception/</id>
    <published>2020-02-24T13:34:55.000Z</published>
    <updated>2020-02-26T13:16:37.964Z</updated>
    
    <content type="html"><![CDATA[<p><em>在程序执行中难免会遇到一些错误，且难以避免，称为异常，有时候是代码逻辑上的错误，比如用 0 做了除数，有些是物理错误，比如 jvm 内存溢出，本篇内容学习如何处理异常。</em></p><a id="more"></a><hr><h2 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h2><p>异常发生的原因通常分为：</p><ul><li>输入非法数据</li><li>寻找的资源不存在</li><li>通信终端或者 jvm 内存溢出</li></ul><p>有些是用户操作错误，有些是程序 bug ，有些是物理因素影响，通常我们把 java 程序异常分为：</p><ul><li>检查性异常：程序员无法预见用户操作产生的异常，如打开不存在的文件，该异常不可以轻易忽略。</li><li>运行时异常：可以被程序员避免的异常，如常见的空指针异常，可以在编译时被忽略。</li><li>错误：错误不是异常，脱离程序员控制的问题，代码可能会对这些错误产生影响，当栈溢出时会发生错误，编译时检查补到，但是很可能和代码有关系。</li></ul><h3 id="一、Exception-类的层次"><a href="#一、Exception-类的层次" class="headerlink" title="一、Exception 类的层次"></a>一、Exception 类的层次</h3><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p><p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p><p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</p><p>Error 用来指示运行时环境发生的错误。</p><p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p><p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p><p><img src="/2020/02/24/javabase41-exception/ex.png" alt="Exception层次关系"></p><h3 id="二、java内置异常类"><a href="#二、java内置异常类" class="headerlink" title="二、java内置异常类"></a>二、java内置异常类</h3><p>Java 语言定义了一些异常类在 java.lang 标准包中。</p><p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p><p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的<em>非检查性异常</em>。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ArithmeticException</td><td>当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td></tr><tr><td>ArrayStoreException</td><td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td></tr><tr><td>ClassCastException</td><td>当试图将对象强制转换为不是实例的子类时，抛出该异常。</td></tr><tr><td>IllegalArgumentException</td><td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td></tr><tr><td>IllegalMonitorStateException</td><td>抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td></tr><tr><td>IllegalStateException</td><td>在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td></tr><tr><td>IllegalThreadStateException</td><td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td></tr><tr><td>IndexOutOfBoundsException</td><td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td></tr><tr><td>NegativeArraySizeException</td><td>如果应用程序试图创建大小为负的数组，则抛出该异常。</td></tr><tr><td>NullPointerException</td><td>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</td></tr><tr><td>NumberFormatException</td><td>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td></tr><tr><td>SecurityException</td><td>由安全管理器抛出的异常，指示存在安全侵犯。</td></tr><tr><td>StringIndexOutOfBoundsException</td><td>此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</td></tr><tr><td>UnsupportedOperationException</td><td>当不支持请求的操作时，抛出该异常。</td></tr></tbody></table><p>下面的表中列出了 Java 定义在 java.lang 包中的<em>检查性异常类</em>。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>应用程序试图加载类时，找不到相应的类，抛出该异常。</td></tr><tr><td>CloneNotSupportedException</td><td>当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</td></tr><tr><td>IllegalAccessException</td><td>拒绝访问一个类的时候，抛出该异常。</td></tr><tr><td>InstantiationException</td><td>当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td></tr><tr><td>InterruptedException</td><td>一个线程被另一个线程中断，抛出该异常。</td></tr><tr><td>NoSuchFieldException</td><td>请求的变量不存在</td></tr><tr><td>NoSuchMethodException</td><td>请求的方法不存在</td></tr></tbody></table><h3 id="三、异常方法"><a href="#三、异常方法" class="headerlink" title="三、异常方法"></a>三、异常方法</h3><p>下面的列表是 Throwable 类的主要方法:</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td></tr><tr><td>public Throwable getCause()</td><td>返回一个Throwable 对象代表异常原因。</td></tr><tr><td>public String toString()</td><td>使用getMessage()的结果返回类的串级名字。</td></tr><tr><td>public void printStackTrace()</td><td>打印toString()结果和栈层次到System.err，即错误输出流。</td></tr><tr><td>public StackTraceElement [] getStackTrace()</td><td>返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td></tr><tr><td>public Throwable fillInStackTrace()</td><td>用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td></tr></tbody></table><p>这些方法常常在try catch 块中使用。</p><h3 id="四、捕获异常"><a href="#四、捕获异常" class="headerlink" title="四、捕获异常"></a>四、捕获异常</h3><p>在前面博客已有提到 try catch 块，下面单独说一下。</p><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p><p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//Catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p><p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="number">11</span>/<span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace(); <span class="comment">//java.lang.ArithmeticException: / by zero</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获除数为 0 异常，并打印到控制台。<br><img src="/2020/02/24/javabase41-exception/e1.png" alt="捕获异常"></p><h3 id="五、多重捕获串"><a href="#五、多重捕获串" class="headerlink" title="五、多重捕获串"></a>五、多重捕获串</h3><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。<br>多重捕获块的语法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多 catch 的情况下陈旭出现的异常会向下按顺序匹配，直到匹配到对应类型的异常。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String fileName = <span class="string">"d:\\1.txt"</span>;</span><br><span class="line">FileInputStream file = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">Byte x = (<span class="keyword">byte</span>) file.read();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException f) &#123;</span><br><span class="line">f.printStackTrace();</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException i) &#123;</span><br><span class="line">i.printStackTrace();</span><br><span class="line">System.out.println(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/24/javabase41-exception/e2.png" alt="捕获异常"></p><h3 id="六、throws-throw-关键字"><a href="#六、throws-throw-关键字" class="headerlink" title="六、throws\throw 关键字"></a>六、throws\throw 关键字</h3><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p><p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p><p>下面方法的声明抛出一个 RemoteException 异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Method implementation</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p><p>例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException,</span></span><br><span class="line"><span class="function">                              InsufficientFundsException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// Method implementation</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、finally-关键字"><a href="#七、finally-关键字" class="headerlink" title="七、finally 关键字"></a>七、finally 关键字</h3><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。</p><p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p><p>finally 代码块出现在 catch 代码块最后，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="number">11</span> / <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"方法执行完了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/24/javabase41-exception/e3.png" alt="运行结果"></p><p>注意下面事项：</p><ul><li>catch 不能独立于 try 存在。</li><li>在 try/catch 后面添加 finally 块并非强制性要求的。</li><li>try 代码后不能既没 catch 块也没 finally 块。</li><li>try, catch, finally 块之间不能添加任何代码。</li></ul><h3 id="八、声明自定义异常"><a href="#八、声明自定义异常" class="headerlink" title="八、声明自定义异常"></a>八、声明自定义异常</h3><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p><ul><li>所有异常都必须是 Throwable 的子类。</li><li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li><li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li></ul><p>可以像下面这样定义自己的异常类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只继承Exception 类来创建的异常类是检查性异常类。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivisorIsZeroException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> divisor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DivisorIsZeroException</span><span class="params">(<span class="keyword">double</span> divisor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.divisor = divisor;</span><br><span class="line">System.out.print(<span class="string">"divisor is zero "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DivisorIsZeroException</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DivisorIsZeroException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> DivisorIsZeroException(i);</span><br><span class="line">System.out.println(<span class="number">11</span> / i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/24/javabase41-exception/e4.png" alt="运行结果"></p><h3 id="九、通用异常"><a href="#九、通用异常" class="headerlink" title="九、通用异常"></a>九、通用异常</h3><p>在Java中定义了两种类型的异常和错误。</p><ul><li>JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</li><li>程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在程序执行中难免会遇到一些错误，且难以避免，称为异常，有时候是代码逻辑上的错误，比如用 0 做了除数，有些是物理错误，比如 jvm 内存溢出，本篇内容学习如何处理异常。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java异常处理" scheme="https://Gitsxm.github.io/tags/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十）——内部类（四种）</title>
    <link href="https://gitsxm.github.io/2020/02/24/javabase40-inner/"/>
    <id>https://gitsxm.github.io/2020/02/24/javabase40-inner/</id>
    <published>2020-02-24T08:22:26.000Z</published>
    <updated>2020-02-26T13:16:43.360Z</updated>
    
    <content type="html"><![CDATA[<p><em>在类的内部可以嵌套一个类，称为内部类，外面的类称为外部类，内部类又可以分为四种，<strong>本篇内容：成员内部类、局部内部类、匿名内部类和静态内部类。</strong></em></p><a id="more"></a><hr><p>内部类可以很好地实现隐藏，一般的非内部类是不允许有 private 与 protected 权限的，但内部类可以。内部类拥有外部类的所有元素的访问权限，接下来分别介绍四种内部类。</p><h2 id="一、成员内部类"><a href="#一、成员内部类" class="headerlink" title="一、成员内部类"></a>一、成员内部类</h2><p>最普通的内部类，定义在一个类的内部，请仔细阅读代码注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"Mgg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Out</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: usrInnerMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 调用内部类成员</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">usrInnerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 想要使用内部类成员需要先创建内部类对象</span></span><br><span class="line">getInnerInstance().print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为创建对象方便创建一个获得内部类对象的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getInnerInstance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获得内部类对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Out.Inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Inner</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 内部类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> Feb 24, 2020</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;<span class="comment">// 内部类私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"内部类的  print 方法"</span>);</span><br><span class="line">System.out.println(num);<span class="comment">// 默认调用内部类成员</span></span><br><span class="line">System.out.println(Out.<span class="keyword">this</span>.num);<span class="comment">// 调用外部类私有成员</span></span><br><span class="line">System.out.println(str); <span class="comment">// 调用外部类静态成员</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个测试类 Test ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Out out = <span class="keyword">new</span> Out(-<span class="number">10</span>);</span><br><span class="line">out.getInnerInstance().print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/24/javabase40-inner/t1.png" alt="通过外部类使用内部类方法"></p><p>通过例子总结成员内部类的特点：</p><ul><li>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</li><li>成员内部类拥有和外部类同名的成员变量或者方法时，默认调用的是内部类成员，外部类成员需要使用 [外部类.this.成员变量/方法] 的方法调用。</li><li>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。</li></ul><blockquote><p>通常外部类不使用 private、protected 修饰，成员内部类则可以使用的四种权限，比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。</p></blockquote><h2 id="二、局部内部类"><a href="#二、局部内部类" class="headerlink" title="二、局部内部类"></a>二、局部内部类</h2><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外部父类eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: eat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: animal eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Animal eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getCat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获得局部内部类的对象的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 局部内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">// 重写了父类 eat方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Cat eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Cat(); <span class="comment">// 向上转型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal anim = Animal.getCat();</span><br><span class="line">anim.eat(); <span class="comment">// Cat eat</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</p></blockquote><h2 id="三、匿名内部类"><a href="#三、匿名内部类" class="headerlink" title="三、匿名内部类"></a>三、匿名内部类</h2><p>匿名内部类形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> &lt;类或接口&gt; ()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名类有两种实现方式：</p><ol><li>继承一个类，重写其方法。</li><li>实现一个接口（可以是多个），实现其方法。</li></ol><p>举个继承类的例子<br>Animal 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外部父类eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: eat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: animal eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Animal eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal ani = <span class="keyword">new</span> Cat() &#123;</span><br><span class="line"><span class="comment">// 重写了eat方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"匿名内部类的 eat方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ani.eat(); <span class="comment">// 匿名内部类的 eat方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/24/javabase40-inner/t2.png" alt="使用继承完成内部匿名类"></p><p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为 Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p><h2 id="四、静态内部类"><a href="#四、静态内部类" class="headerlink" title="四、静态内部类"></a>四、静态内部类</h2><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outstatic</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> String str = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Innerstatic</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(i); //Cannot make a static reference to the non-static field i</span></span><br><span class="line">        System.out.println(str); <span class="comment">// Hello</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Outstatic out = <span class="keyword">new</span> Outstatic();</span><br><span class="line">Outstatic.Innerstatic oi = <span class="keyword">new</span>  Outstatic.Innerstatic();</span><br><span class="line">oi.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/24/javabase40-inner/t.png" alt="运行结果"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在类的内部可以嵌套一个类，称为内部类，外面的类称为外部类，内部类又可以分为四种，&lt;strong&gt;本篇内容：成员内部类、局部内部类、匿名内部类和静态内部类。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java继承多态" scheme="https://Gitsxm.github.io/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十九）——接口（Interface）</title>
    <link href="https://gitsxm.github.io/2020/02/24/javabase39-interface/"/>
    <id>https://gitsxm.github.io/2020/02/24/javabase39-interface/</id>
    <published>2020-02-24T02:53:16.000Z</published>
    <updated>2020-02-26T13:16:48.537Z</updated>
    
    <content type="html"><![CDATA[<p><em>抽象类中可以有抽象方法也可以有普通方法，Java为我们提供了一个专门收纳抽象方法的抽象类型——接口（interface），接口与类是两种不同的概念。</em></p><a id="more"></a><hr><p>与类对比理解：<br><strong>接口与类相似点：</strong></p><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><p><strong>接口与类的区别：</strong></p><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><p><strong>接口特性</strong></p><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><p><strong>抽象类和接口的区别</strong></p><ol><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口</li></ol><h2 id="一、接口声明"><a href="#一、接口声明" class="headerlink" title="一、接口声明"></a>一、接口声明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[public] interface interface_name [extends interface1_name[, interface2_name,…]] &#123;</span><br><span class="line">    <span class="comment">// 接口体，其中可以包含定义常量和声明方法</span></span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] type constant_name = value;    <span class="comment">// 定义常量</span></span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] <span class="function">returnType <span class="title">method_name</span><span class="params">(parameter_list)</span></span>;    <span class="comment">// 声明方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上语法的说明如下：</p><ul><li>public 表示接口的修饰符，当没有修饰符时，则使用默认的修饰符，此时该接口的访问权限仅局限于所属的包；</li><li>interface_name 表示接口的名称。接口名应与类名采用相同的命名规则，即如果仅从语法角度来看，接口名只要是合法的标识符即可。如果要遵守 Java 可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写，单词与单词之间无需任何分隔符。</li><li>extends 表示接口的继承关系；</li><li>interface1_name 表示要继承的接口名称；</li><li>constant_name 表示变量名称，一般是 static 和 final 型的；</li><li>returnType 表示方法的返回值类型；</li><li>parameter_list 表示参数列表，在接口中的方法是没有方法体的。</li></ul><p>动手创建一个接口 Animal ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">//全局常量动物园名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zoo = <span class="string">"幻想乡动物园"</span>;</span><br><span class="line">    <span class="comment">//饲养员</span></span><br><span class="line">String feeder = <span class="string">"kangkang"</span>; <span class="comment">// 推荐这样定义，因为默认的修饰就是  public static final</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: run   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 run 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 jump 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>;<span class="comment">//推荐这样定义 默认修饰为  public abstract</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: eat   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 eat 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;<span class="comment">//推荐这样定义 默认修饰为  public abstract</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: sleep   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 sleep 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;<span class="comment">//推荐这样定义 默认修饰为  public abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提醒一下：接口中的常量必须有初始值，否则无法通过编译。推荐不使用修饰符修饰，默认即可，保持代码简洁（但是团队开发中需要看规范如何要求）。</p><h2 id="二、接口的实现"><a href="#二、接口的实现" class="headerlink" title="二、接口的实现"></a>二、接口的实现</h2><p>Java允许一个类实现多个接口，以补充类单继承的不足。继承使用 extends 关键字，实现则使用 implements 关键字，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;public&gt; class &lt;class_name&gt; [extends superclass_name] [implements interface1_name[, interface2_name…]] &#123;</span><br><span class="line">    <span class="comment">// 主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上语法的说明如下：</p><ul><li>public：类的修饰符；</li><li>superclass_name：需要继承的父类名称；</li><li>interface1_name：要实现的接口名称。</li></ul><p>实现接口需要注意以下几点：</p><ol><li>实现接口与继承父类相似，一样可以获得所实现接口里定义的常量和方法。如果一个类需要实现多个接口，则多个接口之间以逗号分隔。</li><li>一个类可以继承一个父类，并同时实现多个接口，implements 部分必须放在 extends 部分之后。</li><li>一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。</li></ol><p>Demo：<br>创建 Lion 类 实现 Animal 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion run"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion jump"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion sleep"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</p></blockquote><p>测试类 Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Lion lion = <span class="keyword">new</span> Lion();</span><br><span class="line">lion.eat();</span><br><span class="line">lion.run();</span><br><span class="line">lion.jump();</span><br><span class="line">lion.sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2020/02/24/javabase39-interface/t.png" alt="运行结果"></p><h2 id="三、接口继承"><a href="#三、接口继承" class="headerlink" title="三、接口继承"></a>三、接口继承</h2><p>和类以一样，使用 extends 关键字继承父接口，不同的是接口支持多继承，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Biology</span>,<span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 猫爬树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: climbTree   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">climbTree</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了 Cat 接口继承了 Biology（生物），Animal（动物） 接口，只使用了一个 extends 关键字，后面的多个接口用 “ , “ 隔开。</p><p>当新建类实现 Cat 接口时，这个类就要重写 Cat 接口内的所有抽象方法。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;抽象类中可以有抽象方法也可以有普通方法，Java为我们提供了一个专门收纳抽象方法的抽象类型——接口（interface），接口与类是两种不同的概念。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java继承多态" scheme="https://Gitsxm.github.io/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十八）—— 抽象类</title>
    <link href="https://gitsxm.github.io/2020/02/24/javabase38-abstract/"/>
    <id>https://gitsxm.github.io/2020/02/24/javabase38-abstract/</id>
    <published>2020-02-24T01:46:42.000Z</published>
    <updated>2020-02-26T13:16:53.496Z</updated>
    
    <content type="html"><![CDATA[<p><em>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</em></p><a id="more"></a><hr><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>Java 中使用 abstract 来定义抽象类，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: run</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 抽象方法 run</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: sleep   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 普通方法 sleep </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zzzzzzzzz...."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获取名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: setName   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 设置名字 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toString</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Animal [name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类是不能直接实例化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal(<span class="string">"huahua"</span>);<span class="comment">//Cannot instantiate the type Animal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是可以通过继承来实例化：<br>创建一个 Dog 类继承 Animal 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.print(<span class="keyword">this</span>.getName()+<span class="string">" dog run!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 Dog 类时，eclipse 会提示重写父类抽象方法，不然在类名字下面有红线。</p><p>所以当继承抽象类时必须重写父类的抽象方法。</p><p>测试类 Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Dog();<span class="comment">// 向上转型</span></span><br><span class="line">animal.setName(<span class="string">"huahua"</span>);</span><br><span class="line">animal.run();</span><br><span class="line">animal.sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2020/02/24/javabase38-abstract/t1.png" alt="重写的run方法"></p><p>通过上面的例子可以看到：abstract 不仅可以修饰类，还可以修饰成员方法，被修饰的方法称为抽象方法，且当抽象类被继承的时候抽象方法必须被重写。</p><p>那普通类里可以有抽象方法吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> </span>&#123;<span class="comment">//The type Sheep must be an abstract class to define abstract methods</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;<span class="comment">//The abstract method eat in type Sheep can only be defined by an abstract class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到分别再类名和方法名出给出了错误提示，说明普通类里不能创建抽象方法，换句话说：<strong>若一个类里有抽象方法，那这个类肯定是抽象类</strong>。</p><p>当 Dog 类也是抽象类时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 Dog 类虽然继承了 Animal 类，但是不需要重写父类中的抽象方法。所以任何类继承抽象类必须重写抽象方法的结论是不准确的，应该是：<strong>除了抽象类外的任何类继承抽象类必须重写父类抽象方法。</strong></p><h3 id="来做个总结："><a href="#来做个总结：" class="headerlink" title="来做个总结："></a>来做个总结：</h3><ol><li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java继承多态" scheme="https://Gitsxm.github.io/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十七）—— instanceof 关键字详解</title>
    <link href="https://gitsxm.github.io/2020/02/23/javabase37-instanceof/"/>
    <id>https://gitsxm.github.io/2020/02/23/javabase37-instanceof/</id>
    <published>2020-02-23T15:21:41.000Z</published>
    <updated>2020-02-26T13:16:59.409Z</updated>
    
    <content type="html"><![CDATA[<p><em>严格来说 instanceof 是 Java 中的一个双目运算符，由于它是由字母组成的，所以也是 Java 的保留关键字。在 Java 中可以使用 instanceof 关键字判断一个对象是否为一个类（或接口、抽象类、父类）的实例。</em></p><a id="more"></a><hr><p>instanceof 的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj <span class="keyword">instanceof</span> Class;</span><br></pre></td></tr></table></figure><p>obj 代表某个类型的对象，Class 代表某个类或接口，当 obj 是 class 类（或接口）的实例或者子类实例时，结果 result 返回 true，否则返回 false。</p><p>instanceof 三种用法：</p><h3 id="1-判断-obj-是否为某个类对象；"><a href="#1-判断-obj-是否为某个类对象；" class="headerlink" title="1. 判断 obj 是否为某个类对象；"></a>1. 判断 obj 是否为某个类对象；</h3><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.println(cat <span class="keyword">instanceof</span> Cat);<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-判断-obj-是否为接口实现类；"><a href="#2-判断-obj-是否为接口实现类；" class="headerlink" title="2. 判断 obj 是否为接口实现类；"></a>2. 判断 obj 是否为接口实现类；</h3><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">List arrlist1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList arrlist2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(arrlist1 <span class="keyword">instanceof</span> List); <span class="comment">//true</span></span><br><span class="line">System.out.println(arrlist2 <span class="keyword">instanceof</span> List); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List 是 java.util 内的一个接口，ArrayList 是 List 的实现类。（到集合时详细讲讲）</p><h3 id="3-判断-obj-是否是某类的子类或者间接子类；"><a href="#3-判断-obj-是否是某类的子类或者间接子类；" class="headerlink" title="3. 判断 obj 是否是某类的子类或者间接子类；"></a>3. 判断 obj 是否是某类的子类或者间接子类；</h3><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Doctor 类 之前用过的直接拿来用了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String ks;<span class="comment">//科室</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写了父类 work 医生的工作是救人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"healing petients"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getKs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKs</span><span class="params">(String ks)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ks = ks;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Doctor doc = <span class="keyword">new</span> Doctor();</span><br><span class="line">System.out.println(doc <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">System.out.println(doc <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">System.out.println(person <span class="keyword">instanceof</span> Doctor);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Doctor 类继承了 Person 类，Person 是 Object 的子类，Doctor 是 Object 的间接子类。<br>（以上结果都验证过了放心食用。）</p><p>要注意的是 obj 必须为引用类型或者 null，不能是基本类型。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//Incompatible conditional operand types int and Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本类型编译不能通过。</p><p>当 obj = null 时和任何类比都是 false ，因为 null 不代表任何类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(str <span class="keyword">instanceof</span> Object);<span class="comment">//false</span></span><br><span class="line">System.out.println(str <span class="keyword">instanceof</span> String);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="instanceof-三目运算符"><a href="#instanceof-三目运算符" class="headerlink" title="instanceof 三目运算符"></a>instanceof 三目运算符</h3><p>假设有 Dog 类和 Cat 继承了 Animal 类，现在需要判断 obj 对象是否可转型为 Dog 对象，是返回 Dog 对象，否则返回字符串对象，提示不能转型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]  args)</span></span>&#123;</span><br><span class="line">  Animal c = <span class="keyword">new</span> Cat();<span class="comment">//复习向上转型</span></span><br><span class="line">  Animal d = <span class="keyword">new</span> Dog();</span><br><span class="line">  System.out.println(transform(c)); <span class="comment">//不是Dog类型</span></span><br><span class="line">  System.out.println(transform(d)); <span class="comment">//pers.mgg.demo.dt.Dog@15db9742</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">transform</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">  <span class="comment">// true 则向下转型</span></span><br><span class="line">  <span class="keyword">return</span> a <span class="keyword">instanceof</span> Dog ? (Dog)a : <span class="keyword">new</span> String(<span class="string">"不是Dog类型"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;&#125; </span><br></pre></td></tr></table></figure><p>（代码已经验证结果，放心食用）</p></blockquote><p>在类型转换时，食用 instanceof 来做逻辑判断是非常必要的。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;严格来说 instanceof 是 Java 中的一个双目运算符，由于它是由字母组成的，所以也是 Java 的保留关键字。在 Java 中可以使用 instanceof 关键字判断一个对象是否为一个类（或接口、抽象类、父类）的实例。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="https://Gitsxm.github.io/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://Gitsxm.github.io/tags/Java/"/>
    
      <category term="Java继承多态" scheme="https://Gitsxm.github.io/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
</feed>
