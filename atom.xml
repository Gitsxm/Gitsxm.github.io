<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MggBlog</title>
  
  <subtitle>MggBlog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mggblog.ink/"/>
  <updated>2020-02-23T06:44:43.663Z</updated>
  <id>http://www.mggblog.ink/</id>
  
  <author>
    <name>Mgg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十五）—— super 关键字</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase35-super/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase35-super/</id>
    <published>2020-02-23T03:31:22.000Z</published>
    <updated>2020-02-23T06:44:43.663Z</updated>
    
    <content type="html"><![CDATA[<p><em>由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。</em></p><a id="more"></a><hr><p>super 关键字在讲 this 关键字的时候顺带说了一下，this 代表的是当前基类， super 代表父类，它的功能是：</p><ol><li>在子类的构造方法中显式的调用父类构造方法</li><li>访问父类的成员方法和变量。</li></ol><h2 id="super-调用父类构造方法"><a href="#super-调用父类构造方法" class="headerlink" title="super 调用父类构造方法"></a>super 调用父类构造方法</h2><p>新建 Animal 动物类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">System.out.println(<span class="string">"Animal 无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">System.out.println(<span class="string">"Animal 有参构造  Animal name = "</span>+name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 eclipse 快速生成的两个构造方法时，可以看到方法内部自带 super() ，当前的 super() 是指向父类 Object 的无参构造方法。</p><p>创建 Cat 类继承 Animal 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String type, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test 测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Cat cat1 = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat cat2 = <span class="keyword">new</span> Cat(<span class="string">"狸花猫"</span>, <span class="string">"花花"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase35-super/t1.png" alt="super指向父类构造"></p><p>通过 Cat 两个构造方法，我们看到通过 Super 可以分别调用父类 Animal 的有参和无参构造方法，而且和 this() 一样，要放在方法代码第一行。</p><h2 id="super-访问父类成员"><a href="#super-访问父类成员" class="headerlink" title="super 访问父类成员"></a>super 访问父类成员</h2><p>访问父类成员与 this 访问基类成员的方法一样，就是 super.成员</p><p>我们把上面的 Animal 和 Cat 类改改：</p><p>Animal 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物跳 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.name+<span class="string">" jump"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat 类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写父类 jump 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//其实 this 可以不写</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>.type+<span class="string">" "</span> + <span class="keyword">this</span>.name + <span class="string">" jump"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String type, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line"><span class="comment">// 为父类 属性 name 赋值</span></span><br><span class="line"><span class="keyword">super</span>.name = name;</span><br><span class="line"><span class="comment">// 调用父类 jump 方法</span></span><br><span class="line"><span class="keyword">super</span>.jump();</span><br><span class="line"><span class="comment">// 基类 jump 方法</span></span><br><span class="line"><span class="keyword">this</span>.jump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat 类重写了父类 jump 方法，我们在 Cat 类 有参构造中演示用 super 和 this 分别调用父类和基类属性和方法。</p><p>测试类 Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Cat cat2 = <span class="keyword">new</span> Cat(<span class="string">"狸花猫"</span>, <span class="string">"花花"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase35-super/t2.png" alt="调用成员属性和方法"></p><p>如果是基类中独有的属性和方法，可以省略 this 。</p><blockquote><p>super() 与 this() 都不能再 static 环境中使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十四）——继承</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase34-jc/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase34-jc/</id>
    <published>2020-02-23T02:28:42.000Z</published>
    <updated>2020-02-23T06:40:56.190Z</updated>
    
    <content type="html"><![CDATA[<p><em>继承是面向对象的三大特征之一。继承和现实生活中的“继承”的相似之处是保留一些父辈的特性，从而减少代码冗余，提高程序运行效率。</em></p><a id="more"></a><hr><p>继承需要使用 extends 关键字，用法：基类 extends 父类，extends 直译为“扩展”，其实用扩展来描述基类与父类的关系更加准确。</p><p>基类继承父类后，父类的属性和方法的权限修饰不会变，而且不能继承父类的构造方法。</p><p>举个继承的例子，创建医生 Doctor 类和病人 Patient 类继承 Person 类：</p><p>Person 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">private</span> String gender;<span class="comment">//性别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Doctor 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String ks;<span class="comment">//科室</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写了父类 work 医生的工作是救人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"healing petients"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getKs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKs</span><span class="params">(String ks)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ks = ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Patient 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Patient</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String illness;<span class="comment">//病情</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 看医生</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: seeDoctor   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeDoctor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"see a doctor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIllness</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> illness;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIllness</span><span class="params">(String illness)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.illness = illness;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Patient p = <span class="keyword">new</span> Patient();</span><br><span class="line">p.setAge(<span class="number">20</span>);</span><br><span class="line">p.setGender(<span class="string">"男"</span>);</span><br><span class="line">p.setName(<span class="string">"Tom"</span>);</span><br><span class="line">p.setIllness(<span class="string">"头痛"</span>);</span><br><span class="line">Doctor d = <span class="keyword">new</span> Doctor();</span><br><span class="line">d.setAge(<span class="number">30</span>);</span><br><span class="line">d.setGender(<span class="string">"女"</span>);</span><br><span class="line">d.setName(<span class="string">"Jane"</span>);</span><br><span class="line">d.setKs(<span class="string">"神经内科"</span>);</span><br><span class="line">System.out.print(<span class="string">"病人"</span>+p.getName()+p.getAge()+<span class="string">"岁 "</span>+<span class="string">"因"</span>+p.getIllness()+<span class="string">"  "</span>);</span><br><span class="line">p.seeDoctor();</span><br><span class="line">System.out.print(d.getKs()+<span class="string">"医生"</span>+d.getName()+<span class="string">"  "</span>);</span><br><span class="line">d.work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase34-jc/jc.png" alt="继承了Person类中的属性和方法"></p><blockquote><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>Java 不支持多继承，只允许一个类直接继承另一个类，即子类只能有一个直接父类，extends 关键字后面只能有一个类名，但是一个类可以被多个类继承。<br>还有要注意：</p><ol><li>Object 是所有新定义类的父类，虽然没有 extends 字段。</li><li>父类中的 private 成员在子类中是不可见的，因此在子类中不能直接使用它们。如上面例子中的是通过继承了父类的 getter 和 setter 方法来给父类中的属性赋值的。</li><li>我们强调单继承的原因是因为 C++ 支持多继承，如果是 C++ 程序员学java很容易不注意。</li></ol></blockquote><p>最后总结继承的优缺点：<br><strong>优点：</strong></p><ol><li>实现代码共享，减少创建类的工作量，使子类可以拥有父类的方法和属性。</li><li>提高代码维护性和可重用性。</li><li>提高代码的可扩展性，更好的实现父类的方法。</li></ol><p><strong>缺点：</strong></p><ol><li>继承是侵入性的。只要继承，就必须拥有父类的属性和方法。</li><li>降低代码灵活性。子类拥有父类的属性和方法后多了些约束。</li><li>增强代码耦合性（开发项目的原则为高内聚低耦合）。当父类的常量、变量和方法被修改时，需要考虑子类的修改，有可能会导致大段的代码需要重构。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;继承是面向对象的三大特征之一。继承和现实生活中的“继承”的相似之处是保留一些父辈的特性，从而减少代码冗余，提高程序运行效率。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十三）——类的封装</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase33-fz/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase33-fz/</id>
    <published>2020-02-23T01:27:36.000Z</published>
    <updated>2020-02-23T06:40:05.360Z</updated>
    
    <content type="html"><![CDATA[<p><em>封装在讲对象和类的时候已经多多少少有说过，接下来的内容会把封装，继承，多态单独说说，有前面的预习，现在看起来就简单多了。</em></p><a id="more"></a><hr><p>封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，只能通过该类提供的方法来实现对隐藏信息的操作和访问。如计算机，内部部件非常复杂，cpu、主板、显卡、电源、内存等等，在外部套一个机箱，使用外部接口供电流流通，和人机交互，保护了内部部件的安全。</p><p>封装的特点：</p><ul><li>只能通过规定的方法访问数据。</li><li>隐藏类的实例细节，方便修改和实现。</li></ul><p>类封装一般包含这几步：</p><ol><li>使用 private 修饰类的内部属性；</li><li>设置公有（public）的 setter 和 getter 方法，可以修改 setter 方法对赋值进行定制化修改；</li><li>根据需要确定类方法为私有（private）还是公有（public）；</li><li>根据需要创建有参与无参构造以及 toString 方法。</li></ol><p>举个例子，创建一个 Dog 封装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Dog  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 狗实体类  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MGG  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> Feb 23, 2020</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 跳高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"dog jump !"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的姓名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的姓名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的种类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的种类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toString 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dog [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", type="</span> + type + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age, String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 private 修饰 Dog 类属性意味着外部只能通过公有的 setter 和 getter 方法访问和修改属性，jump 方法可以在任何外部类中访问。当然还可以加入 public 修饰的静态常量和静态方法。</p><p>写一个测试类，新建一个 dog 对象，并赋予属性值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Dog dog1 = <span class="keyword">new</span> Dog();</span><br><span class="line">dog1.setName(<span class="string">"臭蛋"</span>);</span><br><span class="line">dog1.setAge(<span class="number">2</span>);</span><br><span class="line">dog1.setType(<span class="string">"金毛犬"</span>);</span><br><span class="line">Dog dog2 = <span class="keyword">new</span> Dog(<span class="string">"拖孩儿"</span>, <span class="number">3</span>, <span class="string">"哈士奇"</span>);</span><br><span class="line">System.out.println(<span class="string">"dog1的名字："</span> + dog1.getName() + <span class="string">"  年龄："</span> + dog1.getAge());</span><br><span class="line">System.out.println(<span class="string">"dog2的名字："</span> + dog2.getName() + <span class="string">"  年龄："</span> + dog2.getAge());</span><br><span class="line">dog1.jump();</span><br><span class="line">dog2.jump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase33-fz/g.png" alt="封装类的使用"></p><p>可以在 setter 方法中设置限制，比如 age &gt; 3 否则提示超出年龄，不再举例了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;封装在讲对象和类的时候已经多多少少有说过，接下来的内容会把封装，继承，多态单独说说，有前面的预习，现在看起来就简单多了。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十二）——递归算法</title>
    <link href="http://www.mggblog.ink/2020/02/22/javabase32-dg/"/>
    <id>http://www.mggblog.ink/2020/02/22/javabase32-dg/</id>
    <published>2020-02-22T12:02:13.000Z</published>
    <updated>2020-02-22T13:57:23.665Z</updated>
    
    <content type="html"><![CDATA[<p><em>递归算法简单说就是方法调用自己，对递归我也就懂这么一点，学习递归是一个很长的过程，从“学会”、“学好”到“用好”得有很长时间的积累，本篇内容简单说说什么是递归，和什么时候用递归，再深了我也不懂了，以后再补充吧。</em></p><a id="more"></a><hr><h2 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h2><p>我们可以把递归比喻成查词典，查到一个词解释里又有个词不懂，接着去查这个词，然后解释里又有个词不懂，就这样往复往后查，直到弄懂了所涉及到的所有词的意思，问题得以解决。</p><p>在讲<a href="http://www.mggblog.ink/2020/02/17/javabase21-kspx/">快速排序</a>时就已经用到递归算法了。</p><p>阶乘是演示递归算法的一个经典例子，顺带把普通循环的方法也弄上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DgTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归结果和用时</span></span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">int</span> i = jc(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">"10!="</span> + i + <span class="string">" 用时:"</span> + (endTime - startTime) + <span class="string">"ns"</span>);</span><br><span class="line">        <span class="comment">// 循环结果和用时</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">int</span> j = jc_loop(<span class="number">10</span>);</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">"loop_10!="</span> + j + <span class="string">" 用时:"</span> + (endTime - startTime) + <span class="string">"ns"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 阶乘递归示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">result = i * jc(i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jc_loop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 阶乘循环示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jc_loop</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">result *= i;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/22/javabase32-dg/jc.png" alt="10的阶乘"></p><p>从结果中可以看出，递归算法不仅可以用普通循环算法代替，而且普通循环算法在相同结果的情况下所用时间更少。</p><h2 id="递归就是不停地入栈出栈"><a href="#递归就是不停地入栈出栈" class="headerlink" title="递归就是不停地入栈出栈"></a>递归就是不停地入栈出栈</h2><p>当一个方法调用它自身的时候，堆栈就会给新的局部变量和自变量分配内存，方法代码就带着这些新的变量从头执行。递归调用并不产生方法新的拷贝。只有参数是新的。每当递归调用返回时，旧的局部变量和自变量就从堆栈中清除（就这么不停地入栈出栈），运行从方法中的调用点重新开始。递归方法可以说是像“望远镜”一样，可以自由伸缩。</p><p>许多子程序的递归版本执行时会比它们的迭代版本要慢一点，因为它们增加了额外的方法调用的消耗。对一个方法太多的递归调用会引起堆栈崩溃。因为自变量和局部变量的存储都在堆栈中，每次调用都创建这些变量新的拷贝，堆栈有可能被耗尽。如果发生这种情况，Java 的运行时系统就会产生异常。但是，除非递归子程序疯狂运行，否则你大概不会担心这种情况。</p><h2 id="使用递归的好处"><a href="#使用递归的好处" class="headerlink" title="使用递归的好处"></a>使用递归的好处</h2><p>递归的主要优点在于：某些类型的算法采用递归比采用迭代算法要更加清晰和简单。例如快速排序算法按照迭代方法是很难实现的。还有其他一些问题，特别是人工智能问题，就依赖于递归提供解决方案。最后，有些人认为递归要比迭代简单。</p><blockquote><p>当编写递归方法时，你必须使用 if 条件语句在递归调用不执行时来强制方法返回。如果你不这么做，一旦你调用方法，它将永远不会返回。这类错误在使用递归时是很常见的。尽量多地使用 println() 语句，使你可以了解程序的进程。如果发现错误，立即中止程序运行。</p></blockquote><p>递归的学习是循序渐进的，真正完全掌握怕是要很长时间，总的来说，递归与普通循环的不同就是递归把本属于程序员思考的部分内容推给了机器。</p><p>当遇到使用普通循环不好实现的算法时，可以试着使用递归算法。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>我这个程度的写递归知识是真的不太行，在工作中很少用到，唯一用递归的场景就是遍历系统菜单，这个需求凡是数据管理系统大概都得用到，还是很重要的。对递归感兴趣的话多去看看csdn上的博客，这篇博客我以后会再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;递归算法简单说就是方法调用自己，对递归我也就懂这么一点，学习递归是一个很长的过程，从“学会”、“学好”到“用好”得有很长时间的积累，本篇内容简单说说什么是递归，和什么时候用递归，再深了我也不懂了，以后再补充吧。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十一）——析构方法</title>
    <link href="http://www.mggblog.ink/2020/02/22/javabase31-xgff/"/>
    <id>http://www.mggblog.ink/2020/02/22/javabase31-xgff/</id>
    <published>2020-02-22T01:24:13.000Z</published>
    <updated>2020-02-22T14:00:48.690Z</updated>
    
    <content type="html"><![CDATA[<p><em>析构函数的作用和构造函数相反，析构函数被用来在对象不再被使用时销毁对象，释放内存空间（例如用 new 创造出来的空间），而且系统自动执行。</em></p><a id="more"></a><hr><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>Object 类中提供了一个 finalize() 方法，因为 Object 是所有类的父类，所有类都可以重写这个方法。</p><p>finalize 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//具体操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jdk 文档中给出的解释：</p><blockquote><p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 finalize 方法，以配置系统资源或执行其他清除。 </p><p>finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象 或类的终结操作执行了某个操作。finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。 </p><p>Object 类的 finalize 方法执行非特殊性操作；它仅执行一些常规返回。Object 的子类可以重写此定义。 </p><p>Java 编程语言不保证哪个线程将调用某个给定对象的 finalize 方法。但可以保证在调用 finalize 时，调用 finalize 的线程将不会持有任何用户可见的同步锁定。如果 finalize 方法抛出未捕获的异常，那么该异常将被忽略，并且该对象的终结操作将终止。 </p><p>在启用某个对象的 finalize 方法后，将不会执行进一步操作，直到 Java 虚拟机再次确定尚未终止的任何线程无法再通过任何方法访问此对象，其中包括由准备终止的其他对象或类执行的可能操作，在执行该操作时，对象可能被丢弃。 </p><p>对于任何给定对象，Java 虚拟机最多只调用一次 finalize 方法。 </p><p>finalize 方法抛出的任何异常都会导致此对象的终结操作停止，但可以通过其他方法忽略它。 </p></blockquote><p>对象的 finalize 方法具有以下特点：</p><ul><li>垃圾回收器是否会执行该方法以及何时执行该方法，都是不确定的。</li><li>finalize() 方法有可能使用对象复活，使对象恢复到可触及状态。</li><li>垃圾回收器在执行 finalize() 方法时，如果出现异常，垃圾回收器不会报告异常，程序继续正常运行。</li></ul><p>举个例子：</p><p>计数类 Count ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建对象时计数加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟销毁对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 销毁对象是变量计数减一</span></span><br><span class="line">count--;</span><br><span class="line">System.out.println(<span class="string">"对象销毁"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数查询方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getCount</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类 Test ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">Count c = <span class="keyword">new</span> Count();</span><br><span class="line">System.out.println(<span class="string">"创建对象c当前count："</span> + c.getCount());</span><br><span class="line">Count c2 = <span class="keyword">new</span> Count();</span><br><span class="line">System.out.println(<span class="string">"创建对象c2当前count："</span> + c2.getCount());</span><br><span class="line">c.finalize();</span><br><span class="line">System.out.println(<span class="string">"销毁对象c当前count："</span> + c2.getCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/22/javabase31-xgff/c.png" alt="模拟对象销毁"></p><p>finalize 方法具有不确定性，如果需要手动对象回收，使用  System.gc() 或者 Runtime.gc()  更好点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;析构函数的作用和构造函数相反，析构函数被用来在对象不再被使用时销毁对象，释放内存空间（例如用 new 创造出来的空间），而且系统自动执行。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十）——构造方法</title>
    <link href="http://www.mggblog.ink/2020/02/21/javabase30-gzff/"/>
    <id>http://www.mggblog.ink/2020/02/21/javabase30-gzff/</id>
    <published>2020-02-21T07:59:32.000Z</published>
    <updated>2020-02-21T14:17:54.413Z</updated>
    
    <content type="html"><![CDATA[<p><em>构造方法是类的特殊方法，创建类时会默认创建一个没有参数，没有具体方法体的构造方法，称为无参构造，还可以自己写有参数的构造完成类初始化，下面详细说说构造方法的用法。</em></p><a id="more"></a><hr><p>方法名与类名一模一样的方法称为构造方法。</p><p>构造方法有以下特点：</p><ul><li>方法名必须与类名相同</li><li>可以有 0 个、1 个或多个参数</li><li>没有任何返回值，包括 void</li><li>默认返回类型就是对象类型本身</li><li>只能与 new 运算符结合使用</li></ul><p>值得注意的是，如果为构造方法定义了返回值类型或使用 void 声明构造方法没有返回值，编译时不会出错，但 Java 会把这个所谓的构造方法当成普通方法来处理。</p><p>构造方法是在创建对象时使用的，其他任何修饰符对他来说没有意义。</p><p>构造方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String gender;</span><br><span class="line"><span class="keyword">public</span> String addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"mgg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> addr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String gender, String addr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line"><span class="keyword">this</span>.addr = addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//无参构造</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(person.name);</span><br><span class="line">System.out.println(<span class="string">"下面为有参构造："</span>);</span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Person person2 = <span class="keyword">new</span> Person(<span class="string">"kangkang"</span>,<span class="string">"男"</span>,<span class="string">"幻想乡木吉镇比利街001号"</span>);</span><br><span class="line">System.out.println(person2.name);</span><br><span class="line">System.out.println(person2.gender);</span><br><span class="line">System.out.println(person2.addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/21/javabase30-gzff/c.png" alt="两种构造用法"></p><p>提示：无参数的构造方法也被称为 Nullary 构造方法。只有编译程序自动加入的构造方法，才称为默认构造函数。如果自行编写无参数、没有内容的构造函数，就不称为默认构造函数了（只是 Nullary 构造函数）。虽然只是名词定义，不过认证考试时要区别一下两者的不同。</p><p>如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。</p><p>如果类中写了有参数的构造方法，但是还想使用 Person p = new Person() 创建对象，必须手动在 Person 中添加无参构造。</p><p>有参数的构造方法是对无参构造的重载，前面已经多次提到过了，而且根据需要，可以创建任意参数的构造方法。</p><blockquote><p>重载（overload）的含义：方法名相同参数不同，无论是参数的类别，还是参数的个数。<br>区别于重写（overwrite）：在类继承时可以重写父类方法，方法名和参数完全一致，方法体不同。另一个是在实现了类接口必须重写接口中的抽象方法。</p></blockquote><p>举一个重写父类方法的例子：</p><p>父类 Person 类，新添加了 work 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String gender;</span><br><span class="line"><span class="keyword">public</span> String addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"mgg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> addr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String gender, String addr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line"><span class="keyword">this</span>.addr = addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: work   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 普通人工作 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Person work"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类 Doctor 类 重写了父类 work 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写了父类 work 医生的工作是救人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"healing petients"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建父类对象</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"kangkang"</span>, <span class="string">"男"</span>, <span class="string">"幻想乡木吉镇比利街001号"</span>);</span><br><span class="line">p.work();</span><br><span class="line">Doctor doc = <span class="keyword">new</span> Doctor();</span><br><span class="line">doc.work();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/21/javabase30-gzff/cx.png" alt="重写父类 work 方法"></p><p>重写与重载的区别要记牢，虽然没人去抓概念，但是如果在什么场合说混了那就太难堪了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;构造方法是类的特殊方法，创建类时会默认创建一个没有参数，没有具体方法体的构造方法，称为无参构造，还可以自己写有参数的构造完成类初始化，下面详细说说构造方法的用法。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十九）—— main() 方法</title>
    <link href="http://www.mggblog.ink/2020/02/21/javabase29-main/"/>
    <id>http://www.mggblog.ink/2020/02/21/javabase29-main/</id>
    <published>2020-02-21T01:45:43.000Z</published>
    <updated>2020-02-21T02:37:26.484Z</updated>
    
    <content type="html"><![CDATA[<p><em>Java中，mian 方法是所有程序的入口，与其他方法有很大的不同，从开始到现在 main 方法已经用过很多次了，但是从来没有详细说明过 main 方法的特点，本篇内容来补充这个知识点。</em></p><a id="more"></a><hr><h2 id="Java-main-方法"><a href="#Java-main-方法" class="headerlink" title="Java main() 方法"></a>Java main() 方法</h2><p>main 方法有只有一种写法，格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 main 方法代码发现：</p><ul><li>main 方法是公有的；</li><li>main 方法是静态方法；（在当前类的 main 里调用其他方法，那这个方法也必须是 static 修饰）</li><li>main 方法没有返回值；</li><li>main 方法的参数是字符串数组。（用来接收执行 Java 程序的命令行参数。命令行参数作为字符串，按照顺序依次对应字符串数组中的元素。）</li></ul><p>一定要注意，main 方法的定义中只有参数名 args 是可以改变的，其他都是固定格式，不能添不能少。但是我们约定参数名和java规范中的名字一样，所以 args 也是不能改的。</p><p>注意因为 static 修饰，main 方法里调用的所有方法必是静态方法，否者无法调用，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">dogJump();</span><br><span class="line">catJump();<span class="comment">//Cannot make a static reference to the non-static method catJump() from the type Test</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dogJump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Dog jump!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catJump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Cat jump!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个类，下面通过 Windows 命令行工具，查看 main 方法里参数的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = args.length; <span class="comment">// 获取参数数量</span></span><br><span class="line">System.out.println(<span class="string">"一共有 "</span> + n + <span class="string">" 个参数"</span>);</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 判断参数个数是否大于0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">System.out.println(args[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行过程：<br><img src="/2020/02/21/javabase29-main/m.png" alt="通过控制台输入参数"></p><p>可以发现 main 方法可以通过控制台传递字符串参数。</p><p>一个程序只能有一个 main 方法，通常做测试用，比如写了几个类，需要一个入口来测试类中方法是否正确。我们称为单元测试，单元测试在开发中非常重要。</p><p>后面会遇到 Junit ，一个专门用来做单元测试的工具，到时候再详细介绍用法。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Java中，mian 方法是所有程序的入口，与其他方法有很大的不同，从开始到现在 main 方法已经用过很多次了，但是从来没有详细说明过 main 方法的特点，本篇内容来补充这个知识点。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十八）——类中常见关键字（访问权限、static、final）</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase28-lgjz/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase28-lgjz/</id>
    <published>2020-02-20T11:49:51.000Z</published>
    <updated>2020-02-21T02:27:38.571Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇把类中常用的关键字单独拿出来说说，<strong>内容包含：访问权限控制关键字 private、friendly、protected、public，静态关键字 static，完结器 final 关键字</strong></em></p><a id="more"></a><hr><h2 id="一、访问权限控制修饰符（private、friendly、protected、public）"><a href="#一、访问权限控制修饰符（private、friendly、protected、public）" class="headerlink" title="一、访问权限控制修饰符（private、friendly、protected、public）"></a>一、访问权限控制修饰符（private、friendly、protected、public）</h2><p>前面提到，类是对对象的封装，既然是封装，那出发点肯定是不想让箱子外部随机接触箱内，所以设置访问权限，想让你看的给你看，不想的外部怎么都访看不见。</p><ol><li><p>类修饰符：public，default（不用写出来）<br>这四个关键字并不是随处都能用，其中 public 只能用在类声明中，在类声明中，除了使用 public 还可以什么都不写，不写的话权限默认为 default ，两者的不同为：<strong>public 声明的类可以被其他包调用，default（不加修饰符） 权限的类只能在包内使用</strong>。</p></li><li><p>成员变量与成员方法修饰符（private、friendly、protected、public）</p></li></ol><p>四种修饰符权限差异：</p><table><thead><tr><th>访问范围</th><th>private</th><th>friendly(默认)</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类</td><td>可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>同一包中的其他类</td><td>不可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的子类</td><td>不可访问</td><td>不可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的非子类</td><td>不可访问</td><td>不可访问</td><td>不可访问</td><td>可访问</td></tr></tbody></table><p>简短叙述一下（权限大小也按1.2.3.4.排，越往下越大）：</p><ol><li><p>private<br>用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用。</p></li><li><p>friendly<br>如果一个类没有访问控制符，说明它具有默认的访问控制特性。这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，即使其他包中有该类的子类。这种访问特性又称为包访问性（package private）。</p></li><li><p>protected<br>用保护访问控制符 protected 修饰的类成员可以被三种类所访问：该类自身、与它在同一个包中的其他类以及在其他包中的该类的子类。使用 protected 修饰符的主要作用，是允许其他包中它的子类来访问父类的特定属性和方法，否则可以使用默认访问控制符。</p></li><li><p>public<br>当一个类被声明为 public 时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用 import 语句引入 public 类，就可以访问和引用这个类。</p></li></ol><blockquote><p>每个程序的主类必须是 public 。</p></blockquote><p>在讲类的时候里面有提到 private 与 public的用法，其他两个用法实在很少用到，做项目不可能吧权限细分的那么清楚，找很多麻烦。</p><h2 id="二、static-关键字（加一个静态导入的知识）"><a href="#二、static-关键字（加一个静态导入的知识）" class="headerlink" title="二、static 关键字（加一个静态导入的知识）"></a>二、static 关键字（加一个静态导入的知识）</h2><p>类中的属性和方法概括为类成员，带有 static 关键字修饰的称为：静态成员，静态成员为类所有，不依赖与任何对象，只要类被加载，就可以被访问。</p><p>前面有用到了 static 修饰的属性和方法，调用语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.方法/属性;</span><br></pre></td></tr></table></figure><p>再举个例子加深印象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">"kangkang"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: run   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 男孩跑步 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">" is running！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 男孩跳 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">" is jumpping！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//创建两个 boy 对象</span></span><br><span class="line">Boy boy1 = <span class="keyword">new</span> Boy();</span><br><span class="line">Boy boy2 = <span class="keyword">new</span> Boy();</span><br><span class="line">System.out.println(<span class="string">"静态变量 name 值："</span>+Boy.name);</span><br><span class="line">boy1.jump();</span><br><span class="line">boy2.jump();</span><br><span class="line"><span class="comment">// 在这里改变静态变量值</span></span><br><span class="line">Boy.name = <span class="string">"jhon"</span>;</span><br><span class="line">System.out.println(<span class="string">"------静态变量值改变--------"</span>);</span><br><span class="line">System.out.println(<span class="string">"静态变量 name 值："</span>+Boy.name);</span><br><span class="line">boy1.jump();</span><br><span class="line">boy2.jump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/20/javabase28-lgjz/s.png" alt="静态成员不依赖对象"></p><p>我们发现，静态变量值改变时，使用它的每一个对象也会作出相应改变，如果是普通成员变量的话，不同对象的值是没有干扰的。</p><p>静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。</p><p>如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。</p><blockquote><p>除了静态方法静态变量，类中还可以有静态代码块，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticCode</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Boy.i); <span class="comment">//结果为 11</span></span><br></pre></td></tr></table></figure><p>在直接使用时，i 已经自加过了，提高了代码效率？我实在不知道有什么用。</p></blockquote><blockquote><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>在 JDK 1.5 之后增加了一种静态导入的语法，用于导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法。如果一个类中的方法全部是使用 static 声明的静态方法，则在导入时就可以直接使用 import static 的方式导入。</p><p>静态导入使用 import static 语句，静态导入也有两种语法，分别用于导入指定类的单个静态成员变量、方法和全部静态成员变量、方法，其中导入指定类的单个静态成员变量、方法的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.ClassName.fieldName|methodName;</span><br></pre></td></tr></table></figure><p>上面语法导入 package.ClassName 类中名为 fieldName 的静态成员变量或者名为 methodName 的静态方法。例如，可以使用import static java.lang.System.out;语句来导入 java.lang.System 类的 out 静态成员变量。</p><p>导入指定类的全部静态成员变量、方法的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.ClassName.*;</span><br></pre></td></tr></table></figure><p>上面语法中的星号只能代表静态成员变量或方法名。</p><p><strong>说那么多，其实只需与普通 import 对比下就行了，一句话： import 和 import static 的作用，使用 import 可以省略写包名，而使用 import static 可以省略类名。</strong><br>而且在开发过程中，没什么机会让你手动导入。除了遇到大佬自己写的工具类。</p></blockquote><h2 id="三、final-关键字"><a href="#三、final-关键字" class="headerlink" title="三、final 关键字"></a>三、final 关键字</h2><p>final 的意义就是无法再改变，声明为多少就是多少。</p><p>final 有如下限制作用：</p><ul><li><p>如果 final 用在了变量前面，变量就变为常量，无法在改变，</p></li><li><p>如果 final 加在方法前面，表明方法无法被重写，重写的意思就是方法名和参数一样，方法体不一样。</p></li><li><p>如果 final 加在了类前，表明类无法被继承。</p></li></ul><p>但是在使用时应该注意一下几点：</p><ol><li>在变量中，如果使用 final ，成为常量，可以不赋值，但是在使用前必须先赋值，赋值之后就无法改变了。</li><li>对基本类型变量来说是其值不可变，而对对象引用类型变量来说其引用不可再变。</li><li>在开发中我们约定，如果使用 final 定义常量，常量的名字使用全大写字符，如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP = <span class="string">"192.168.1.1"</span>;</span><br></pre></td></tr></table></figure></li><li>如果 final 修饰了类，就不需要在类方法前加 final 操作没有意义。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本篇把类中常用的关键字单独拿出来说说，&lt;strong&gt;内容包含：访问权限控制关键字 private、friendly、protected、public，静态关键字 static，完结器 final 关键字&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十七）——注释</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase27-doc/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase27-doc/</id>
    <published>2020-02-20T07:24:38.000Z</published>
    <updated>2020-02-21T01:14:44.977Z</updated>
    
    <content type="html"><![CDATA[<p><em>学过了类的各种东西，现在说一个很简单但是很重要的东西，就是注释——javadoc，简单是因为只需要按几下按键就出来了，重要是因为，有注释会给予看程序的其他人极大的方便，其他人不用去猜你写这个类做啥用，这个方法干嘛用。大大提高了程序的可读性，维护起来容易多了。</em></p><a id="more"></a><hr><p>虽然从事开发工作时间不长，但是从我敲第一行代码开始就养成写注释的习惯了，几乎每个方法和类都会写注释，毕竟写个注释用不了几秒。也有遇到大佬不写注释的，类也不写，方法也不写，用到时都要去猜去试，浪费不少时间，大概这就是大佬把，哈哈哈。下面演示一下在 Eclipse 下如何快速生成注释。</p><p>生成注释前必须要先做配置，默认的注释过于简单，配置流程如下：<br><img src="/2020/02/20/javabase27-doc/s1.png" alt="步骤1"><br><img src="/2020/02/20/javabase27-doc/s2.png" alt="步骤2"><br><img src="/2020/02/20/javabase27-doc/s3.png" alt="步骤3"><br><img src="/2020/02/20/javabase27-doc/s4.png" alt="步骤4"><br><img src="/2020/02/20/javabase27-doc/s5.png" alt="步骤5"></p><p>我把我的配置写出来，我就配置了三个，你也可以去百度搜“eclipse 注释模板”挑选自己喜欢的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Files 文件</span></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * All rights Reserved, Designed By www.mggblog.ink</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>:  $&#123;file_name&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> $&#123;package_name&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:Description  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: mgg     </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:   $&#123;date&#125; $&#123;time&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Types   类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: $&#123;type_name&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;todo&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $&#123;user&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> $&#123;date&#125;  </span></span><br><span class="line"><span class="comment"> * $&#123;tags&#125;  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods  方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: $&#123;enclosing_method&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;todo&#125; </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: $&#123;user&#125;  </span></span><br><span class="line"><span class="comment"> * $&#123;tags&#125;        </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>下面说如何用，上图：<br><img src="/2020/02/20/javabase27-doc/demo.gif" alt="/**+回车"></p><p>然后编辑 Description ,描述作用。方法上生成注释的操作也是一样的，不举例了。</p><p>最后效果</p><p><img src="/2020/02/20/javabase27-doc/sl.png" alt="注释示例"></p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>一定要养成写注释的好习惯啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;学过了类的各种东西，现在说一个很简单但是很重要的东西，就是注释——javadoc，简单是因为只需要按几下按键就出来了，重要是因为，有注释会给予看程序的其他人极大的方便，其他人不用去猜你写这个类做啥用，这个方法干嘛用。大大提高了程序的可读性，维护起来容易多了。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十六）——创建对象（显式、隐式）</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase26-newobj/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase26-newobj/</id>
    <published>2020-02-20T03:09:14.000Z</published>
    <updated>2020-02-21T01:14:43.609Z</updated>
    
    <content type="html"><![CDATA[<p><em>把对象创建的过程称为类的实例化，如果类没有实例化，无论是类属性还是方法都无法使用（除了 static 修饰的），本篇内容学习如何创建对象，<strong>主要内容有：三种显式、一种隐式创建方法</strong></em></p><a id="more"></a><hr><h2 id="一、显式创建对象"><a href="#一、显式创建对象" class="headerlink" title="一、显式创建对象"></a>一、显式创建对象</h2><p>显式创建对象有四种：new 、java.lang.Class 类方法创建、对象 clone 方法、 java.io.ObjectlnputStream 对象的 readObject() 方法。</p><h3 id="1-new-关键字创建对象"><a href="#1-new-关键字创建对象" class="headerlink" title="1.new 关键字创建对象"></a>1.new 关键字创建对象</h3><p>这个是最常用的方式，前面也多次使用，这里不再多叙述，new 的语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型 对象名 = <span class="keyword">new</span> 类型();</span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line">String str = <span class="keyword">new</span> String();</span><br><span class="line"><span class="comment">// 有时候用不着对象名 ——匿名对象</span></span><br><span class="line">System.out.print(<span class="keyword">new</span> String(<span class="string">"This is kangkang!!"</span>));</span><br></pre></td></tr></table></figure><blockquote><p><strong>匿名对象</strong><br>没有明确给出对象名，普通对象需要同时在栈和堆中开辟空间，匿名对象只占用堆空间，而且匿名对象时一次性的，如果当前方法里值与需要用到一次对象，可以采用这种写法，通常作为参数使用。</p></blockquote><h3 id="2-使用-newlnstance-方法"><a href="#2-使用-newlnstance-方法" class="headerlink" title="2.使用 newlnstance() 方法"></a>2.使用 newlnstance() 方法</h3><p>借助了 java.lang.Class 类提供的 newInstance 方法，首先创建 Class 对象（注意区分 Class 与 class，Class是一个具体的类，class 是类的概念，一个关键字），Class 对象无法通过 new 新建，需要借助静态方法 .forName 完成对象创建。Class 类功能很强大，支持了 java 中很重要的 “反射机制” ，反射机制后面单独讲。</p><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class</span></span><br><span class="line">Class 类对象名称 = Class.forName(要实例化的类全称);</span><br><span class="line">类名 对象名 = (类名)Class类对象名称.newInstance();</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// forname 中参数 一定是类的完整路径，要带包名</span></span><br><span class="line">Class cls = Class.forName(<span class="string">"demo_class.Student"</span>);</span><br><span class="line">Student stu = (Student) cls.newInstance();</span><br><span class="line">stu.study();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到了昨天建的 Student 类，要提醒的是，使用 forName 时，参数是类的完整路径，一定要带包名。</p><blockquote><p>提到包名就要说说包命名规范，通常为 com.公司.项目.[package]…. 这个 com 是 company 的缩写，说明是公司项目，那个人项目呢？</p><p>包命名有如下规范：</p><ol><li>个人的项目命名：</li></ol><ul><li>indi ： 个体项目（individual），指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。 包名为“indi.发起者名.项目名.模块名……”</li><li>onem ： 单人项目（one-man），推荐用indi，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。 包名为“onem.发起者名.项目名.模块名……”</li><li>pers ： 个人项目（personal），指个人发起，独自完成，可分享的项目，copyright主要属于个人。 包名为“pers.个人名.项目名.模块名.……”</li><li>priv ： 私有项目（private），指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。 包名为“priv.个人名.项目名.模块名.……”</li></ul><ol start="2"><li>团体的项目命名:</li></ol><ul><li>team： 团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有。 包名为“team.团队名.项目名.模块名.……”</li><li>com ： 公司项目，copyright由项目发起的公司所有。 包名为“com.公司名.项目名.模块名.……”</li></ul><p>比如上面的测试类所处的包正确的包名为：pers.mgg.demo.test </p></blockquote><p>Student 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do homework"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现接口后 重写 clone方法  右击→ Source → Override/Implement Methods</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/2020/02/20/javabase26-newobj/gi.png" alt="使用 newInstance 创建 Student 对象"></p><h3 id="3-使用-clone-方法"><a href="#3-使用-clone-方法" class="headerlink" title="3.使用 clone() 方法"></a>3.使用 clone() 方法</h3><p>该方法很少用，使用该方法创建对象时，要实例化的类必须继承 java.lang.Cloneable 接口。 调用对象的 clone() 方法创建对象的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名对象名 = (类名)已创建好的类对象名.clone();</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">Student stu2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stu2 = (Student) stu1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">stu2.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/20/javabase26-newobj/gi.png" alt="异常处理"></p><blockquote><p>代码中的 try  catch  是异常处理，详细内容到后面异常处理再说，这里稍微提一下：</p><p><img src="/2020/02/20/javabase26-newobj/yc.png" alt="异常处理"></p><p><img src="/2020/02/20/javabase26-newobj/yc2.png" alt="两种不同的异常处理"></p><p>在实际开发中用 try catch 比较多</p></blockquote><h2 id="二、隐式创建"><a href="#二、隐式创建" class="headerlink" title="二、隐式创建"></a>二、隐式创建</h2><p>隐式创建其实前面经常用了，举个例子就是 String str = “oh! awesome!!” 。</p><p>以及当使用字符串拼接时  str = str+”come on”  也会隐式创建对象，str 已经不是原来的 str 了。</p><p>最后 java 虚拟机在加载 .class 文件时，都会创建一个上面说到的 java.lang.Class 对象，用来封装类在方法区内的数据结构。</p><blockquote><p>垃圾回收（jvm gc）<br>每个对象都是相互独立的，在内存中占有独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成了垃圾，由 Java 虚拟机自带的垃圾回收机制处理。</p></blockquote><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>显式的三种方法，前两种要掌握，clone 方法要了解，隐式就没什么可说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;把对象创建的过程称为类的实例化，如果类没有实例化，无论是类属性还是方法都无法使用（除了 static 修饰的），本篇内容学习如何创建对象，&lt;strong&gt;主要内容有：三种显式、一种隐式创建方法&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十五）—— this 关键字</title>
    <link href="http://www.mggblog.ink/2020/02/19/javabase25-this/"/>
    <id>http://www.mggblog.ink/2020/02/19/javabase25-this/</id>
    <published>2020-02-19T10:09:17.000Z</published>
    <updated>2020-02-21T01:14:17.756Z</updated>
    
    <content type="html"><![CDATA[<p><em>this 关键字是 Java 常用的关键字，可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。<strong>本篇包括：this.属性，this.方法，this.构造方法</strong></em></p><a id="more"></a><hr><h2 id="一、this-属性名"><a href="#一、this-属性名" class="headerlink" title="一、this.属性名"></a>一、this.属性名</h2><p>大部分时候，普通方法访问其他方法、成员变量时无须使用 this 前缀，<strong>但如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用 this 前缀</strong>。</p><p>其实在上一篇说 getter setter的时候已经有遇到这个关键字了，<br>举一个 Person 类的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String gender; <span class="comment">//性别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> tall;  <span class="comment">//身高</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了加上 getter 和 setter 这次加点新的，添一个构造方法和一个 toString。</p><p>直接快速生成：<br><img src="/2020/02/19/javabase25-this/pc.png" alt="快速生成三个方法"></p><p>因为是第一次碰到构造方法，请自己仔细体会方法内部信息</p><p>此时 Person 类变成了 完全体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String gender; <span class="comment">//性别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> tall;  <span class="comment">//身高</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带参数构造方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tall</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender, <span class="keyword">double</span> tall)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line"><span class="keyword">this</span>.tall = tall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTall</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTall</span><span class="params">(<span class="keyword">double</span> tall)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tall = tall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", gender="</span> + gender + <span class="string">", tall="</span> + tall + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，构造方法和 setter 方法内部都有 this 关键字，通过 this.属性 让参数变为类属性的值，编写一个测试类来看一下构造方法的作用。</p><blockquote><p>补充一个问题,当类中只有一个有参构造：<br><img src="/2020/02/19/javabase25-this/t.png" alt="注意只有一个有参构造的情况"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">// 利用有参数的构造方法直接给Person类对象属性赋值</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"kangkang"</span>, <span class="number">10</span>, <span class="string">"男"</span>, <span class="number">110</span>);</span><br><span class="line">System.out.println(person.getName());</span><br><span class="line">System.out.println(person.getAge());</span><br><span class="line">System.out.println(person.getGender());</span><br><span class="line">System.out.println(person.getTall());</span><br><span class="line"><span class="comment">// 直接使用toString</span></span><br><span class="line">System.out.println(person.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/19/javabase25-this/t1.png" alt="输出结果"></p><p>很明显，通过类中的有参构造，为 Person 类属性赋值，而在构造方法中正是使用了 this 关键字（仔细体会开头的那句话：<strong>如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用 this 前缀</strong>）</p><p><em>提示：当一个类的属性（成员变量）名与访问该属性的方法参数名相同时，则需要使用 this 关键字来访问类中的属性，以区分类的属性和方法中的参数。</em></p><h2 id="二、this-方法名"><a href="#二、this-方法名" class="headerlink" title="二、this.方法名"></a>二、this.方法名</h2><p>this 关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。</p><p>新建一个 Student 类，让其中一个方法调用另一个方法，具体流程为吃晚饭，写作业，睡觉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"Tom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do homework"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 吃饭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"have a dinner"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 睡觉</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.eat();</span><br><span class="line"><span class="keyword">this</span>.study();</span><br><span class="line">System.out.println(<span class="string">"do sleep"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(Student.name);</span><br><span class="line">stu.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看结果：<br><img src="/2020/02/19/javabase25-this/t2.png" alt="运行结果"></p><p>在 Student 类中的sleep 方法使用this 关键字调用了其他两个方法，在测试类中只需要调用一个 sleep 就可以完成 三个方法的操作。</p><p>我们发现当 sleep 方法改为这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">eat();</span><br><span class="line">study();</span><br><span class="line">System.out.println(<span class="string">"do sleep"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行测试类，发现输出结果一样，<strong>省略 this 前缀只是一种假象，虽然程序员省略了调用 eat()、study() 方法之前的 this，但实际上这个 this 依然是存在的。</strong></p><blockquote><p>注意：对于 static 修饰的方法而言，可以使用类来直接调用该方法，如果在 static 修饰的方法中使用 this 关键字，则这个关键字就无法指向合适的对象。所以，static 修饰的方法中不能使用 this 引用。并且 Java 语法规定，静态成员不能直接访问非静态成员。</p></blockquote><h2 id="三、this-访问构造方法"><a href="#三、this-访问构造方法" class="headerlink" title="三、this 访问构造方法"></a>三、this 访问构造方法</h2><p>将 Student 改为这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.name+ <span class="string">"  do homework"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="string">"Tom"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">stu.study();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/19/javabase25-this/t3.png" alt="输出结果"></p><p>无参构造直接通过 this(“Tom”) 给私有属性赋予了值， this(“Tom”) 与 this.Student(“Tom”) 等价，且只能在构造方法中使用，也必是第一条代码。</p><blockquote><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>当在创建无参构造时，会发现方法中有 super();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super 关键字是指向父类的引用，前面说过创建的每一个类都会继承 Object 类，刚才 this() 的用法为指向自己个构造，那么 super() 就会指向父类构造方法，我认为这解释了为什么创建基类对象后，父类方法可以直接使用。</p><p>与 this() 一样，只能在构造方法中使用，也必是第一条代码。</p></blockquote><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>在正常的开发中，用到实体类都会有专门的软件生成，不用自己手写，因为写实体类实在浪费时间。实体类一建生成可以让程序员吧时间放在逻辑代码部分，提高开发效率。但是作为新手的话，还是多写写，多多体会。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;this 关键字是 Java 常用的关键字，可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。&lt;strong&gt;本篇包括：this.属性，this.方法，this.构造方法&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十四）——类的概念、定义、类属性、类方法（含可变参数）</title>
    <link href="http://www.mggblog.ink/2020/02/19/javabase24-oop-class/"/>
    <id>http://www.mggblog.ink/2020/02/19/javabase24-oop-class/</id>
    <published>2020-02-19T00:47:36.000Z</published>
    <updated>2020-02-21T04:12:27.348Z</updated>
    
    <content type="html"><![CDATA[<p><em>在面向对象中，类和对象是最基本、最重要的组成单元。类实际上是表示一个客观世界某类群体的一些基本特征抽象。对象就是表示一个个具体的东西。所以说类是对象的抽象，对象是类的具体。</em></p><a id="more"></a><hr><h2 id="一、类的概念"><a href="#一、类的概念" class="headerlink" title="一、类的概念"></a>一、类的概念</h2><p>类（Class） 就是类别，在上一篇说封装时我们提到类是对象的封装，对象是自然界客观存在的个体，而类是一个概念，并不是可以看得见摸得着的。无论是进口法拉利、兰博基尼、还是国产长城、吉利都属于汽车，汽车是对这些对象的描述，都有外壳、车轮、底盘、方向盘、发动机等，都可以向前跑，向后倒车，鸣喇叭、刹车。类与对象的关系就是 汽车 与这些具体实物的关系，由此可见。</p><ul><li>类是概念模型，定义对象的所有特性和所需的操作，对象是真实的模型，是一个具体的实体。</li><li>类是描述了一组有相同特性（属性）和相同行为（方法）的一组对象的集合。</li></ul><p>我们买车的时候会去了解，动发动机怎么样，座椅舒不舒服，悬挂系统稳不稳，轮胎大小等具体信息，这些事对象的属性。还要去试驾开起来如何，体现了对象中的方法。不同的车属性和驾驶体验各有不同。</p><ul><li>对象或实体所拥有的特征在类中表示时称为类的属性。</li><li>对象执行的操作称为类的方法。</li></ul><p><strong>类是构造面向对象程序的基本单位</strong>，是抽取了同类对象的共同属性和方法所形成的对象或实体的“模板”。而对象是现实世界中实体的描述，对象要创建才存在，有了对象才能对对象进行操作。类是对象的模板，对象是类的实例。</p><p>举一些类的例子：</p><p><img src="/2020/02/19/javabase24-oop-class/cd.png" alt="类"></p><h2 id="二、类的定义"><a href="#二、类的定义" class="headerlink" title="二、类的定义"></a>二、类的定义</h2><p>Java中所有程序都基于类，类是引用类型。定义类的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[public][abstract|final]class&lt;class_name&gt;[extends&lt;class_name&gt;][implements&lt;interface_name&gt;] &#123;</span><br><span class="line">    <span class="comment">// 定义属性部分</span></span><br><span class="line">    &lt;property_type&gt;&lt;property1&gt;;</span><br><span class="line">    &lt;property_type&gt;&lt;property2&gt;;</span><br><span class="line">    &lt;property_type&gt;&lt;property3&gt;;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">// 定义方法部分</span></span><br><span class="line">    function1();</span><br><span class="line">    function2();</span><br><span class="line">    function3();</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述语法中各关键字的描述如下。</p><ul><li>public：表示“共有”的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，作为公共工具供其他类和程序使用的类应定义为 public 类。</li><li>abstract：如果类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用 abstract 修饰的方法）和具体方法（没有使用 abstract 修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。</li><li>final：如果类被 final 修饰，则不允许被继承。</li><li>class：声明类的关键字。</li><li>class_name：类的名称。</li><li>extends：表示继承其他类。</li><li>implements：表示实现某些接口。</li><li>property_type：表示成员变量的类型。</li><li>property：表示成员变量名称。</li><li>function()：表示成员方法名称。</li></ul><p>Java 类名的命名规则：</p><ol><li>类名应该以下划线（_）或字母开头，最好以字母开头。</li><li>第一个字母最好大写，如果类名由多个单词组成，则每个单词的首字母最好都大写。</li><li>类名不能为 Java 中的关键字，例如 boolean、this、int 等。</li><li>类名不能包含任何嵌入的空格或点号以及除了下划线（_）和美元符号（$）字符之外的特殊字符。</li></ol><p>例如定义一个汽车类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">String brand; <span class="comment">// 品牌</span></span><br><span class="line"><span class="keyword">double</span> length;<span class="comment">// 长度</span></span><br><span class="line"><span class="keyword">double</span> width; <span class="comment">// 宽度</span></span><br><span class="line"><span class="keyword">double</span> weight;<span class="comment">// 重量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Runing"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的汽车类的属性为：品牌、长度、宽度、重量；方法为 run()。</p><p>class 前的 public 代表公用的，外部可以随意访问该类，属性中的 private 代表私有，只有本类内部可以访问，方法前的 public 表示该方法可以在任意类中使用。</p><h2 id="三、类的属性和方法"><a href="#三、类的属性和方法" class="headerlink" title="三、类的属性和方法"></a>三、类的属性和方法</h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h3><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>|<span class="keyword">protected</span>|<span class="keyword">private</span>][<span class="keyword">static</span>][<span class="keyword">final</span>]&lt;type&gt;&lt;variable_name&gt;</span><br></pre></td></tr></table></figure><p>各参数的含义如下。</p><ul><li>public、protected、private：用于表示成员变量的访问权限。</li><li>static：表示该成员变量为类变量，也称为静态变量。</li><li>final：表示将该成员变量声明为常量，其值无法更改。</li><li>type：表示变量的类型。</li><li>variable_name：表示变量名称。</li></ul><p>为 Car 类中的属性加上修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brand = <span class="string">"Des Auto"</span>; <span class="comment">//品牌</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> length;<span class="comment">//长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> width; <span class="comment">//宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> weight;<span class="comment">//重量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Runing"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加完修饰符后，品牌 brand 属性变成了一个公有静态的常量，值为“ Des Auto ”，让这个汽车类变成类大众汽车的类，final 声明后品牌信息无法修改。</p><p>其他属性变成类私有属性，只能在类内部访问。</p><p>属性不赋值的话有默认值：</p><ul><li>整数型（byte、short、int 和 long）的基本类型变量的默认值为 0。</li><li>单精度浮点型（float）的基本类型变量的默认值为 0.0f。</li><li>双精度浮点型（double）的基本类型变量的默认值为 0.0d。</li><li>字符型（char）的基本类型变量的默认值为 “\u0000”。</li><li>布尔型的基本类型变量的默认值为 false。</li><li>数组引用类型的变量的默认值为 null。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。</li></ul><p>一般属性名的命名方式与变量一样，采用驼峰式，比如 身份证号 用 personId ，电话号码 用 telNumber， 组合词的话头字母小写，后面单词头字母大写，单个字母的属性名小写就可以了。另外还有中间加下划线的命名方式，如 person_id ，驼峰式命名用的比较广泛，但是具体还是要看项目开发规范的要求，有可能写规范的喜欢用下划线呢。</p><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h3><p>方法表示这个类可以完成哪些动作，比如上面 Car 类里有 run() 方法，语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>][<span class="keyword">static</span>]&lt;<span class="keyword">void</span>|return_type&gt;&lt;method_name&gt;([paramList]) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public | private | protected 只能选择一个，代表了不同的访问权限。</p><p>上述代码中一个方法包含 4 部分：方法的返回值、方法名称、方法的参数和方法体。其中 retum_type 是方法返回值的数据类型，数据类型可以是原始的数据类型，即常用的 8 种数据类型，也可以是一个引用数据类型，如一个类、接口和数组等。</p><p>除了这些，一个方法还可以没有返回值，即返回类型为 void，像 main() 方法。method_name 表示自定义的方法名称，方法的名称首先要遵循标识符的命名约定，除此之外，方法的名称第一个单词的第一个字母是小写，第二单词的第一个字母是大写，依此类推。</p><p>paramList 表示参数列表，这些变量都要有自己的数据类型，可以是原始数据类型，也可以是复杂数据类型，一个方法主要依靠参数来传递消息。方法主体是方法中执行功能操作的语句。其他各修饰符的含义如下。</p><ul><li>public、private、protected：表示成员方法的访问权限。</li><li>static：表示限定该成员方法为静态方法。</li><li>final：表示限定该成员方法不能被重写或重载。</li><li>abstract：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类</li></ul><p>这里涉及到的重载，重写，抽象方法后面再做了解。</p><p>我们约定采用驼峰式命名，比如 carRun() 汽车跑的方法：</p><p>为上面的 Car 类重新写个方法 carRun：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brand = <span class="string">"Des Auto"</span>; <span class="comment">// 品牌</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> length;<span class="comment">// 长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> width; <span class="comment">// 宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> weight;<span class="comment">// 重量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有方法 只能在类内部调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Runing"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公有且静态方法，可以在其他类不创建对象的情况下调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">carRun</span><span class="params">(<span class="keyword">double</span> speed)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;<span class="comment">// 共有的 静态的 无法被重写的 带有参数的 并且带有异常处理的方法</span></span><br><span class="line">System.out.println(<span class="string">"The car is start up!"</span>);<span class="comment">//启动引擎</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);<span class="comment">//等待一秒，线程先不用了解  InterruptedException 异常处理就是因为它 模拟汽车运行</span></span><br><span class="line">run();<span class="comment">//调用了类中的run方法</span></span><br><span class="line">System.out.println(<span class="string">"The car is running with speed: "</span> + speed + <span class="string">"km/s"</span>);<span class="comment">//使用了参数 speed</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"car turn off"</span>; <span class="comment">//返回了 car 的运行状态 执行完毕后 car 熄火了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上方 run 方法 与 carRun 在修饰上的不同，编写个测试类来演示一下：</p><blockquote><p>当想调用 Car的属性或者方法时发现只有 public 修饰的属性和方法可以访问<br><img src="/2020/02/19/javabase24-oop-class/bl.png" alt="只有public修饰的属性和方法可以访问"></p><p>那如何设置和获得 Car 类 中的私有属性呢？ 需要在 Car内部设置公有的 设置和读取属性的方法（setter 和 getter）。</p><p>现在大多数 IDE 都提供快速生成 setter 和 getter 方法的按钮，以及构造方法。</p><p>进入 Car 类 在其他方法下方右击→Source→Generate getter and setter<br><img src="/2020/02/19/javabase24-oop-class/gs.png" alt="快速生成 getter 和 setter 方法"><br><img src="/2020/02/19/javabase24-oop-class/set.png" alt="快速生成 getter 和 setter 方法"></p><p>保存 然后再返回测试类。</p><p>发现可以为 Car 的属性设置值了 看一下</p><p><img src="/2020/02/19/javabase24-oop-class/t.png" alt="成功通过类方法设置并获取了私有属性值"></p><p>通常凡是类中有属性的都会是这种形式，属性私有，然后创建公有的setter和getter方法。</p></blockquote><p>经过一段小插曲，继续方法 carRun 的测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//由于是静态方法，不需要new Car对象</span></span><br><span class="line">String status = Car.carRun(<span class="number">120.0</span>);  <span class="comment">//速度参数为double型 120.0，然后使用String 新建String变量 status 接收 carRun 方法返回值。</span></span><br><span class="line">System.out.println(status);</span><br><span class="line"><span class="comment">//System.out.println(Car.carRun(120.0));  //不新建变量直接这样也行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/19/javabase24-oop-class/carrun.gif" alt="测试 carRun 方法"></p><p>仔细对比 run 方法与 carRun 方法 体会不同修饰符的意义，体会有返回值方法 return 的用法。</p><blockquote><h3 id="方法中参数的用法"><a href="#方法中参数的用法" class="headerlink" title="方法中参数的用法"></a>方法中参数的用法</h3><p>方法中的参数可以有很多个且类型可以不同，用“ ,” 隔开。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">int</span> i, String str, Car car, <span class="keyword">double</span> d)</span></span>&#123;<span class="comment">// 方法内部的参数叫 形式参数 形参</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用方法时参数的顺序，数量，类型要严格一致，一一对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">10</span>;</span><br><span class="line">String s = <span class="string">"kk"</span>;</span><br><span class="line">Car car1 = <span class="keyword">new</span> Car;</span><br><span class="line"><span class="keyword">double</span> speed =  <span class="number">120.0</span>;</span><br><span class="line"></span><br><span class="line">printf(sum,s,car1,d);<span class="comment">// 调用方法时 给的参数叫 实际参数 实参</span></span><br></pre></td></tr></table></figure></blockquote><p>还要提醒一点：在方法内部注意变量的作用域 看好花括号 “ {} “</p><h3 id="类方法的可变参数"><a href="#类方法的可变参数" class="headerlink" title="类方法的可变参数"></a>类方法的可变参数</h3><p>可变参数的意思就是方法的参数数量可以变化，在开发过程中会经常遇到参数个数无法确定的情况，这时候就需要可变参数了。</p><p>可变参数的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">methodName(&#123;paramList&#125;,paramType…paramName);</span><br></pre></td></tr></table></figure><p>其中，methodName 表示方法名称；paramList 表示方法的固定参数列表；paramType 表示可变参数的类型；… 是声明可变参数的标识；paramName 表示可变参数名称。</p><p><em>注意：可变参数必须定义在参数列表的最后。</em></p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kbcs</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"有其他参数方法"</span>);</span><br><span class="line">kbParam(<span class="string">"kk"</span>, <span class="number">10</span>, <span class="keyword">new</span> <span class="keyword">double</span>[] &#123; <span class="number">8.8</span>, <span class="number">9.9</span>, <span class="number">123.4</span> &#125;);</span><br><span class="line">System.out.println(<span class="string">"无其他参数方法"</span>);</span><br><span class="line">kbParam2(<span class="number">8.8</span>, <span class="number">9.9</span>, <span class="number">123.4</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: kbParam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 有其他参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kbParam</span><span class="params">(String name, <span class="keyword">int</span> i, <span class="keyword">double</span>... ds)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"可变参数个数："</span> + ds.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> d : ds) &#123;</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: kbParam2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 无其他参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kbParam2</span><span class="params">(<span class="keyword">double</span>... ds)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"可变参数个数："</span> + ds.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> d : ds) &#123;</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/19/javabase24-oop-class/cs.png" alt="有无其他参数，带入参数方法不一样"></p><p>当有其他参数时，可变参数要放在后面，并且需要 new 创建对应类型的数组对象，填写参数。</p><p>当没有其他参数时，可以直接写对应类型的参数。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>这部分知识内容多，需要多练，多体会，基础要打牢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在面向对象中，类和对象是最基本、最重要的组成单元。类实际上是表示一个客观世界某类群体的一些基本特征抽象。对象就是表示一个个具体的东西。所以说类是对象的抽象，对象是类的具体。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十三）——对象概念、面向对象的三个特征</title>
    <link href="http://www.mggblog.ink/2020/02/18/javabase23-oop1/"/>
    <id>http://www.mggblog.ink/2020/02/18/javabase23-oop1/</id>
    <published>2020-02-18T13:37:28.000Z</published>
    <updated>2020-02-21T01:16:45.650Z</updated>
    
    <content type="html"><![CDATA[<p><em>对 Java 语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过相互作用传递信息，实现程序开发。</em></p><a id="more"></a><hr><h2 id="一、对象的概念"><a href="#一、对象的概念" class="headerlink" title="一、对象的概念"></a>一、对象的概念</h2><p>“java是面向对象的语言”这种描述是老生常谈，概念知识没必要长篇大论，个人感觉一个合适的比喻比得过一大段详细的描述。那如何理解“对象”呢？</p><p>对象就是现实世界中的一个实体，比如说人类，每个人都是一个对象，用java程序语言来描述一个人的各种信息与动作，此时称java是面向对象的程序语言。</p><p>每个对象都有自身的特点，以人为例：</p><ul><li>每个人都有性别，名字等（对象的属性），每个正常人都可以吃饭、睡觉（对象的行为）；</li><li>人可以变胖或者变瘦（对象状态变化）；</li><li>每个人都是唯一的，没有完全相同的两个人（对象唯一性）；</li><li>物以类聚，人是生物的一个种类，我只是人类中的一员（对象是类别的实例）；</li><li>自然界除了人，还有花鸟虫鱼野兽等其他类生物，每一个具体的生物都是一个对象（一切皆为对象）。</li></ul><h2 id="二、面向对象的三个特征"><a href="#二、面向对象的三个特征" class="headerlink" title="二、面向对象的三个特征"></a>二、面向对象的三个特征</h2><p>面向对象有散个基本特征：<strong>封装、继承、多态</strong>。首先搞清楚，为什么要面向对象。以人为例：</p><ul><li>有一个人善于弹钢琴，在自己家可以弹，也可以被委派到音乐会去弹，他老婆是老师，每天都要去学校上课（面向对象代码可重复使用，不同种功能分开开发，提高开发效率）</li><li>这个人音乐天赋了得，有个乐团缺个打鼓手，他自学打鼓加入了乐团（面向对象可扩展性）</li><li>乐团按照乐器种类发工资，乐团里每个人都拿到了不同种乐器相应的钱（面向对象易于管理数据与功能的关系）</li></ul><p>以 java 来说，她多次蝉联世界编程语言使用人数第一的宝座，此殊荣说明了 java 的强大，但是成就了 java 如此强大的是她的三个核心特征：封装、继承、多态。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是将对象属性与方法结合起来，外部无法干扰到对象内部的属性信息与方法，保护了该对象不被破坏。有以下优点：</p><ul><li>保护对象，外部在没有权限的情况下无法随意访问对象内部</li><li>隐藏细节信息，如外人只知道我善于弹钢琴，但是他不知道我是如何弹的那么好的。</li><li>有利于建立对象间的耦合关系，还是乐团的例子，我会弹钢琴，别人会其他乐器，一起组了个乐团，合作一起做音乐。</li><li>提高软件复用率，有个乐团出高新招聘钢琴师，我不满意现在的工资跳槽了过去，我并不是只能在这个乐团弹。</li></ul><p>java 中封装的对象称为为类，有权限修饰符 private protect public  来限定外部访问的权限大小，后面再说。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承很容易理解，就以人来说，正常情况下，一个人可以走路，他的儿子应该也会走路，不但会走路，还会开车。放在程序中，就是子类继承了父类的所有属性和方法，并且可以具有父类没有的属性与方法。<strong>在java中每个类只可以继承一个父类（单继承机制）</strong></p><p>举个具体程序的例子：</p><p>有一个 Person 类:<br>类中属性有：姓名，性别，年龄。<br>类中的方法有：吃饭，睡觉。</p><p>我可以使用这个 Person 类完成一个具体的操作“康康是个男生，今年10岁，他正在吃饭，一会要去睡觉。”</p><p>现在我需要一个 Student 类来完成学生的具体操作“小红是个女生，今年9岁，她吃完饭，要去睡觉，睡醒要学习，然后再吃饭睡觉。” 显然 Person 中没有学习的功能，而且 student 类依然需要 person 类中的属性和方法。</p><p>此时只需要创建一个 student 类继承 person 类，然后在 student 类中新增 学习的方法就可以了。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态的属性是相对于接口来说的，因为类只支持单继承，而接口支持多实现（可以认为是接口的多继承），类在下一篇学，接口在单独讲多态的时候学，学完后可以再返回来看看这三个属性加深理解。</p><p>举例说明接口的多态：</p><p>有一个 teacher 类 ，类中有一个 teach 的抽象方法（接口中的方法都是抽象的，抽象的意思是只有方法名没有方法体，方法如何执行写在实现接口的类中）</p><p>然后有 englishteacher 类 和 mathteacher 类分别实现了 teacher 接口</p><p>englishteacher 类中的 teach 方法具体表现为 teach english</p><p>mathteacher 类中 teach 方法具体表现为 tech math。</p><p><img src="/2020/02/18/javabase23-oop1/dt.png" alt="接口的实现"></p><p>那么多态有什么什么好处呢，就上面的例子，写接口的人只需考虑老师要做哪些工作，不用考虑具体做什么，英语老师只需要关心教英语，数学老师只需要关心教数学。</p><p>今天的内容只是简单介绍，这些内容，会在后面的学习中有更多的体会。<br>__</p><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>最近掉头发掉的厉害，睡了睡了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;对 Java 语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过相互作用传递信息，实现程序开发。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十二）——选择排序</title>
    <link href="http://www.mggblog.ink/2020/02/18/javabase22-xzpx/"/>
    <id>http://www.mggblog.ink/2020/02/18/javabase22-xzpx/</id>
    <published>2020-02-18T01:43:31.000Z</published>
    <updated>2020-02-21T00:35:29.646Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇内容包括：选择排序，三种排序方法总结</em></p><a id="more"></a><hr><h2 id="一、选择排序"><a href="#一、选择排序" class="headerlink" title="一、选择排序"></a>一、选择排序</h2><h3 id="选择排序思路"><a href="#选择排序思路" class="headerlink" title="选择排序思路"></a>选择排序思路</h3><p>选择排序思路比较简单，从第一次开始，每次都找到数组中最小的值，互换掉索引最小的那个，举例说明：<br>如数组 int arr[] = {6,5,4,3,2,1} ,从第一个元素开始不断寻找最小值来互换：</p><p>第一步，找到最小值为 1 ，互换 6 结果为 1 5 4 3 2 6；</p><p>第二步，从剩下的 5 4 3 2 6 中找到最小值 2 ，互换 5 结果为 1 2 4 3 5 6；</p><p>第三步，从剩下的 4 3 5 6 中找到最小值 3 ，互换 4 结果为 1 2 3 4 5 6 ，排序完成了？</p><p>其实排序并没有完成，第三步完成后未排序元素为 4，5，6 ，只不过每次寻找最小都是自身了，但是程序依旧要执行后面的两步：</p><p>第四步，从 4 5 6 找出 4，</p><p>第五步，从 5 6 中 找出 5，</p><p>当只剩下 6 一个元素时 就没必要在运行下去了，因为没有下一个元素个可以比较了。最终排序结果 1 2 3 4 5 6。</p><p>分析例子：</p><p>6 个元素的数组需要找 5 次最小，每一次找到最小要和未被互换过的第一个元素互换，那么程序就理顺了：</p><ol><li>确定循环互换次数，</li><li>找最小值</li><li>互换直到当前元素下标与数组长度-1相等。</li></ol><h3 id="构建程序"><a href="#构建程序" class="headerlink" title="构建程序"></a>构建程序</h3><p>通过上面的分析可以确定，程序需要两层循环，外层循环控制互换次数，并执行互换操作，内层循环寻找最小值。</p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;<span class="comment">//外层确定次数</span></span><br><span class="line"><span class="keyword">int</span> min = arr[i];<span class="comment">//最小值</span></span><br><span class="line"><span class="keyword">int</span> index = i;<span class="comment">//最小值索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;<span class="comment">//找到最小值</span></span><br><span class="line"><span class="keyword">if</span> (min &gt; arr[j]) &#123;</span><br><span class="line">min = arr[j];</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[index] = arr[i];<span class="comment">//最小值与当前元素交换</span></span><br><span class="line">arr[i] = min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出排序完成结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/18/javabase22-xzpx/px.png" alt="排序完成"><br>别的没什么好说的，接下来谈谈冒泡、快速、选择排序的特点做个总结。</p><h2 id="二、总结三种排序方法"><a href="#二、总结三种排序方法" class="headerlink" title="二、总结三种排序方法"></a>二、总结三种排序方法</h2><p>三种方法的时间空间复杂度稳定性比较：<br><img src="/2020/02/18/javabase22-xzpx/td.png" alt="算法特点"></p><p>总结就是：</p><ul><li>冒泡稳定，速度一般；</li><li>快速快，不稳定；</li><li>选择速度一般且不稳定，元素越多效率越低。</li></ul><p>排序算法有七八种呢，这三种较为常见，别的有时间再去了解。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>接下来学 java 类和对象，java 语言的立足之本。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本篇内容包括：选择排序，三种排序方法总结&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十一）——快速排序</title>
    <link href="http://www.mggblog.ink/2020/02/17/javabase21-kspx/"/>
    <id>http://www.mggblog.ink/2020/02/17/javabase21-kspx/</id>
    <published>2020-02-17T14:47:29.000Z</published>
    <updated>2020-02-21T01:13:14.130Z</updated>
    
    <content type="html"><![CDATA[<p><em>快速排序由C. A. R. Hoare在1960年提出。快速它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</em></p><a id="more"></a><hr><h2 id="一、快速排序思路"><a href="#一、快速排序思路" class="headerlink" title="一、快速排序思路"></a>一、快速排序思路</h2><p>快速排序相对于冒泡排序的逻辑复杂了很多，带来的好处就是快速排序在几种算法中排序效率较高，无论是面试还是软考很容易碰到，它采用分治法，思想简单概括为：</p><ul><li><ol><li>于数组中选出一个基数（就是排序时以他为准）。</li></ol></li><li><ol start="2"><li>分区，比基数大的放右边，小的放左边。</li></ol></li><li><ol start="3"><li>对两边分别再进行 1.2. 步，最终排序完成。<blockquote><p>从 3. 可以看出算法中肯定需要用到递归，不然无法完成左右再重新分的需求，新手还不懂递归是什么的点击<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/5634537?fr=aladdin">递归</a>。</p></blockquote></li></ol></li></ul><p>从其他博客中看来看去，最终找到了一种很好的理解方式（虽然我也懂得这个算法了，以我三脚猫的功夫怕是说不清啊，我会对博客内容进行整理）：</p><p><em>（以下内容转载自：<a href="https://me.csdn.net/shujuelin">脚丫先生</a>：<a href="https://blog.csdn.net/shujuelin/article/details/82423852">https://blog.csdn.net/shujuelin/article/details/82423852</a> ）</em></p><p>假设现在对“6 1 2 7 9 3 4 5 10 8”这个10个数进行排序。首先在这个序列中随便找一个数作为<strong>基准数</strong>（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列：</p><p>3 1 2 5 4 6 9 7 10 8</p><p>在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。想一想，你有办法可以做到这点吗？</p><p>方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。(直接看图理解就好，文字配图，效果更佳)</p><p><img src="/2020/02/17/javabase21-kspx/kp1.jpg" alt="开始">  </p><p>首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。</p><p><img src="/2020/02/17/javabase21-kspx/kp2.jpg" alt="两边找到符合条件的值">  </p><p><img src="/2020/02/17/javabase21-kspx/kp3.jpg" alt="交换">  </p><p>现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：</p><p>6 1 2 5 9 3 4 7 10 8</p><p><img src="/2020/02/17/javabase21-kspx/kp4.jpg" alt="继续寻找">  </p><p><img src="/2020/02/17/javabase21-kspx/kp5.jpg" alt="交换">  </p><p>到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：</p><p>6 1 2 5 4 3 9 7 10 8</p><p>第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。将基准数6和3进行交换。交换之后的序列如下：</p><p>3 1 2 5 4 6 9 7 10 8</p><p><em>两个哨兵碰头，对应数组内两端取到同一个索引：</em><br><img src="/2020/02/17/javabase21-kspx/kp6.jpg" alt="两个哨兵碰头"><br><em>对应索引与基准数交换：</em><br><img src="/2020/02/17/javabase21-kspx/kp7.jpg" alt="交换"><br><em>交换：</em><br><img src="/2020/02/17/javabase21-kspx/kp8.jpg" alt="交换完成">  </p><p><em>交换完成后结束了相当重要的工作，剩下工作就是对左右两边数组再次进行相同操作，这部分操作对应代码中递归调用的阶段。</em></p><p>到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。</p><p>OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。</p><p>左边的序列是“3 1 2 5 4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧</p><p>如果你模拟的没有错，调整完毕之后的序列的顺序应该是：</p><p>2 1 3 5 4</p><p>OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：</p><p>1 2 3 4 5 6 9 7 10 8</p><p>对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下</p><p>1 2 3 4 5 6 7 8 9 10</p><p><strong>到此，排序完全结束。</strong> 细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。</p><p><img src="/2020/02/17/javabase21-kspx/kpmap.jpg" alt="过程图解">  </p><p>快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。</p><h2 id="二、构建程序"><a href="#二、构建程序" class="headerlink" title="二、构建程序"></a>二、构建程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test_qsort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序入口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="comment">// 输入起始参数，数组arr， 基准数索引为0，最右侧索引为 length-1</span></span><br><span class="line">quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 输出最终结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> low</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> high</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 如果不知道要会用到多少变量，可以先往下写，用到了再补到上面，i j 分别代表左右索引</span></span><br><span class="line"><span class="keyword">int</span> i, j, temp, t;</span><br><span class="line"><span class="comment">// 如果不满足下面条件说明排序已经完成了</span></span><br><span class="line"><span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明基准数</span></span><br><span class="line">temp = arr[low];</span><br><span class="line"><span class="comment">// 因为后面要和基准数做交换，所以需要声明新变量</span></span><br><span class="line">i = low;</span><br><span class="line">j = high;</span><br><span class="line"><span class="comment">// 根据基准数，左右开始找合适的值</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="comment">// 先从右边开始找小于基准数的元素 自己想想为什么？</span></span><br><span class="line"><span class="keyword">while</span> (temp &lt;= arr[j] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后左边开始找大于基准数的元素</span></span><br><span class="line"><span class="keyword">while</span> (temp &gt;= arr[i] &amp;&amp; i &lt; j) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右边找到小于基准数的元素，左边找到大于基准数的元素，在两边索引还不一致的情况下，交换位置</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">t = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 完成了两边交换，此时左右定位到同一个索引上，新型基准数与当前索引元素的交换。</span></span><br><span class="line">arr[low] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line"><span class="comment">// 左右分别开始以上步骤</span></span><br><span class="line"><span class="comment">// 右边数组 虽然此时 i = j 但是在递归调用时 i 会变为 0，所以只能用 j-1 来代表定位同一索引的值</span></span><br><span class="line">quickSort(arr, low, j - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 左边数组</span></span><br><span class="line">quickSort(arr, j + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序结果:<br><img src="/2020/02/17/javabase21-kspx/pxjg.png" alt="过程图解">  </p><p>快速排序不知有一种写法，但是中心思想不变，等熟练了可以试试换种写法。</p><h2 id="三、为什么要先从右边开始找？"><a href="#三、为什么要先从右边开始找？" class="headerlink" title="三、为什么要先从右边开始找？"></a>三、为什么要先从右边开始找？</h2><p>以习惯的基准数在左边第一个，排序为升序为例：</p><p>无论是手写示例还是代码调试都可以很容易找到答案</p><p>以 b 代表基准数，s 代表与基准数互换的数， sL 代表s左边的数, sR 代表s右边的数</p><p>图解：<br><img src="/2020/02/17/javabase21-kspx/bug.png" alt="问题图解">  </p><p>在基准数与 i = j  所在索引的数对换前： </p><p>在对调前还不会出现问题，问题出在对调的数变了，因为在完成 b 与 s 调换后，要达到 b 的左边都小于 b ，右边都大于 b ，那么在调换前这几个数的关系是  sR&gt;b&gt;sL?s,那么开始调换，如果从左边先，索引 i+1 后到达 s，s &lt; b,明显 i 不能停留在 s 的位置，继续 +1 找到大于 b 的数 sR ，然后 j 从右边开始 正好此时 j=i ，本来应该 s 与 b 交换，现在变成了 sR 与 b 交换，sR 是这几个数里最大的，跑到左边肯定就不对了，从这一步开始，后面排序都乱了，从右边先开始就没有这个问题了。</p><p>至于如何从先左边开始才能正确，我觉得要把 左小右大 的规则反过来，这样代码里的逻辑就要完全改变了。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>更新博客睡觉。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;快速排序由C. A. R. Hoare在1960年提出。快速它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十）——冒泡排序</title>
    <link href="http://www.mggblog.ink/2020/02/17/javabase20-px/"/>
    <id>http://www.mggblog.ink/2020/02/17/javabase20-px/</id>
    <published>2020-02-17T07:32:04.000Z</published>
    <updated>2020-02-21T01:12:14.826Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇学习数组三种排序方法中的冒泡排序，名字很形象了，冒泡，像汽水里的泡泡一个一个冒到液面。冒泡排序的思想是从第一个元素开始，和相邻的元素比较，如果大于后面元素就交换位置，最终完成排序。</em></p><a id="more"></a><hr><h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><p>了解了思想如何体现到程序上呢，很抽象，那就需要举个排序例子来研究一下。我们直接考虑最麻烦的情况，元素是从大到小排列，每个元素都要冒泡冒上去。</p><p>如一个整数数组 arr[] 中元素为 ：4，3，2，1 。</p><p>对数组进行排序：</p><ol><li><p>根据排序思想，首先 4 和 3 比较 4 &gt; 3 ,顺序变为 3，4，2，1，然后再比较 4 和 2，最终第一次比完结果为 3，2，1，4；<br>一共比对了 3 次，分别是 arr[0]:arr[1],arr[1]:arr[2],arr[2]:arr[3]。</p></li><li><p>然后对 3，2，1，4再进行比较排序…. 第二次比对完结果为：2，1，3，4；<br>此时发现，第一次比对完成后，最后一位元素 4 前面肯定没有了比 4 大的数，已经确定了 4 为最大值，所以剩下的元素比较不用和 4 比，只需要比 2 次即可,分别是 arr[0]:arr[1],arr[1]:arr[2]。本次结果确定了 3 是第二大。</p></li><li><p>最后对 2，1，3，4进行比较….第三次比对完结果为：1，2，3，4；<br>同理当比对完第二次后，确定了 4 为最大值，3 为第二大值， 剩下的数据不需要再和 3，4 比较，只比较 1 次就可以了，arr[0]:arr[1]，最终完成了排序。</p></li></ol><p>由此可以得出结论：4 个元素的数组在最麻烦的情况下，整个数组元素从第一个到最后一个需要比对 3 次，每次数组内部相邻元素分别需要比对 3、2、1次。</p><p>推广到 n 个元素的数组：n 个元素的数组在最麻烦的情况下，需要循环对比 n-1 次，每次数组内相邻的元素分别需要对比 n-1、n-2….2、1次。</p><p>考虑了排序最麻烦的情况，如果程序可以正确处理最麻烦的情况，那像原数组元素排序为 3，2，4，1 这种也不在话下，因为它被包含于最复杂的情况中。</p><p>接下来就可以思考程序内部怎么写了。</p><p>如何让两个元素值对换，如 i=1，j=2，变为 i=2，j=1？</p><p>当直接 i=j 时 j 就无法通过 j=i 获得 真实i 的值，所以 需要一个中间变量先将 i 的值存起来。<br>就是这样： sum = i; i=j; j=sum;  三步走完成数值交换。</p><h2 id="二、构建程序"><a href="#二、构建程序" class="headerlink" title="二、构建程序"></a>二、构建程序</h2><p>从上面的思考中可以看出：</p><ol><li>程序必须有两个循环，外部循环控制总比对次数，内部循环根据索引控制哪两个元素进行比对。</li><li>然后是两个相邻元素的交换需要交换的两个元素需要借助一个额外的变量来做中间量。</li></ol><p>那么程序就出来了：</p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">11</span>, <span class="number">32</span>, <span class="number">56</span>, <span class="number">13</span>, <span class="number">66</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123; <span class="comment">//控制总循环次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123; <span class="comment">//控制索引进行比对,不理解的话仔细观察思路 1.2.3.</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">sum = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">arr[j] = sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">//输出每次排序的结果</span></span><br><span class="line">System.out.println(<span class="string">"第"</span>+(i+<span class="number">1</span>)+<span class="string">"次排序，排序结果："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> a : arr)</span><br><span class="line">System.out.print(a + <span class="string">" "</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//输出最终排序结果</span></span><br><span class="line">System.out.println(<span class="string">"排序结果："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr)</span><br><span class="line">System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/17/javabase20-px/mp.png" alt="结果符合预期">;</p><p>程序可以还改一改，从控制台输入元素的值，然后排序，这里不再举例。</p><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>冒泡排序是三个排序中最容易理解的排序，仔细体会，下一篇写快速排序，快速排序很少写，没印象，我还要学一学。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本篇学习数组三种排序方法中的冒泡排序，名字很形象了，冒泡，像汽水里的泡泡一个一个冒到液面。冒泡排序的思想是从第一个元素开始，和相邻的元素比较，如果大于后面元素就交换位置，最终完成排序。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十九）——数组查询、复制</title>
    <link href="http://www.mggblog.ink/2020/02/16/javabase19-array-s-c/"/>
    <id>http://www.mggblog.ink/2020/02/16/javabase19-array-s-c/</id>
    <published>2020-02-16T07:23:04.000Z</published>
    <updated>2020-02-21T01:12:13.442Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>本篇内容包括：数组查询指定元素，数组复制</strong></em></p><a id="more"></a><hr><h2 id="一、数组查询指定元素（binarySearch-方法）"><a href="#一、数组查询指定元素（binarySearch-方法）" class="headerlink" title="一、数组查询指定元素（binarySearch() 方法）"></a>一、数组查询指定元素（binarySearch() 方法）</h2><p>两种搜索，一个是查元素返回索引，一个是限定索引范围查元素返回索引。<br><strong>1. binarySearch(Object[] a,Object key)</strong><br>以 int 型数组为例：</p><p>使用二分搜索法来搜索指定的 int 型数组，以获得指定的值。<strong>必须在进行此调用之前对数组进行排序（通过 sort(int[]) 方法）</strong>。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。 </p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">55</span>,<span class="number">22</span>,<span class="number">34</span>,<span class="number">77</span>,<span class="number">11</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(<span class="string">"元素77的索引为："</span>+Arrays.binarySearch(arr, <span class="number">77</span>));</span><br><span class="line">System.out.println(<span class="string">"元素77的索引为："</span>+Arrays.binarySearch(arr, <span class="number">33</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/bs.png" alt="经过排序后77索引为4，如果没有返回负值"></p><p><strong>2. binarySearch(Object[] a,int fromIndex,int toIndex,Object key);</strong><br>依然以 int 型数组为例：</p><p>使用二分搜索法来搜索指定的 int 型数组的范围，以获得指定的值。<strong>必须在进行此调用之前对范围进行排序（通过 sort(int[], int, int) 方法）（jdk文档里这么说，我倒觉得不如直接完全排序清楚）</strong>。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个带有指定值的元素，则无法保证找到的是哪一个。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> fromIndex，<span class="keyword">int</span> endIndex,<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line">Arrays.sort(arr);<span class="comment">// 完全排序</span></span><br><span class="line">System.out.println(<span class="string">"元素77的索引为："</span> + Arrays.binarySearch(arr, <span class="number">1</span>, <span class="number">5</span>, <span class="number">34</span>));</span><br><span class="line">System.out.println(<span class="string">"元素11的索引为："</span> + Arrays.binarySearch(arr, <span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/bs2.png" alt="经过排序后34索引为3，范围内没11，返回负值"></p><h2 id="二、数组复制"><a href="#二、数组复制" class="headerlink" title="二、数组复制"></a>二、数组复制</h2><p>数组复制是编程时常见需求，Java 中提供了四种方法：</p><ol><li>Arrays 类的 copyOf() 方法</li><li>Arrays 类的 copyOfRange() 方法</li><li>System 类的 arraycopy() 方法</li><li>Object 类的 clone() 方法  </li></ol><p>下面分别介绍用法：</p><h3 id="copyOf-与-copyOfRange"><a href="#copyOf-与-copyOfRange" class="headerlink" title="copyOf 与 copyOfRange"></a>copyOf 与 copyOfRange</h3><p>copyOf() 方法是复制数组至指定长度，copyOfRange() 方法则将指定数组的指定长度复制到一个新数组中。<strong>注意：目标数组如果已经存在，将会被重构。</strong><br><strong>1. copyOf</strong><br>以 int 数组方法为例</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOf(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length);</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOf(arr, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">int</span>[] newArr2 = Arrays.copyOf(arr, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"完全复制的新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n未完全复制的新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr2) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/fzjg1.png" alt="复制结果"></p><p><strong>2. copyOfRange</strong><br>依然以 int 数组为例</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOf(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> fromIndex,<span class="keyword">int</span> endIndex);</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOfRange(arr,<span class="number">2</span>,<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">"从索引2-5复制的新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/fzjg2.png" alt="复制结果"></p><p>元素一共八个，但是结束索引的位置是10，新数组中补充了两个 int数组默认值 0 。</p><h2 id="三、arraycopy-方法"><a href="#三、arraycopy-方法" class="headerlink" title="三、arraycopy 方法"></a>三、arraycopy 方法</h2><p>arraycopy() 方法位于 java.lang.System 类中，其语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(dataType[] srcArray,<span class="keyword">int</span> srcIndex,<span class="keyword">int</span> destArray,<span class="keyword">int</span> destIndex,<span class="keyword">int</span> length)</span><br></pre></td></tr></table></figure><p>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的源数组到 dest 引用的目标数组，数组组件的一个子序列被复制下来。被复制的组件的编号等于 length 参数。源数组中位置在 srcPos 到 srcPos+length-1 之间的组件被分别复制到目标数组中的 destPos 到 destPos+length-1 位置。</p><p><strong>注意：目标数组不会被覆盖，相当于替换目标数组中元素的值</strong></p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = &#123;<span class="number">23</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">90</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">26</span>,<span class="number">33</span>,<span class="number">66</span>,<span class="number">77</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"原数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :arr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n目标数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">       <span class="comment">//原函数索引从 0 开始，目标函数索引从2开始，替换长度为 5</span></span><br><span class="line">System.arraycopy(arr, <span class="number">0</span>, newArr, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"\n复制后目标数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/ac.png" alt="复制结果"></p><h2 id="四、clone-方法"><a href="#四、clone-方法" class="headerlink" title="四、clone 方法"></a>四、clone 方法</h2><p>Object类方法，原数组可以直接调用，<strong>目标数组如果已经存在，将会被重构</strong>，由于方法返回值为 Object 型对象，需要强制转换为数组对象（虽然这么说，但是我用过后不用转也可以）。<br>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] newArr = arr.clone();</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr =(<span class="keyword">int</span>[]) arr.clone();</span><br><span class="line">System.out.println(<span class="string">"原数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :arr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n"</span>+arr.equals(newArr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/c.png" alt="复制结果"></p><blockquote><p>注意：以上几种方法都是浅拷贝（浅复制）。浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变。</p></blockquote><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>数组常规操作都有了，下回我们一起学三种排序，冒泡、快速、选择排序，这是算法新手的第一个拦路虎，不同语言有不同的写法，但是思路相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;strong&gt;本篇内容包括：数组查询指定元素，数组复制&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十八）——二维、多维数组及常用方法</title>
    <link href="http://www.mggblog.ink/2020/02/16/javabase18-array2/"/>
    <id>http://www.mggblog.ink/2020/02/16/javabase18-array2/</id>
    <published>2020-02-16T02:14:12.000Z</published>
    <updated>2020-02-21T01:12:11.795Z</updated>
    
    <content type="html"><![CDATA[<p><em>一维数组显然还无法满足日常数据的存储，最常用的 Excel 有行有列就可以满足普通数据的存储需要，二维数组就是表格形式，<strong>本期内容：二维数组、多维数组、数组常用方法（Arrays 类）</strong></em> </p><a id="more"></a><hr><h2 id="一、-二维数组"><a href="#一、-二维数组" class="headerlink" title="一、[二维数组]"></a>一、[二维数组]</h2><h3 id="二维数组声明"><a href="#二维数组声明" class="headerlink" title="二维数组声明"></a>二维数组声明</h3><p>将二维数组理解成一个一维数组的每个元素都是一维数组就可以了，声明方法就是加 [] :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [][] 像一维数组提到的 可以换位置  int[][] arr   或者是 int arr[][]</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">5</span>];<span class="comment">//定义五行五列的int数组</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];<span class="comment">//第二维可以不预设长度，但是用到时要先设置好，否者空指针异常。</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">int</span> arr[][]; <span class="comment">//等用到了再初始化 直接给值 或者设定长度</span></span><br></pre></td></tr></table></figure><p>Demo：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> arr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];<span class="comment">//声明时初始化</span></span><br><span class="line"><span class="keyword">int</span> arr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][]; <span class="comment">//声明时第二维没有初始化</span></span><br><span class="line"><span class="keyword">int</span> arr3[][]; <span class="comment">//声明时未初始化</span></span><br><span class="line">arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">System.out.println(arr1);</span><br><span class="line">System.out.println(arr2);</span><br><span class="line">System.out.println(arr3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase18-array2/csh.png" alt="运行结果"></p><h3 id="二维数组赋值与遍历"><a href="#二维数组赋值与遍历" class="headerlink" title="二维数组赋值与遍历"></a>二维数组赋值与遍历</h3><p>选择初始化时直接赋值或者通过索引赋值。</p><ol><li>直接赋值：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维 int 型数组</span></span><br><span class="line"><span class="keyword">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li>for 循环赋值<br>一维数组赋值时使用一个 for 循环，二维时就需要再嵌套一个 for 循环：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length;j++) &#123;</span><br><span class="line">arr[i][j] = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>赋值用了两层，那么遍历也需要两层，来练习一下。</p><p>创建一个二维数组，从控制台输入值并且遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">System.out.println(<span class="string">"请输入第"</span> + (i + <span class="number">1</span>) + <span class="string">"行第"</span> + (j + <span class="number">1</span>) + <span class="string">"列元素："</span>);</span><br><span class="line">arr[i][j] = input.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"\n~~~~~~~~~~~~"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"行第"</span> + (j + <span class="number">1</span>) + <span class="string">"列元素="</span> + arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果  </p><p><img src="/2020/02/16/javabase18-array2/fzbl.png" alt="二维数组赋值与遍历"></p><p>遍历也可以使用 foreach ,同样要使用两层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] row : arr )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> val : row)&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个数组元素都会获得了，那获取整行整列也就比较简单了。</p><p>以上面demo为例，获取第一行，只需要使用第一个索引就可以了 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] row = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : row) System.out.println(i);</span><br></pre></td></tr></table></figure><p>如果要获取某一列的值就有点麻烦了，无法直接通过获取数组来遍历了，需要使用 for 循环，访问下标,比如获取第二列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"第"</span>+<span class="number">2</span>+<span class="string">"列："</span>+arr[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、多维数组"><a href="#二、多维数组" class="headerlink" title="二、多维数组"></a>二、多维数组</h2><p>其实类似二维数组的理解，一维数组的每个元素都是一维以上的数组，如每个元素都是二维数组就是三维数组，就这么套娃套下去，只要内存顶得住，想多少维就多少维。<br>举个三维的例子，直接赋值吧，控制台输入就是三层 for 嵌套了，遍历也是三层 for 嵌套，几维就需要几个嵌套。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[][][] = &#123;&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;,&#123;&#123;<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>&#125;&#125;&#125;; <span class="comment">//多维的声明就是加 []</span></span><br></pre></td></tr></table></figure><p>这是一个2X2X2的立体数据块，这么理解就可以了，到了四维数组，脑子是理解不动了，反正将索引 [] 使用数学的排列组合就可以定位到所有元素了。</p><p>说到底无论几维数组，都是一维数组，一直嵌套而已，因为内存存储并没有那么多维度，只分栈和堆。由一维的地址指向值，变成地址指向地址，最后在指向堆内的值。</p><p>掌握一维和二维数组用法足够对付大部分问题了。</p><h2 id="三、数组常用方法"><a href="#三、数组常用方法" class="headerlink" title="三、数组常用方法"></a>三、数组常用方法</h2><p>Arrays 类为数组的处理提供了众多方法，例如排序 sort，比较 equals等，里面重载的方法众多，挑出代表，重点在于知道这些方法的使用方式，而不是掌握所有方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>asList(T… a)</td><td>返回一个受指定数组支持的固定大小的列表。</td></tr><tr><td>binarySearch(byte[] a, byte key)</td><td>使用二分搜索法来搜索指定的 byte 型数组，以获得指定的值。</td></tr><tr><td>copyOf(boolean[] original, int newLength)</td><td>复制指定的数组，截取或用 false 填充（如有必要），以使副本具有指定的长度。</td></tr><tr><td>copyOfRange(boolean[] original, int from, int to)</td><td>将指定数组的指定范围复制到一个新数组。</td></tr><tr><td>deepEquals(Object[] a1, Object[] a2)</td><td>如果两个指定数组彼此是深层相等 的，则返回 true。</td></tr><tr><td>deepHashCode(Object[] a)</td><td>基于指定数组的“深层内容”返回哈希码。</td></tr><tr><td>deepToString(Object[] a)</td><td>返回指定数组“深层内容”的字符串表示形式。</td></tr><tr><td>equals(boolean[] a, boolean[] a2)</td><td>如果两个指定的 boolean 型数组彼此相等，则返回 true。</td></tr><tr><td>fill(boolean[] a, boolean val)</td><td>将指定的 boolean 值分配给指定 boolean 型数组的每个元素。</td></tr><tr><td>hashCode(boolean[] a)</td><td>基于指定数组的内容返回哈希码。</td></tr><tr><td>sort(byte[] a)</td><td>对指定的 byte 型数组按数字升序进行排序。</td></tr><tr><td>toString(boolean[] a)</td><td>返回指定数组内容的字符串表示形式。</td></tr></tbody></table><p>这是从jdk1.6文档中获得的数据，在网上看博客时得到 jdk8 中 Arrays 得到加强，添加了许多新方法，这就需要下载jdk8 文档，我从其他博客里转载过来一段。</p><p>由于计算机硬件的飞速发展，目前几乎所有家用 PC 都是 4 核、8 核的 CPU，而服务器的 CPU 则具有更好的性能，因此 Java 8 与时俱进地增加了并发支持，并发支持可以充分利用硬件设备来提高程序的运行性能。</p><ol><li>oid parallelPrefix(xxx[] array, XxxBinaryOperator op)<br>该方法使用 op 参数指定的计算公式计算得到的结果作为新的元素。op 计算公式包括 left、right 两个形参，其中 left 代表数组中前一个索引处的元素，right 代表数组中当前索引处的元素，当计算第一个新数组元素时，left 的值默认为 1。</li><li>void parallelPrefix(xxx[] array, int fromIndex, int toIndex, XxxBinaryOperator op)<br>该方法与上一个方法相似，区别是该方法仅重新计算 fromIndex 到 toIndex 索引的元素。</li><li>void setAll(xxx[] array, IntToXxxFunction generator)<br>该方法使用指定的生成器（generator）为所有数组元素设置值，该生成器控制数组元素的值的生成算法。</li><li>void parallelSetAll(xxx[] array, IntToXxxFunction generator)<br>该方法的功能与上一个方法相同，只是该方法增加了并行能力，可以利用多 CPU 并行来提高性能。</li><li>void parallelSort(xxx[] a)<br>该方法的功能与 Arrays 类以前就有的 sort() 方法相似，只是该方法增加了并行能力，可以利用多 CPU 并行来提高性能。</li><li>void parallelSort(xxx[] a，int fromIndex, int toIndex)<br>该方法与上一个方法相似，区別是该方法仅对 fromIndex 到 toIndex 索引的元素进行排序。</li><li>Spliterator.OfXxx spliterator(xxx[] array)<br>将该数组的所有元素转换成对应的 Spliterator 对象。</li><li>Spliterator.OfXxx spliterator(xxx[] array, int startInclusive, int endExclusive)<br>该方法与上一个方法相似，区别是该方法仅转换 startInclusive 到 endExclusive 索引的元素。</li><li>XxxStream stream(xxx[] array)<br>该方法将数组转换为 Stream，Stream 是 Java 8 新增的流式编程的 API。</li><li>XxxStream stream(xxx[] array, int startInclusive, int endExclusive)<br>该方法与上一个方法相似，区别是该方法仅将 fromIndex 到 toIndex 索引的元索转换为 Stream。</li></ol><p>上面方法列表中，所有以 parallel 开头的方法都表示该方法可利用 CPU 并行的能力来提高性能。上面方法中的 xxx 代表不同的数据类型，比如处理 int[] 型数组时应将 xxx 换成 int，处理 long[] 型数组时应将 XXX 换成 long。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>虽然写了这么多方法，如果不用还是没用，脑袋记和容易网，能做到多翻文档就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;一维数组显然还无法满足日常数据的存储，最常用的 Excel 有行有列就可以满足普通数据的存储需要，二维数组就是表格形式，&lt;strong&gt;本期内容：二维数组、多维数组、数组常用方法（Arrays 类）&lt;/strong&gt;&lt;/em&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十七）——数组简介和一维数组</title>
    <link href="http://www.mggblog.ink/2020/02/15/javabase17-array/"/>
    <id>http://www.mggblog.ink/2020/02/15/javabase17-array/</id>
    <published>2020-02-15T08:30:43.000Z</published>
    <updated>2020-02-21T01:12:09.152Z</updated>
    
    <content type="html"><![CDATA[<p><em>一个数据用变量存储，如果10个人名呢，建十个变量也谈不上麻烦，那100个呢？这时候就需要引入一个新的工具来存储数据了，Java为我们提供了数组工具，<strong>本篇内容：数组简介，一维数组。</strong></em></p><a id="more"></a><hr><h2 id="一、数组简介"><a href="#一、数组简介" class="headerlink" title="一、数组简介"></a>一、数组简介</h2><p>数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。</p><h3 id="数组特征"><a href="#数组特征" class="headerlink" title="数组特征"></a>数组特征</h3><p>数组主要有三个基本特征：</p><ol><li>一个数组内部存放的数据类型一致，如一个元素是 int 型，其他元素也只能是 int 型。</li><li>数组内元素有序排列，这里说的有序是指索引有序，索引从 0 开始，最大值为元素个数 -1。</li><li>初始化数组后，数组的元素个数不能再变化。</li></ol><p>数组大概是这个样子：<br><img src="/2020/02/15/javabase17-array/sl.png" alt="一维和多维数组"></p><p>而且还有几个特点：</p><ol><li>数组可分为一维数组、二维数组和多维数组。</li><li>数值元素默认值为 0 ，引用元素默认为 null，字符型默认为’\u0000’。</li><li>数组内元素可以为数组，这也是多维数组的原理。</li><li>数组是 Array 的派生类。可以使用 Array 类方法处理数组</li></ol><h3 id="数组的内存存储"><a href="#数组的内存存储" class="headerlink" title="数组的内存存储"></a>数组的内存存储</h3><p>数组为引用类型，变量名保存在栈中，元素值保存在堆中。<br>以整型数组为例：  </p><p><img src="/2020/02/15/javabase17-array/szcf.png" alt="int 型数组内存存放"></p><p>如果初始化了一个空数组，堆内数据都为默认值。</p><h2 id="二、一维数组"><a href="#二、一维数组" class="headerlink" title="二、一维数组"></a>二、一维数组</h2><p>上面说了数组是引用类型，所以使用数组时一定要记住需要声明和初始化。</p><h3 id="定义一维数组"><a href="#定义一维数组" class="headerlink" title="定义一维数组"></a>定义一维数组</h3><p>定义数组形式有三种：</p><ol><li>直接定义和初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li><li>指定数组长度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] strs = <span class="keyword">new</span> String [<span class="number">3</span>]; <span class="comment">//当然可以先定义用的时候再初始化 如String [] strs =null ; strs = new String [3];</span></span><br></pre></td></tr></table></figure></li><li>不设定长度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[] &#123; <span class="string">"kk"</span>, <span class="string">"jj"</span> &#125;; <span class="comment">//实在鸡肋方法</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>“ [] “ 在定义中可以变位置，如 int a [] = new int[3];  </li><li>一旦声明了数组的大小，就不能再修改。这里的数组长度也是必需的，不能少。  </li></ul></blockquote></li></ol><h3 id="数组元素赋值与遍历"><a href="#数组元素赋值与遍历" class="headerlink" title="数组元素赋值与遍历"></a>数组元素赋值与遍历</h3><p>数组中每个元素都有索引且索引从 0 开始，使用中括号 [] 读取索引，如 arr[1] 代表着数组 arr 的第二个元素。赋值与遍历是与索引分不开的，写个例子练习一下，其实前面有写过。</p><p>写个Demo，通过控制台给数组赋值，然后再遍历出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String strs[] = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strs.length ;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"请输入第"</span>+(i+<span class="number">1</span>)+<span class="string">"个元素："</span>);</span><br><span class="line">strs[i] = input.nextLine();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"~~~~~~~~~~~~~~\n遍历结果为："</span>);</span><br><span class="line"><span class="keyword">for</span>(String s : strs) System.out.println(s);  <span class="comment">//只遍历数据可以用foreach ,需要通过索引操作还是for循环方便。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/15/javabase17-array/szfz.png" alt="数组元素赋值与遍历"></p><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>Jdk文档中有 Arrays 类定义了大量的数组 sort 方法，可对数组进行排序，感兴趣要去看看 Arrays 类中排序方法的源代码，在这里只说怎么用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">44</span>,<span class="number">55</span>,<span class="number">22</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">80</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) System.out.println((i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/15/javabase17-array/sx.png" alt="按升序排列"></p><p>后面会详细学三种排序算法（冒泡排序、快速排序、选择排序），先看看源码获得启发。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>数组这边要多练习，非常重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;一个数据用变量存储，如果10个人名呢，建十个变量也谈不上麻烦，那100个呢？这时候就需要引入一个新的工具来存储数据了，Java为我们提供了数组工具，&lt;strong&gt;本篇内容：数组简介，一维数组。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十六）——数据类型封装类</title>
    <link href="http://www.mggblog.ink/2020/02/15/javabase16-sjfzl/"/>
    <id>http://www.mggblog.ink/2020/02/15/javabase16-sjfzl/</id>
    <published>2020-02-15T02:00:05.000Z</published>
    <updated>2020-02-17T09:56:50.357Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>本篇内容：Integer 类、Float 类、Double 类、Number 类、Character 类、Boolean 类、 Byte 类。</strong></em></p><a id="more"></a><hr><h2 id="一、Integer-类"><a href="#一、Integer-类" class="headerlink" title="一、Integer 类"></a>一、Integer 类</h2><p>Integer 类在对象中包装了一个基本类型 int 的值。Integer 类型的对象包含一个 int 类型的字段。</p><h3 id="两个带参数构造："><a href="#两个带参数构造：" class="headerlink" title="两个带参数构造："></a>两个带参数构造：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="keyword">int</span> val);<span class="comment">//参数为整型</span></span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(String val);<span class="comment">//参数为字符串型</span></span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>byte  byteValue()</td><td>以 byte 类型返回该 Integer 的值</td></tr><tr><td>short shortValue()</td><td>以 short 类型返回该 Integer 的值</td></tr><tr><td>int  intValue()</td><td>以 int 类型返回该 Integer 的值</td></tr><tr><td>String  toString()</td><td>返回一个表示该 Integer 值的 String 对象</td></tr><tr><td>boolean  equals(Object obj)</td><td>比较此对象与指定对象是否相等</td></tr><tr><td>int  compareTo(Integer anotherlnteger)</td><td>在数字上比较两个 Integer 对象，如相等，则返回 0；小于返回负值大于返回正值</td></tr><tr><td>Integer  valueOf(String s)</td><td>返回保存指定的 String 值的 Integer 对象</td></tr><tr><td>int  parseInt(String s)</td><td>将数字字符串转换为 int 数值</td></tr></tbody></table><p>其中有几个方法我们在前面 String 与 int 互转已经用过很多次了，看看其他方法是什么个效果：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="string">"100"</span>);</span><br><span class="line">System.out.println(integer.compareTo(<span class="keyword">new</span> Integer(<span class="string">"200"</span>)));</span><br><span class="line">System.out.println(integer.doubleValue());</span><br><span class="line">System.out.println(integer.byteValue());</span><br><span class="line">System.out.println(integer.floatValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/integer.png" alt="运行结果">  </p><h3 id="Integer常量"><a href="#Integer常量" class="headerlink" title="Integer常量"></a>Integer常量</h3><p> 常用常量：</p><ul><li>MAX_VALUE：值为 231-1 的常量，它表示 int 类型能够表示的最大值。</li><li>MIN_VALUE：值为 -231 的常量，它表示 int 类型能够表示的最小值。</li><li>SIZE：用来以二进制补码形式表示 int 值的比特位数。</li><li>TYPE：表示基本类型 int 的 Class 实例。</li></ul><h2 id="二、Float-类"><a href="#二、Float-类" class="headerlink" title="二、Float 类"></a>二、Float 类</h2><p>Float 类在对象中包装一个基本类型 float 的值。Float 类型的对象包含一个 float 类型的字段。 </p><p>此外，此类提供了几种方法，可将 float 类型与 String 类型互相转换，还提供了处理 float 类型时非常有用的其他一些常量和方法。 </p><h3 id="Float-类的三个构造方法："><a href="#Float-类的三个构造方法：" class="headerlink" title="Float 类的三个构造方法："></a>Float 类的三个构造方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Float float1 = <span class="keyword">new</span> Float(<span class="keyword">double</span> value);    <span class="comment">// 以 double 类型的变量作为参数创建 Float 对象</span></span><br><span class="line">Float float2 = <span class="keyword">new</span> Float(<span class="keyword">float</span> value);    <span class="comment">// 以 float 类型的变量作为参数创建 Float 对象</span></span><br><span class="line">Float float3 = <span class="keyword">new</span> Float(String s);    <span class="comment">// 以 String 类型的变量作为参数创建 Float 对象</span></span><br></pre></td></tr></table></figure><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>Float 同样提供了与字符串之间相互转换的方法，以及用于比较的 equlas方法，来学一下其他方法：</p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>byteValue()</td><td>byte</td><td>以 byte 类型返回该 Float 的值</td></tr><tr><td>doubleValue()</td><td>double</td><td>以 double 类型返回该 Float 的值</td></tr><tr><td>floatValue()</td><td>float</td><td>以 float 类型返回该 Float 的值</td></tr><tr><td>intValue()</td><td>int</td><td>以 int 类型返回该 Float 的值（强制转换为 int 类型）</td></tr><tr><td>longValue()</td><td>long</td><td>以 long 类型返回该 Float 的值（强制转换为 long 类型）</td></tr><tr><td>shortValue()</td><td>short</td><td>以 short 类型返回该 Float 的值（强制转换为 short 类型）</td></tr><tr><td>isNaN()</td><td>boolean</td><td>如果此 Float 值是一个非数字值，则返回 true，否则返回 false</td></tr><tr><td>isNaN(float v)</td><td>boolean</td><td>如果指定的参数是一个非数字值，则返回 true，否则返回 false</td></tr><tr><td>toString()</td><td>String</td><td>返回一个表示该 Float 值的 String 对象</td></tr><tr><td>valueOf(String s)</td><td>Float</td><td>返回保存指定的 String 值的 Float 对象</td></tr><tr><td>parseFloat(String s)</td><td>float</td><td>将数字字符串转换为 float 数值</td></tr></tbody></table><p>写个 float 与 String 转化demo加深印象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"12.3"</span>;</span><br><span class="line"><span class="keyword">float</span> num = Float.parseFloat(str); <span class="comment">// 将字符串转换为 float 类型的数值</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">45.6f</span>;</span><br><span class="line">String s = Float.toString(f); <span class="comment">// 将 float 类型的数值转换为字符串</span></span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/s.png" alt="运行结果">  </p><h3 id="Float-常量"><a href="#Float-常量" class="headerlink" title="Float 常量"></a>Float 常量</h3><p>在 Float 类中包含了很多常量，其中较为常用的常量如下。</p><ul><li>MAX_VALUE：值为 1.4E38 的常量，它表示 float 类型能够表示的最大值。</li><li>MIN_VALUE：值为 3.4E-45 的常量，它表示 float 类型能够表示的最小值。</li><li>MAX_EXPONENT:有限 float 变量可能具有的最大指数。</li><li>MIN_EXPONENT：标准化 float 变量可能具有的最小指数。</li><li>MIN_NORMAL：保存 float 类型数值的最小标准值的常量，即 2-126。</li><li>NaN：保存 float 类型的非数字值的常量。</li><li>SIZE：用来以二进制补码形式表示 float 值的比特位数。</li><li>TYPE：表示基本类型 float 的 Class 实例。</li></ul><p>输出看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> max_value = Float.MAX_VALUE; <span class="comment">// 获取 float 类型可取的最大值</span></span><br><span class="line"><span class="keyword">float</span> min_value = Float.MIN_VALUE; <span class="comment">// 获取 float 类型可取的最小值</span></span><br><span class="line"><span class="keyword">float</span> min_normal = Float.MIN_NORMAL; <span class="comment">// 获取 float 类型可取的最小标准值</span></span><br><span class="line"><span class="keyword">float</span> size = Float.SIZE; <span class="comment">// 获取 float 类型的二进制位</span></span><br><span class="line">System.out.println(max_value);</span><br><span class="line">System.out.println(min_value);</span><br><span class="line">System.out.println(min_normal);</span><br><span class="line">System.out.println(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/f.png" alt="运行结果">  </p><h2 id="三、Double-类"><a href="#三、Double-类" class="headerlink" title="三、Double 类"></a>三、Double 类</h2><p>Double 类在对象中包装一个基本类型 double 的值。每个 Double 类型的对象都包含一个 double 类型的字段。 </p><p>此外，该类还提供多个方法，可以将 double 转换为 String，将 String 转换为 double，也提供了其他一些处理 double 时有用的常量和方法。</p><h3 id="两个构造方法："><a href="#两个构造方法：" class="headerlink" title="两个构造方法："></a>两个构造方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Double d = <span class="keyword">new</span> Double(<span class="keyword">double</span> value);<span class="comment">//构造一个新分配的 Double 对象，它表示基本的 double 参数</span></span><br><span class="line">Double d = <span class="keyword">new</span> Double(String s); <span class="comment">//构造一个新分配的 Double 对象，表示用字符串表示的 double 类型的浮点值。该方法与 valueOf 方法一样，可将字符串转换为 double 值。</span></span><br></pre></td></tr></table></figure><p>如果字符串有数字以外的字符就会抛出异常。</p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>这些包装类的类方法基本都差不多：<br><img src="/2020/02/15/javabase16-sjfzl/df.png" alt="Double 类常用方法"><br>double 型 与 String 互转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"123.4"</span>;</span><br><span class="line"><span class="keyword">double</span> num = Double.parseDouble(str);    <span class="comment">// 将字符串转换为 double 类型的数值</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">56.78</span>;</span><br><span class="line">String s = Double.toString(d);    <span class="comment">// 将double类型的数值转换为字符串</span></span><br><span class="line">System.out.println(Double.isNaN(d));  <span class="comment">//验证</span></span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/d.png" alt="运行结果">  </p><h3 id="Double-类常量"><a href="#Double-类常量" class="headerlink" title="Double 类常量"></a>Double 类常量</h3><p>基本个Float一样：</p><ul><li>MAX_VALUE:值为 1.8E308 的常量，它表示 double 类型的最大正有限值的常量。</li><li>MIN_VALUE：值为 4.9E-324 的常量，它表示 double 类型数据能够保持的最小正非零值的常量。</li><li>NaN：保存 double 类型的非数字值的常量。</li><li>NEGATIVE_INFINITY：保持 double 类型的负无穷大的常量。</li><li>POSITIVE_INFINITY：保持 double 类型的正无穷大的常量。</li><li>SIZE：用秦以二进制补码形式表示 double 值的比特位数。</li><li>TYPE：表示基本类型 double 的 Class 实例。</li></ul><h2 id="四、Number-类"><a href="#四、Number-类" class="headerlink" title="四、Number 类"></a>四、Number 类</h2><p>抽象类 Number 是 BigDecimal、BigInteger、Byte、Double、Float、Integer、Long 和 Short 类的超类。 </p><p>Number 的子类必须提供将表示的数值转换为 byte、double、float、int、long 和 short 的方法。 </p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p><img src="/2020/02/15/javabase16-sjfzl/n.png" alt="Number 类方法">  </p><p>因为是抽象类，不能自己实例化，要依靠子类，方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number num = <span class="keyword">new</span> Integer(); <span class="comment">//Integer 可以换为任何子类；</span></span><br></pre></td></tr></table></figure><h2 id="五、Character-类"><a href="#五、Character-类" class="headerlink" title="五、Character 类"></a>五、Character 类</h2><p>Character 类在对象中包装一个基本类型 char 的值。Character 类型的对象包含类型为 char 的单个字段。 </p><p>此外，该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然。 </p><p>编码参照 Unicode 标准，我前面说 char 是 ASCII 码，其实没什么问题，Unicode 是 ASCII 码优化来的，都是机器码。</p><h3 id="一个构造方法"><a href="#一个构造方法" class="headerlink" title="一个构造方法"></a>一个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character c = <span class="keyword">new</span> Character(<span class="keyword">char</span> value); <span class="comment">//构造一个新分配的 Character 对象，用以表示指定的 char 值。</span></span><br></pre></td></tr></table></figure><h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><p>无论是字符处理还是判断这些方法都是很重要且常用的,方法都是静态方法，可以直接用。<br><img src="/2020/02/15/javabase16-sjfzl/n2.png" alt="Character 类方法"> </p><p>写个demo，验证字符串大小写，并处理为大写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] c = &#123; <span class="string">'K'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Character.isLowerCase(c[i])) &#123;</span><br><span class="line">c[i] = Character.toUpperCase(c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch : c) &#123;</span><br><span class="line">System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/k.png" alt="运行结果"> </p><h2 id="六、Boolean-类"><a href="#六、Boolean-类" class="headerlink" title="六、Boolean 类"></a>六、Boolean 类</h2><p>Boolean 类将基本类型为 boolean 的值包装在一个对象中。一个 Boolean 类型的对象只包含一个类型为 boolean 的字段。 </p><p>此外，此类还为 boolean 和 String 的相互转换提供了许多方法，并提供了处理 boolean 时非常有用的其他一些常量和方法。 </p><h3 id="两个构造方法"><a href="#两个构造方法" class="headerlink" title="两个构造方法"></a>两个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean b = <span class="keyword">new</span> Boolean(<span class="keyword">boolean</span> value); <span class="comment">// 分配一个表示 value 参数的 Boolean 对象。 </span></span><br><span class="line">Boolean b = <span class="keyword">new</span> Boolean(String s); <span class="comment">//如果 String 参数不为 null 且在忽略大小写时等于 "true"，则分配一个表示 true 值的 Boolean 对象。否则分配一个表示 false 值的 Boolean 对象.</span></span><br></pre></td></tr></table></figure><p>注：一般情况下都不宜使用 new Boolean(boolean value) 构造方法。若不需要新新的实例，则静态工厂 valueOf(boolean) 通常是一个更好的选择。这有可能显著提高空间和时间性能。 </p><p>注： new Boolean(String s) 字符串参数只能为 true/false 不能时其他，比如 yes/no ，ok 什么的。</p><h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><p>相对其他数据类型方法少的多：<br><img src="/2020/02/15/javabase16-sjfzl/b.png" alt="Boolean 常用方法"><br>其中还有一些静态方法很少用到，不再举例。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>三个常量，经常用：</p><ul><li>TRUE：对应基值 true 的 Boolean 对象。</li><li>FALSE：对应基值 false 的 Boolean 对象。</li><li>TYPE：表示基本类型 boolean 的 Class 对象。</li></ul><h2 id="七、Byte-类"><a href="#七、Byte-类" class="headerlink" title="七、Byte 类"></a>七、Byte 类</h2><p>Byte 类将基本类型 byte 的值包装在一个对象中。一个 Byte 类型的对象只包含一个类型为 byte 的字段。 </p><p>此外，该类还为 byte 和 String 的相互转换提供了几种方法，并提供了处理 byte 时非常有用的其他一些常量和方法。 </p><h3 id="两个个构造方法"><a href="#两个个构造方法" class="headerlink" title="两个个构造方法"></a>两个个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Byte b = <span class="keyword">new</span> Byte(<span class="keyword">byte</span> value);<span class="comment">//构造一个新分配的 Byte 对象，以表示指定的 byte 值。 </span></span><br><span class="line">Byte b = <span class="keyword">new</span> Byte(String s); <span class="comment">//构造一个新分配的 Byte 对象，以表示 String 参数所指示的 byte 值。该字符串以使用基数 10 的 parseByte 方法所使用的方式被转换成一个 byte 值。</span></span><br></pre></td></tr></table></figure><p>new Byte(String s) 如果字符串不是 byte值会抛出异常。</p><h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><p>都是一些转换方法：<br><img src="/2020/02/15/javabase16-sjfzl/b1.png" alt="Byte 常用方法"><br>另外还有很多静态方法，感兴趣打开文档看看去。</p><h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><p>在 Byte 类中包含了很多的常量，其中较为常用的常量如下。</p><ul><li>MIN_VALUE：byte 类可取的最小值。</li><li>MAX_VALUE：byte 类可取的最大值。</li><li>SIZE：用于以二进制补码形式表示的 byte 值的位数。</li><li>TYPE：表示基本类 byte 的 Class 实例。</li></ul><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>内置包装类整完了，看着很多，其实并没多少东西，而且各个类方法都有互通之处，记住一个类就可以了，一般用的的方法都一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;strong&gt;本篇内容：Integer 类、Float 类、Double 类、Number 类、Character 类、Boolean 类、 Byte 类。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java内置包装类" scheme="http://www.mggblog.ink/tags/Java%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
</feed>
