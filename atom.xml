<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MggBlog</title>
  
  <subtitle>MggBlog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mggblog.ink/"/>
  <updated>2020-02-25T02:39:18.756Z</updated>
  <id>http://www.mggblog.ink/</id>
  
  <author>
    <name>Mgg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十二）——Log日志记录</title>
    <link href="http://www.mggblog.ink/2020/02/25/javabase42-log/"/>
    <id>http://www.mggblog.ink/2020/02/25/javabase42-log/</id>
    <published>2020-02-25T01:04:58.000Z</published>
    <updated>2020-02-25T02:39:18.756Z</updated>
    
    <content type="html"><![CDATA[<p><em>程序在部署运行时，不可能时时有人盯着会发生什么异常，这时候需要一个记录程序运行过程的工具，方便程序员查找关键信息，本篇介绍Java自带的日志工具类——java.util.logging。</em></p><a id="more"></a><hr><p>初学Java时经常用控制台打印 System.out.println() 来观察代码运行情况，随着代码越来越复杂，程序中就会出现很多这种代码，没有问题后再删去，非常麻烦，Java 为开发者提供了日志工具包 java.util.logging ，方便程序员快速定位问题所在。</p><p>想要快速生成日志记录，直接调用 Logger 类的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logger.getGlobal().info(<span class="string">"日志信息"</span>);</span><br></pre></td></tr></table></figure><p>Logging 把日志分为7个安全级别，等级一次降低。</p><table><thead><tr><th>等级</th><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>SEVERE</td><td>severe()</td><td>严重</td></tr><tr><td>WARNING</td><td>warning()</td><td>警告</td></tr><tr><td>INFO</td><td>info()</td><td>信息</td></tr><tr><td>CONFIG</td><td>config()</td><td>配置</td></tr><tr><td>FINE</td><td>fine()</td><td>良好</td></tr><tr><td>FINER</td><td>finer()</td><td>较好</td></tr><tr><td>FINEST</td><td>finest()</td><td>最好</td></tr></tbody></table><p>Logger 默认安全级别为 INFO ，比 INFO 级别低的日志将不显示。Logger 的默认级别定义在 jre 安装目录的 lib 下面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Limit the message that are printed on the console to INFO and above.</span><br><span class="line">java.util.logging.ConsoleHandler.level = INFO</span><br></pre></td></tr></table></figure><p>默认情况下，日志只显示三个级别，INFO、WARNING、SERVERE。<br>获得 Logger 对象后可以使用 对象.方法 来使用日志，<br>还可以使用 对象.log(Level.INFO,msg) 来调用<br>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Logger.getGlobal().info(<span class="string">"it is INFO msg"</span>);<span class="comment">// 静态方法</span></span><br><span class="line">Logger logger = Logger.getGlobal();<span class="comment">// 获取 Logger 对象</span></span><br><span class="line">logger.severe(<span class="string">"it is SEVERE msg"</span>);</span><br><span class="line">logger.log(Level.WARNING, <span class="string">"it is WARNING msg"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台：<br><img src="/2020/02/25/javabase42-log/l1.png" alt="三种使用日志的方法"></p><p>可以使用 setLevel 方法设置级别，例如logger.setLevel(Level.FINE);可以将 FINE 和更高级别的都记录下来。另外，还可以使用 Level.ALL 开启所有级别的记录，或者使用 Level.OFF 关闭所有级别的记录。</p><p>注意：如果将记录级别设计为 INFO 或者更低，则需要修改日志处理器的配置。默认的日志处理器不会处理低于 INFO 级别的信息。</p><blockquote><h3 id="修改日志管理器配置"><a href="#修改日志管理器配置" class="headerlink" title="修改日志管理器配置"></a>修改日志管理器配置</h3><p>可以通过编辑配置文件来修改日志系统的各种属性。在默认情况下，配置文件存在于 jre 安装目录下“jre/lib/logging.properties”。要想使用另一个配置文件，就要将 java.util.logging.config.file 特性设置为配置文件的存储位置，并用下列命令启动应用程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.util.logging.config.file = configFile MainClass</span><br></pre></td></tr></table></figure><p>日志管理器在 JVM 启动过程中初始化，这在 main 执行之前完成。如果在 main 中调用System.setProperty(“java.util.logging.config.file”,file) ，也会调用LogManager.readConfiguration() 来重新初始化日志管理器。</p><p>要想修改默认的日志记录级别，就需要编辑配置文件，并修改以下命令行。</p><p>.level=INFO</p><p>可以通过添加以下内容来指定自己的日志记录级别</p><p>Test.Test.level=FINE</p><p>也就是说，在日志记录器名后面添加后缀 .level。</p><p>在稍后可以看到，日志记录并不将消息发送到控制台上，这是处理器的任务。另外，处理器也有级别。要想在控制台上看到 FINE 级别的消息，就需要进行下列设置。</p><p>java.util.logging.ConsoleHandler.level=FINE</p><p>注意：在日志管理器配置的属性设置不是系统属性，因此，用-Dcom.mycompany.myapp.level=FINE启动应用程序不会对日志记录器产生任何影响。</p></blockquote><p>在开发项目过程中通常会使用开源的日志记录脚手架 log4j2 ，通过修改简单的配置文件就可以完成日志记录的工作，log4j2 后面单独写博客来说。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;程序在部署运行时，不可能时时有人盯着会发生什么异常，这时候需要一个记录程序运行过程的工具，方便程序员查找关键信息，本篇介绍Java自带的日志工具类——java.util.logging。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java异常处理" scheme="http://www.mggblog.ink/tags/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十一）——异常处理</title>
    <link href="http://www.mggblog.ink/2020/02/24/javabase41-exception/"/>
    <id>http://www.mggblog.ink/2020/02/24/javabase41-exception/</id>
    <published>2020-02-24T13:34:55.000Z</published>
    <updated>2020-02-25T00:51:15.791Z</updated>
    
    <content type="html"><![CDATA[<p><em>在程序执行中难免会遇到一些错误，且难以避免，称为异常，有时候是代码逻辑上的错误，比如用 0 做了除数，有些是物理错误，比如 jvm 内存溢出，本篇内容学习如何处理异常。</em></p><a id="more"></a><hr><h2 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h2><p>异常发生的原因通常分为：</p><ul><li>输入非法数据</li><li>寻找的资源不存在</li><li>通信终端或者 jvm 内存溢出</li></ul><p>有些是用户操作错误，有些是程序 bug ，有些是物理因素影响，通常我们把 java 程序异常分为：</p><ul><li>检查性异常：程序员无法预见用户操作产生的异常，如打开不存在的文件，该异常不可以轻易忽略。</li><li>运行时异常：可以被程序员避免的异常，如常见的空指针异常，可以在编译时被忽略。</li><li>错误：错误不是异常，脱离程序员控制的问题，代码可能会对这些错误产生影响，当栈溢出时会发生错误，编译时检查补到，但是很可能和代码有关系。</li></ul><h3 id="一、Exception-类的层次"><a href="#一、Exception-类的层次" class="headerlink" title="一、Exception 类的层次"></a>一、Exception 类的层次</h3><p>所有的异常类是从 java.lang.Exception 类继承的子类。</p><p>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</p><p>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</p><p>Error 用来指示运行时环境发生的错误。</p><p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p><p>异常类有两个主要的子类：IOException 类和 RuntimeException 类。</p><p><img src="/2020/02/24/javabase41-exception/ex.png" alt="Exception层次关系"></p><h3 id="二、java内置异常类"><a href="#二、java内置异常类" class="headerlink" title="二、java内置异常类"></a>二、java内置异常类</h3><p>Java 语言定义了一些异常类在 java.lang 标准包中。</p><p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p><p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的<em>非检查性异常</em>。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ArithmeticException</td><td>当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</td></tr><tr><td>ArrayIndexOutOfBoundsException</td><td>用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</td></tr><tr><td>ArrayStoreException</td><td>试图将错误类型的对象存储到一个对象数组时抛出的异常。</td></tr><tr><td>ClassCastException</td><td>当试图将对象强制转换为不是实例的子类时，抛出该异常。</td></tr><tr><td>IllegalArgumentException</td><td>抛出的异常表明向方法传递了一个不合法或不正确的参数。</td></tr><tr><td>IllegalMonitorStateException</td><td>抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</td></tr><tr><td>IllegalStateException</td><td>在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</td></tr><tr><td>IllegalThreadStateException</td><td>线程没有处于请求操作所要求的适当状态时抛出的异常。</td></tr><tr><td>IndexOutOfBoundsException</td><td>指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</td></tr><tr><td>NegativeArraySizeException</td><td>如果应用程序试图创建大小为负的数组，则抛出该异常。</td></tr><tr><td>NullPointerException</td><td>当应用程序试图在需要对象的地方使用 null 时，抛出该异常</td></tr><tr><td>NumberFormatException</td><td>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</td></tr><tr><td>SecurityException</td><td>由安全管理器抛出的异常，指示存在安全侵犯。</td></tr><tr><td>StringIndexOutOfBoundsException</td><td>此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小。</td></tr><tr><td>UnsupportedOperationException</td><td>当不支持请求的操作时，抛出该异常。</td></tr></tbody></table><p>下面的表中列出了 Java 定义在 java.lang 包中的<em>检查性异常类</em>。</p><table><thead><tr><th>异常</th><th>描述</th></tr></thead><tbody><tr><td>ClassNotFoundException</td><td>应用程序试图加载类时，找不到相应的类，抛出该异常。</td></tr><tr><td>CloneNotSupportedException</td><td>当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常。</td></tr><tr><td>IllegalAccessException</td><td>拒绝访问一个类的时候，抛出该异常。</td></tr><tr><td>InstantiationException</td><td>当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</td></tr><tr><td>InterruptedException</td><td>一个线程被另一个线程中断，抛出该异常。</td></tr><tr><td>NoSuchFieldException</td><td>请求的变量不存在</td></tr><tr><td>NoSuchMethodException</td><td>请求的方法不存在</td></tr></tbody></table><h3 id="三、异常方法"><a href="#三、异常方法" class="headerlink" title="三、异常方法"></a>三、异常方法</h3><p>下面的列表是 Throwable 类的主要方法:</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。</td></tr><tr><td>public Throwable getCause()</td><td>返回一个Throwable 对象代表异常原因。</td></tr><tr><td>public String toString()</td><td>使用getMessage()的结果返回类的串级名字。</td></tr><tr><td>public void printStackTrace()</td><td>打印toString()结果和栈层次到System.err，即错误输出流。</td></tr><tr><td>public StackTraceElement [] getStackTrace()</td><td>返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。</td></tr><tr><td>public Throwable fillInStackTrace()</td><td>用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中。</td></tr></tbody></table><p>这些方法常常在try catch 块中使用。</p><h3 id="四、捕获异常"><a href="#四、捕获异常" class="headerlink" title="四、捕获异常"></a>四、捕获异常</h3><p>在前面博客已有提到 try catch 块，下面单独说一下。</p><p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p><p>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//Catch 块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p><p>如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="number">11</span>/<span class="number">0</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">e.printStackTrace(); <span class="comment">//java.lang.ArithmeticException: / by zero</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获除数为 0 异常，并打印到控制台。<br><img src="/2020/02/24/javabase41-exception/e1.png" alt="捕获异常"></p><h3 id="五、多重捕获串"><a href="#五、多重捕获串" class="headerlink" title="五、多重捕获串"></a>五、多重捕获串</h3><p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。<br>多重捕获块的语法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">   <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多 catch 的情况下陈旭出现的异常会向下按顺序匹配，直到匹配到对应类型的异常。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String fileName = <span class="string">"d:\\1.txt"</span>;</span><br><span class="line">FileInputStream file = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">Byte x = (<span class="keyword">byte</span>) file.read();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException f) &#123;</span><br><span class="line">f.printStackTrace();</span><br><span class="line">System.out.println(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException i) &#123;</span><br><span class="line">i.printStackTrace();</span><br><span class="line">System.out.println(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/24/javabase41-exception/e2.png" alt="捕获异常"></p><h3 id="六、throws-throw-关键字"><a href="#六、throws-throw-关键字" class="headerlink" title="六、throws\throw 关键字"></a>六、throws\throw 关键字</h3><p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</p><p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p><p>下面方法的声明抛出一个 RemoteException 异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Method implementation</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p><p>例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">className</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> RemoteException,</span></span><br><span class="line"><span class="function">                              InsufficientFundsException</span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">// Method implementation</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//Remainder of class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、finally-关键字"><a href="#七、finally-关键字" class="headerlink" title="七、finally 关键字"></a>七、finally 关键字</h3><p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p><p>无论是否发生异常，finally 代码块中的代码总会被执行。</p><p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p><p>finally 代码块出现在 catch 代码块最后，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 异常的变量名<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 异常的变量名<span class="number">2</span>)&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">// 程序代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="number">11</span> / <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"方法执行完了"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/24/javabase41-exception/e3.png" alt="运行结果"></p><p>注意下面事项：</p><ul><li>catch 不能独立于 try 存在。</li><li>在 try/catch 后面添加 finally 块并非强制性要求的。</li><li>try 代码后不能既没 catch 块也没 finally 块。</li><li>try, catch, finally 块之间不能添加任何代码。</li></ul><h3 id="八、声明自定义异常"><a href="#八、声明自定义异常" class="headerlink" title="八、声明自定义异常"></a>八、声明自定义异常</h3><p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p><ul><li>所有异常都必须是 Throwable 的子类。</li><li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li><li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li></ul><p>可以像下面这样定义自己的异常类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只继承Exception 类来创建的异常类是检查性异常类。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DivisorIsZeroException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> divisor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DivisorIsZeroException</span><span class="params">(<span class="keyword">double</span> divisor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.divisor = divisor;</span><br><span class="line">System.out.print(<span class="string">"divisor is zero "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DivisorIsZeroException</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> DivisorIsZeroException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> DivisorIsZeroException(i);</span><br><span class="line">System.out.println(<span class="number">11</span> / i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/24/javabase41-exception/e4.png" alt="运行结果"></p><h3 id="九、通用异常"><a href="#九、通用异常" class="headerlink" title="九、通用异常"></a>九、通用异常</h3><p>在Java中定义了两种类型的异常和错误。</p><ul><li>JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</li><li>程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在程序执行中难免会遇到一些错误，且难以避免，称为异常，有时候是代码逻辑上的错误，比如用 0 做了除数，有些是物理错误，比如 jvm 内存溢出，本篇内容学习如何处理异常。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java异常处理" scheme="http://www.mggblog.ink/tags/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四十）——内部类（四种）</title>
    <link href="http://www.mggblog.ink/2020/02/24/javabase40-inner/"/>
    <id>http://www.mggblog.ink/2020/02/24/javabase40-inner/</id>
    <published>2020-02-24T08:22:26.000Z</published>
    <updated>2020-02-24T13:18:14.500Z</updated>
    
    <content type="html"><![CDATA[<p><em>在类的内部可以嵌套一个类，称为内部类，外面的类称为外部类，内部类又可以分为四种，<strong>本篇内容：成员内部类、局部内部类、匿名内部类和静态内部类。</strong></em></p><a id="more"></a><hr><p>内部类可以很好地实现隐藏，一般的非内部类是不允许有 private 与 protected 权限的，但内部类可以。内部类拥有外部类的所有元素的访问权限，接下来分别介绍四种内部类。</p><h2 id="一、成员内部类"><a href="#一、成员内部类" class="headerlink" title="一、成员内部类"></a>一、成员内部类</h2><p>最普通的内部类，定义在一个类的内部，请仔细阅读代码注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"Mgg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Out</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: usrInnerMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 调用内部类成员</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">usrInnerMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 想要使用内部类成员需要先创建内部类对象</span></span><br><span class="line">getInnerInstance().print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为创建对象方便创建一个获得内部类对象的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getInnerInstance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获得内部类对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Out.Inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Inner</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 内部类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> Feb 24, 2020</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">10</span>;<span class="comment">// 内部类私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"内部类的  print 方法"</span>);</span><br><span class="line">System.out.println(num);<span class="comment">// 默认调用内部类成员</span></span><br><span class="line">System.out.println(Out.<span class="keyword">this</span>.num);<span class="comment">// 调用外部类私有成员</span></span><br><span class="line">System.out.println(str); <span class="comment">// 调用外部类静态成员</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个测试类 Test ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Out out = <span class="keyword">new</span> Out(-<span class="number">10</span>);</span><br><span class="line">out.getInnerInstance().print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/24/javabase40-inner/t1.png" alt="通过外部类使用内部类方法"></p><p>通过例子总结成员内部类的特点：</p><ul><li>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</li><li>成员内部类拥有和外部类同名的成员变量或者方法时，默认调用的是内部类成员，外部类成员需要使用 [外部类.this.成员变量/方法] 的方法调用。</li><li>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。</li></ul><blockquote><p>通常外部类不使用 private、protected 修饰，成员内部类则可以使用的四种权限，比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。</p></blockquote><h2 id="二、局部内部类"><a href="#二、局部内部类" class="headerlink" title="二、局部内部类"></a>二、局部内部类</h2><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外部父类eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: eat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: animal eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Animal eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getCat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获得局部内部类的对象的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 局部内部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">// 重写了父类 eat方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Cat eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Cat(); <span class="comment">// 向上转型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal anim = Animal.getCat();</span><br><span class="line">anim.eat(); <span class="comment">// Cat eat</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: 局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的。</p></blockquote><h2 id="三、匿名内部类"><a href="#三、匿名内部类" class="headerlink" title="三、匿名内部类"></a>三、匿名内部类</h2><p>匿名内部类形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> &lt;类或接口&gt; ()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名类有两种实现方式：</p><ol><li>继承一个类，重写其方法。</li><li>实现一个接口（可以是多个），实现其方法。</li></ol><p>举个继承类的例子<br>Animal 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 外部父类eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: eat</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: animal eat方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Animal eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal ani = <span class="keyword">new</span> Cat() &#123;</span><br><span class="line"><span class="comment">// 重写了eat方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"匿名内部类的 eat方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">ani.eat(); <span class="comment">// 匿名内部类的 eat方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/24/javabase40-inner/t2.png" alt="使用继承完成内部匿名类"></p><p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为 Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p><h2 id="四、静态内部类"><a href="#四、静态内部类" class="headerlink" title="四、静态内部类"></a>四、静态内部类</h2><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outstatic</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> String str = <span class="string">"Hello"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Innerstatic</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println(i); //Cannot make a static reference to the non-static field i</span></span><br><span class="line">        System.out.println(str); <span class="comment">// Hello</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Outstatic out = <span class="keyword">new</span> Outstatic();</span><br><span class="line">Outstatic.Innerstatic oi = <span class="keyword">new</span>  Outstatic.Innerstatic();</span><br><span class="line">oi.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/24/javabase40-inner/t.png" alt="运行结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在类的内部可以嵌套一个类，称为内部类，外面的类称为外部类，内部类又可以分为四种，&lt;strong&gt;本篇内容：成员内部类、局部内部类、匿名内部类和静态内部类。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十九）——接口（Interface）</title>
    <link href="http://www.mggblog.ink/2020/02/24/javabase39-interface/"/>
    <id>http://www.mggblog.ink/2020/02/24/javabase39-interface/</id>
    <published>2020-02-24T02:53:16.000Z</published>
    <updated>2020-02-24T04:08:49.043Z</updated>
    
    <content type="html"><![CDATA[<p><em>抽象类中可以有抽象方法也可以有普通方法，Java为我们提供了一个专门收纳抽象方法的抽象类型——接口（interface），接口与类是两种不同的概念。</em></p><a id="more"></a><hr><p>与类对比理解：<br><strong>接口与类相似点：</strong></p><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><p><strong>接口与类的区别：</strong></p><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><p><strong>接口特性</strong></p><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li></ul><p><strong>抽象类和接口的区别</strong></p><ol><li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li><li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li><li>一个类只能继承一个抽象类，而一个类却可以实现多个接口</li></ol><h2 id="一、接口声明"><a href="#一、接口声明" class="headerlink" title="一、接口声明"></a>一、接口声明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[public] interface interface_name [extends interface1_name[, interface2_name,…]] &#123;</span><br><span class="line">    <span class="comment">// 接口体，其中可以包含定义常量和声明方法</span></span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">static</span>] [<span class="keyword">final</span>] type constant_name = value;    <span class="comment">// 定义常量</span></span><br><span class="line">    [<span class="keyword">public</span>] [<span class="keyword">abstract</span>] <span class="function">returnType <span class="title">method_name</span><span class="params">(parameter_list)</span></span>;    <span class="comment">// 声明方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上语法的说明如下：</p><ul><li>public 表示接口的修饰符，当没有修饰符时，则使用默认的修饰符，此时该接口的访问权限仅局限于所属的包；</li><li>interface_name 表示接口的名称。接口名应与类名采用相同的命名规则，即如果仅从语法角度来看，接口名只要是合法的标识符即可。如果要遵守 Java 可读性规范，则接口名应由多个有意义的单词连缀而成，每个单词首字母大写，单词与单词之间无需任何分隔符。</li><li>extends 表示接口的继承关系；</li><li>interface1_name 表示要继承的接口名称；</li><li>constant_name 表示变量名称，一般是 static 和 final 型的；</li><li>returnType 表示方法的返回值类型；</li><li>parameter_list 表示参数列表，在接口中的方法是没有方法体的。</li></ul><p>动手创建一个接口 Animal ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="comment">//全局常量动物园名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String zoo = <span class="string">"幻想乡动物园"</span>;</span><br><span class="line">    <span class="comment">//饲养员</span></span><br><span class="line">String feeder = <span class="string">"kangkang"</span>; <span class="comment">// 推荐这样定义，因为默认的修饰就是  public static final</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: run   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 run 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 jump 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span>;<span class="comment">//推荐这样定义 默认修饰为  public abstract</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: eat   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 eat 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;<span class="comment">//推荐这样定义 默认修饰为  public abstract</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: sleep   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物 sleep 抽象方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;<span class="comment">//推荐这样定义 默认修饰为  public abstract</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提醒一下：接口中的常量必须有初始值，否则无法通过编译。推荐不使用修饰符修饰，默认即可，保持代码简洁（但是团队开发中需要看规范如何要求）。</p><h2 id="二、接口的实现"><a href="#二、接口的实现" class="headerlink" title="二、接口的实现"></a>二、接口的实现</h2><p>Java允许一个类实现多个接口，以补充类单继承的不足。继承使用 extends 关键字，实现则使用 implements 关键字，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;public&gt; class &lt;class_name&gt; [extends superclass_name] [implements interface1_name[, interface2_name…]] &#123;</span><br><span class="line">    <span class="comment">// 主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上语法的说明如下：</p><ul><li>public：类的修饰符；</li><li>superclass_name：需要继承的父类名称；</li><li>interface1_name：要实现的接口名称。</li></ul><p>实现接口需要注意以下几点：</p><ol><li>实现接口与继承父类相似，一样可以获得所实现接口里定义的常量和方法。如果一个类需要实现多个接口，则多个接口之间以逗号分隔。</li><li>一个类可以继承一个父类，并同时实现多个接口，implements 部分必须放在 extends 部分之后。</li><li>一个类实现了一个或多个接口之后，这个类必须完全实现这些接口里所定义的全部抽象方法（也就是重写这些抽象方法）；否则，该类将保留从父接口那里继承到的抽象方法，该类也必须定义成抽象类。</li></ol><p>Demo：<br>创建 Lion 类 实现 Animal 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lion</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion run"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion jump"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion eat"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"Lion sleep"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</p></blockquote><p>测试类 Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Lion lion = <span class="keyword">new</span> Lion();</span><br><span class="line">lion.eat();</span><br><span class="line">lion.run();</span><br><span class="line">lion.jump();</span><br><span class="line">lion.sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2020/02/24/javabase39-interface/t.png" alt="运行结果"></p><h2 id="三、接口继承"><a href="#三、接口继承" class="headerlink" title="三、接口继承"></a>三、接口继承</h2><p>和类以一样，使用 extends 关键字继承父接口，不同的是接口支持多继承，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Biology</span>,<span class="title">Animal</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 猫爬树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: climbTree   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">climbTree</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了 Cat 接口继承了 Biology（生物），Animal（动物） 接口，只使用了一个 extends 关键字，后面的多个接口用 “ , “ 隔开。</p><p>当新建类实现 Cat 接口时，这个类就要重写 Cat 接口内的所有抽象方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;抽象类中可以有抽象方法也可以有普通方法，Java为我们提供了一个专门收纳抽象方法的抽象类型——接口（interface），接口与类是两种不同的概念。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十八）—— 抽象类</title>
    <link href="http://www.mggblog.ink/2020/02/24/javabase38-abstract/"/>
    <id>http://www.mggblog.ink/2020/02/24/javabase38-abstract/</id>
    <published>2020-02-24T01:46:42.000Z</published>
    <updated>2020-02-24T02:54:40.777Z</updated>
    
    <content type="html"><![CDATA[<p><em>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</em></p><a id="more"></a><hr><p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><h2 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h2><p>Java 中使用 abstract 来定义抽象类，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">// 名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: run</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 抽象方法 run</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: sleep   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 普通方法 sleep </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"zzzzzzzzz...."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获取名字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: setName   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 设置名字 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toString</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Animal [name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类是不能直接实例化的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Animal(<span class="string">"huahua"</span>);<span class="comment">//Cannot instantiate the type Animal</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是可以通过继承来实例化：<br>创建一个 Dog 类继承 Animal 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.print(<span class="keyword">this</span>.getName()+<span class="string">" dog run!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 Dog 类时，eclipse 会提示重写父类抽象方法，不然在类名字下面有红线。</p><p>所以当继承抽象类时必须重写父类的抽象方法。</p><p>测试类 Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Animal animal = <span class="keyword">new</span> Dog();<span class="comment">// 向上转型</span></span><br><span class="line">animal.setName(<span class="string">"huahua"</span>);</span><br><span class="line">animal.run();</span><br><span class="line">animal.sleep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><img src="/2020/02/24/javabase38-abstract/t1.png" alt="重写的run方法"></p><p>通过上面的例子可以看到：abstract 不仅可以修饰类，还可以修饰成员方法，被修饰的方法称为抽象方法，且当抽象类被继承的时候抽象方法必须被重写。</p><p>那普通类里可以有抽象方法吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> </span>&#123;<span class="comment">//The type Sheep must be an abstract class to define abstract methods</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;<span class="comment">//The abstract method eat in type Sheep can only be defined by an abstract class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到分别再类名和方法名出给出了错误提示，说明普通类里不能创建抽象方法，换句话说：<strong>若一个类里有抽象方法，那这个类肯定是抽象类</strong>。</p><p>当 Dog 类也是抽象类时:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 Dog 类虽然继承了 Animal 类，但是不需要重写父类中的抽象方法。所以任何类继承抽象类必须重写抽象方法的结论是不准确的，应该是：<strong>除了抽象类外的任何类继承抽象类必须重写父类抽象方法。</strong></p><h3 id="来做个总结："><a href="#来做个总结：" class="headerlink" title="来做个总结："></a>来做个总结：</h3><ol><li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p></li><li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p></li><li><p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</p></li><li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十七）—— instanceof 关键字详解</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase37-instanceof/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase37-instanceof/</id>
    <published>2020-02-23T15:21:41.000Z</published>
    <updated>2020-02-23T16:43:43.512Z</updated>
    
    <content type="html"><![CDATA[<p><em>严格来说 instanceof 是 Java 中的一个双目运算符，由于它是由字母组成的，所以也是 Java 的保留关键字。在 Java 中可以使用 instanceof 关键字判断一个对象是否为一个类（或接口、抽象类、父类）的实例。</em></p><a id="more"></a><hr><p>instanceof 的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj <span class="keyword">instanceof</span> Class;</span><br></pre></td></tr></table></figure><p>obj 代表某个类型的对象，Class 代表某个类或接口，当 obj 是 class 类（或接口）的实例或者子类实例时，结果 result 返回 true，否则返回 false。</p><p>instanceof 三种用法：</p><h3 id="1-判断-obj-是否为某个类对象；"><a href="#1-判断-obj-是否为某个类对象；" class="headerlink" title="1. 判断 obj 是否为某个类对象；"></a>1. 判断 obj 是否为某个类对象；</h3><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.println(cat <span class="keyword">instanceof</span> Cat);<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-判断-obj-是否为接口实现类；"><a href="#2-判断-obj-是否为接口实现类；" class="headerlink" title="2. 判断 obj 是否为接口实现类；"></a>2. 判断 obj 是否为接口实现类；</h3><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">List arrlist1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ArrayList arrlist2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(arrlist1 <span class="keyword">instanceof</span> List); <span class="comment">//true</span></span><br><span class="line">System.out.println(arrlist2 <span class="keyword">instanceof</span> List); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List 是 java.util 内的一个接口，ArrayList 是 List 的实现类。（到集合时详细讲讲）</p><h3 id="3-判断-obj-是否是某类的子类或者间接子类；"><a href="#3-判断-obj-是否是某类的子类或者间接子类；" class="headerlink" title="3. 判断 obj 是否是某类的子类或者间接子类；"></a>3. 判断 obj 是否是某类的子类或者间接子类；</h3><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Doctor 类 之前用过的直接拿来用了</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String ks;<span class="comment">//科室</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写了父类 work 医生的工作是救人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"healing petients"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getKs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKs</span><span class="params">(String ks)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ks = ks;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">Doctor doc = <span class="keyword">new</span> Doctor();</span><br><span class="line">System.out.println(doc <span class="keyword">instanceof</span> Person);<span class="comment">//true</span></span><br><span class="line">System.out.println(doc <span class="keyword">instanceof</span> Object);<span class="comment">//true</span></span><br><span class="line">System.out.println(person <span class="keyword">instanceof</span> Doctor);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Doctor 类继承了 Person 类，Person 是 Object 的子类，Doctor 是 Object 的间接子类。<br>（以上结果都验证过了放心食用。）</p><p>要注意的是 obj 必须为引用类型或者 null，不能是基本类型。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//Incompatible conditional operand types int and Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本类型编译不能通过。</p><p>当 obj = null 时和任何类比都是 false ，因为 null 不代表任何类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(str <span class="keyword">instanceof</span> Object);<span class="comment">//false</span></span><br><span class="line">System.out.println(str <span class="keyword">instanceof</span> String);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="instanceof-三目运算符"><a href="#instanceof-三目运算符" class="headerlink" title="instanceof 三目运算符"></a>instanceof 三目运算符</h3><p>假设有 Dog 类和 Cat 继承了 Animal 类，现在需要判断 obj 对象是否可转型为 Dog 对象，是返回 Dog 对象，否则返回字符串对象，提示不能转型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]  args)</span></span>&#123;</span><br><span class="line">  Animal c = <span class="keyword">new</span> Cat();<span class="comment">//复习向上转型</span></span><br><span class="line">  Animal d = <span class="keyword">new</span> Dog();</span><br><span class="line">  System.out.println(transform(c)); <span class="comment">//不是Dog类型</span></span><br><span class="line">  System.out.println(transform(d)); <span class="comment">//pers.mgg.demo.dt.Dog@15db9742</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">transform</span><span class="params">(Animal a)</span></span>&#123;</span><br><span class="line">  <span class="comment">// true 则向下转型</span></span><br><span class="line">  <span class="keyword">return</span> a <span class="keyword">instanceof</span> Dog ? (Dog)a : <span class="keyword">new</span> String(<span class="string">"不是Dog类型"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;&#125; </span><br></pre></td></tr></table></figure><p>（代码已经验证结果，放心食用）</p></blockquote><p>在类型转换时，食用 instanceof 来做逻辑判断是非常必要的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;严格来说 instanceof 是 Java 中的一个双目运算符，由于它是由字母组成的，所以也是 Java 的保留关键字。在 Java 中可以使用 instanceof 关键字判断一个对象是否为一个类（或接口、抽象类、父类）的实例。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十六）——多态</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase36-dt/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase36-dt/</id>
    <published>2020-02-23T07:12:58.000Z</published>
    <updated>2020-02-24T16:09:52.572Z</updated>
    
    <content type="html"><![CDATA[<p><em>多态性是面向对象编程的又一个重要特征，它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。</em></p><a id="more"></a><hr><p>对面向对象来说，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是大家通常所说的多态性。</p><p>Java 实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。</p><ul><li>继承：在多态中必须存在有继承关系的子类和父类。</li><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法（壳子不变，核心重新写）。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。</li></ul><blockquote><p>向上转型是java中类型转换的知识，这里说一下不再做单独解读<br>java对象的类型转换分为向上转和向下转<br><strong>1. 向上转型</strong><br>父类引用指向子类对象为向上转型，语法格式如下：<br>fatherClass obj = new sonClass();</p><p>如 Cat 类继承了 Animal 类，Cat 类向上转型的方式为：<br>Animal animal = new Cat();</p><p>向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用向上转型可以调用父类类型中的所有成员，不能调用子类类型中特有成员，最终运行效果看子类的具体实现。</p><p><strong>2.向下转型</strong><br>与向上转型相反，子类对象指向父类引用为向下转型，语法格式如下：<br>sonClass obj = (sonClass) fatherClass;</p><p>如通过 Animal 对象创建 Cat 型引用：<br>Animal animal = new Animal();<br>Cat cat = (Cat) animal;</p><p>向下转型可以调用子类类型中所有的成员，不过需要注意的是如果父类引用对象指向的是子类对象，那么在向下转型的过程中是安全的，也就是编译是不会出错误。但是如果父类引用对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现我们开始提到的 Java 强制类型转换异常，一般使用 instanceof 运算符来避免出此类错误。</p><p>在下面的多态例子中会有用到 instanceof ，这里不再举例</p></blockquote><p>继承很好理解，前面也有举过类似的例子，比如，Cat 类和 Dog 类继承 Animal 类，重写了Animal 的run方法，让Cat具有猫的跑动方式，Dog有了狗的跑动方式。</p><p>重写在前面有多次讲解，如<a href="http://www.mggblog.ink/2020/02/21/javabase30-gzff/">构造方法</a>,并且有举重写的例子，在此不再特殊说明。</p><p>举一个多态例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      show(<span class="keyword">new</span> Cat());  <span class="comment">// 以 Cat 对象调用 show 方法</span></span><br><span class="line">      show(<span class="keyword">new</span> Dog());  <span class="comment">// 以 Dog 对象调用 show 方法</span></span><br><span class="line">                </span><br><span class="line">      Animal a = <span class="keyword">new</span> Cat();  <span class="comment">// 向上转型  </span></span><br><span class="line">      a.eat();               <span class="comment">// 调用的是 Cat 的 eat</span></span><br><span class="line">      Cat c = (Cat)a;        <span class="comment">// 向下转型  </span></span><br><span class="line">      c.work();        <span class="comment">// 调用的是 Cat 的 work</span></span><br><span class="line">  &#125;  </span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Animal a)</span>  </span>&#123;</span><br><span class="line">      a.eat();  </span><br><span class="line">        <span class="comment">// 类型判断</span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)  &#123;  <span class="comment">// 猫做的事情 </span></span><br><span class="line">            Cat c = (Cat)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123; <span class="comment">// 狗做的事情 </span></span><br><span class="line">            Dog c = (Dog)a;  </span><br><span class="line">            c.work();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类 Animal </span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; </span><br><span class="line"><span class="comment">//抽象方法吃</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Cat 类 继承 Animal 并重写抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"吃鱼"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"抓老鼠"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog 类 继承 Animal 并重写抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"吃骨头"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"看家"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/23/javabase36-dt/t1.png" alt="实现多态"></p><h3 id="多态有三种实现方法："><a href="#多态有三种实现方法：" class="headerlink" title="多态有三种实现方法："></a>多态有三种实现方法：</h3><p>方式一：重写</p><p>方式二：接口(Interface,后面详细讲)</p><ol><li>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。</li><li>java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。</li></ol><p>方式三：抽象类和抽象方法<br>上面例子中 Animal 就是抽象类,类中 eat() 方法为抽象方法，有 abstract 修饰。</p><h3 id="多态的优点："><a href="#多态的优点：" class="headerlink" title="多态的优点："></a>多态的优点：</h3><ol><li>消除类型之间的耦合关系</li><li>可替换性</li><li>可扩充性</li><li>接口性</li><li>灵活性</li><li>简化性</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;多态性是面向对象编程的又一个重要特征，它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十五）—— super 关键字</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase35-super/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase35-super/</id>
    <published>2020-02-23T03:31:22.000Z</published>
    <updated>2020-02-23T06:46:41.249Z</updated>
    
    <content type="html"><![CDATA[<p><em>由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。</em></p><a id="more"></a><hr><p>super 关键字在讲 this 关键字的时候顺带说了一下，this 代表的是当前基类， super 代表父类，它的功能是：</p><ol><li>在子类的构造方法中显式的调用父类构造方法</li><li>访问父类的成员方法和变量。</li></ol><h2 id="super-调用父类构造方法"><a href="#super-调用父类构造方法" class="headerlink" title="super 调用父类构造方法"></a>super 调用父类构造方法</h2><p>新建 Animal 动物类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">System.out.println(<span class="string">"Animal 无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">System.out.println(<span class="string">"Animal 有参构造  Animal name = "</span>+name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 eclipse 快速生成的两个构造方法时，可以看到方法内部自带 super() ，当前的 super() 是指向父类 Object 的无参构造方法。</p><p>创建 Cat 类继承 Animal 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String type, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(name);</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test 测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Cat cat1 = <span class="keyword">new</span> Cat();</span><br><span class="line">Cat cat2 = <span class="keyword">new</span> Cat(<span class="string">"狸花猫"</span>, <span class="string">"花花"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase35-super/t1.png" alt="super指向父类构造"></p><p>通过 Cat 两个构造方法，我们看到通过 Super 可以分别调用父类 Animal 的有参和无参构造方法，而且和 this() 一样，要放在方法代码第一行。</p><h2 id="super-访问父类成员"><a href="#super-访问父类成员" class="headerlink" title="super 访问父类成员"></a>super 访问父类成员</h2><p>访问父类成员与 this 访问基类成员的方法一样，就是 super.成员</p><p>我们把上面的 Animal 和 Cat 类改改：</p><p>Animal 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 动物跳 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.name+<span class="string">" jump"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat 类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写父类 jump 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//其实 this 可以不写</span></span><br><span class="line">System.out.println(<span class="keyword">this</span>.type+<span class="string">" "</span> + <span class="keyword">this</span>.name + <span class="string">" jump"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String type, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line"><span class="comment">// 为父类 属性 name 赋值</span></span><br><span class="line"><span class="keyword">super</span>.name = name;</span><br><span class="line"><span class="comment">// 调用父类 jump 方法</span></span><br><span class="line"><span class="keyword">super</span>.jump();</span><br><span class="line"><span class="comment">// 基类 jump 方法</span></span><br><span class="line"><span class="keyword">this</span>.jump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat 类重写了父类 jump 方法，我们在 Cat 类 有参构造中演示用 super 和 this 分别调用父类和基类属性和方法。</p><p>测试类 Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Cat cat2 = <span class="keyword">new</span> Cat(<span class="string">"狸花猫"</span>, <span class="string">"花花"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase35-super/t2.png" alt="调用成员属性和方法"></p><p>如果是基类中独有的属性和方法，可以省略 this 。</p><blockquote><p>super() 与 this() 都不能在 static 环境中使用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十四）——继承</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase34-jc/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase34-jc/</id>
    <published>2020-02-23T02:28:42.000Z</published>
    <updated>2020-02-23T06:47:38.975Z</updated>
    
    <content type="html"><![CDATA[<p><em>继承是面向对象的三大特征之一。继承和现实生活中的“继承”的相似之处是保留一些父辈的特性，从而减少代码冗余，提高程序运行效率。</em></p><a id="more"></a><hr><p>继承需要使用 extends 关键字，用法：基类 extends 父类，extends 直译为“扩展”，其实用扩展来描述基类与父类的关系更加准确。</p><p>基类继承父类后，父类的属性和方法的权限修饰不会变，而且不能继承父类的构造方法。</p><p>举个继承的例子，创建医生 Doctor 类和病人 Patient 类继承 Person 类：</p><p>Person 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">private</span> String gender;<span class="comment">//性别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;<span class="comment">//年龄</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Doctor 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String ks;<span class="comment">//科室</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写了父类 work 医生的工作是救人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"healing petients"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getKs</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKs</span><span class="params">(String ks)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ks = ks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Patient 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Patient</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String illness;<span class="comment">//病情</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 看医生</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: seeDoctor   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeDoctor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"see a doctor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getIllness</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> illness;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIllness</span><span class="params">(String illness)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.illness = illness;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Patient p = <span class="keyword">new</span> Patient();</span><br><span class="line">p.setAge(<span class="number">20</span>);</span><br><span class="line">p.setGender(<span class="string">"男"</span>);</span><br><span class="line">p.setName(<span class="string">"Tom"</span>);</span><br><span class="line">p.setIllness(<span class="string">"头痛"</span>);</span><br><span class="line">Doctor d = <span class="keyword">new</span> Doctor();</span><br><span class="line">d.setAge(<span class="number">30</span>);</span><br><span class="line">d.setGender(<span class="string">"女"</span>);</span><br><span class="line">d.setName(<span class="string">"Jane"</span>);</span><br><span class="line">d.setKs(<span class="string">"神经内科"</span>);</span><br><span class="line">System.out.print(<span class="string">"病人"</span>+p.getName()+p.getAge()+<span class="string">"岁 "</span>+<span class="string">"因"</span>+p.getIllness()+<span class="string">"  "</span>);</span><br><span class="line">p.seeDoctor();</span><br><span class="line">System.out.print(d.getKs()+<span class="string">"医生"</span>+d.getName()+<span class="string">"  "</span>);</span><br><span class="line">d.work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase34-jc/jc.png" alt="继承了Person类中的属性和方法"></p><blockquote><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>Java 不支持多继承，只允许一个类直接继承另一个类，即子类只能有一个直接父类，extends 关键字后面只能有一个类名，但是一个类可以被多个类继承。<br>还有要注意：</p><ol><li>Object 是所有新定义类的父类，虽然没有 extends 字段。</li><li>父类中的 private 成员在子类中是不可见的，因此在子类中不能直接使用它们。如上面例子中的是通过继承了父类的 getter 和 setter 方法来给父类中的属性赋值的。</li><li>强调单继承的原因是因为 C++ 支持多继承，如果是 C++ 程序员学java很容易不注意。</li></ol></blockquote><p>最后总结继承的优缺点：<br><strong>优点：</strong></p><ol><li>实现代码共享，减少创建类的工作量，使子类可以拥有父类的方法和属性。</li><li>提高代码维护性和可重用性。</li><li>提高代码的可扩展性，更好的实现父类的方法。</li></ol><p><strong>缺点：</strong></p><ol><li>继承是侵入性的。只要继承，就必须拥有父类的属性和方法。</li><li>降低代码灵活性。子类拥有父类的属性和方法后多了些约束。</li><li>增强代码耦合性（开发项目的原则为高内聚低耦合）。当父类的常量、变量和方法被修改时，需要考虑子类的修改，有可能会导致大段的代码需要重构。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;继承是面向对象的三大特征之一。继承和现实生活中的“继承”的相似之处是保留一些父辈的特性，从而减少代码冗余，提高程序运行效率。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十三）——类的封装</title>
    <link href="http://www.mggblog.ink/2020/02/23/javabase33-fz/"/>
    <id>http://www.mggblog.ink/2020/02/23/javabase33-fz/</id>
    <published>2020-02-23T01:27:36.000Z</published>
    <updated>2020-02-23T06:48:13.835Z</updated>
    
    <content type="html"><![CDATA[<p><em>封装在讲对象和类的时候已经多多少少有说过，接下来的内容会把封装，继承，多态单独说说，有前面的预习，现在看起来就简单多了。</em></p><a id="more"></a><hr><p>封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，只能通过该类提供的方法来实现对隐藏信息的操作和访问。如计算机，内部部件非常复杂，cpu、主板、显卡、电源、内存等等，在外部套一个机箱，使用外部接口供电流流通和人机交互，机箱保护了内部部件的安全。</p><p>封装的特点：</p><ul><li>只能通过规定的方法访问数据。</li><li>隐藏类的实例细节，方便修改和实现。</li></ul><p>类封装一般包含这几步：</p><ol><li>使用 private 修饰类的内部属性；</li><li>设置公有（public）的 setter 和 getter 方法，可以修改 setter 方法对赋值进行定制化修改；</li><li>根据需要确定类方法为私有（private）还是公有（public）；</li><li>根据需要创建有参与无参构造以及 toString 方法。</li></ol><p>举个例子，创建一个 Dog 封装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: Dog  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 狗实体类  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> MGG  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> Feb 23, 2020</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 跳高</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"dog jump !"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的姓名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的姓名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的年龄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 狗的种类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 狗的种类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toString 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Dog [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", type="</span> + type + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(String name, <span class="keyword">int</span> age, String type)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 private 修饰 Dog 类属性意味着外部只能通过公有的 setter 和 getter 方法访问和修改属性，jump 方法可以在任何外部类中访问。当然还可以加入 public 修饰的静态常量和静态方法。</p><p>写一个测试类，新建一个 dog 对象，并赋予属性值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Dog dog1 = <span class="keyword">new</span> Dog();</span><br><span class="line">dog1.setName(<span class="string">"臭蛋"</span>);</span><br><span class="line">dog1.setAge(<span class="number">2</span>);</span><br><span class="line">dog1.setType(<span class="string">"金毛犬"</span>);</span><br><span class="line">Dog dog2 = <span class="keyword">new</span> Dog(<span class="string">"拖孩儿"</span>, <span class="number">3</span>, <span class="string">"哈士奇"</span>);</span><br><span class="line">System.out.println(<span class="string">"dog1的名字："</span> + dog1.getName() + <span class="string">"  年龄："</span> + dog1.getAge());</span><br><span class="line">System.out.println(<span class="string">"dog2的名字："</span> + dog2.getName() + <span class="string">"  年龄："</span> + dog2.getAge());</span><br><span class="line">dog1.jump();</span><br><span class="line">dog2.jump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/23/javabase33-fz/g.png" alt="封装类的使用"></p><p>可以在 setter 方法中设置限制，比如 age &gt; 3 否则提示超出年龄，不再举例了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;封装在讲对象和类的时候已经多多少少有说过，接下来的内容会把封装，继承，多态单独说说，有前面的预习，现在看起来就简单多了。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java继承多态" scheme="http://www.mggblog.ink/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十二）——递归算法</title>
    <link href="http://www.mggblog.ink/2020/02/22/javabase32-dg/"/>
    <id>http://www.mggblog.ink/2020/02/22/javabase32-dg/</id>
    <published>2020-02-22T12:02:13.000Z</published>
    <updated>2020-02-22T13:57:23.665Z</updated>
    
    <content type="html"><![CDATA[<p><em>递归算法简单说就是方法调用自己，对递归我也就懂这么一点，学习递归是一个很长的过程，从“学会”、“学好”到“用好”得有很长时间的积累，本篇内容简单说说什么是递归，和什么时候用递归，再深了我也不懂了，以后再补充吧。</em></p><a id="more"></a><hr><h2 id="什么是递归？"><a href="#什么是递归？" class="headerlink" title="什么是递归？"></a>什么是递归？</h2><p>我们可以把递归比喻成查词典，查到一个词解释里又有个词不懂，接着去查这个词，然后解释里又有个词不懂，就这样往复往后查，直到弄懂了所涉及到的所有词的意思，问题得以解决。</p><p>在讲<a href="http://www.mggblog.ink/2020/02/17/javabase21-kspx/">快速排序</a>时就已经用到递归算法了。</p><p>阶乘是演示递归算法的一个经典例子，顺带把普通循环的方法也弄上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DgTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归结果和用时</span></span><br><span class="line"><span class="keyword">long</span> startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">int</span> i = jc(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">long</span> endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">"10!="</span> + i + <span class="string">" 用时:"</span> + (endTime - startTime) + <span class="string">"ns"</span>);</span><br><span class="line">        <span class="comment">// 循环结果和用时</span></span><br><span class="line">startTime = System.nanoTime();</span><br><span class="line"><span class="keyword">int</span> j = jc_loop(<span class="number">10</span>);</span><br><span class="line">endTime = System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">"loop_10!="</span> + j + <span class="string">" 用时:"</span> + (endTime - startTime) + <span class="string">"ns"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jc</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 阶乘递归示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">result = i * jc(i - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jc_loop</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 阶乘循环示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jc_loop</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">result *= i;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/22/javabase32-dg/jc.png" alt="10的阶乘"></p><p>从结果中可以看出，递归算法不仅可以用普通循环算法代替，而且普通循环算法在相同结果的情况下所用时间更少。</p><h2 id="递归就是不停地入栈出栈"><a href="#递归就是不停地入栈出栈" class="headerlink" title="递归就是不停地入栈出栈"></a>递归就是不停地入栈出栈</h2><p>当一个方法调用它自身的时候，堆栈就会给新的局部变量和自变量分配内存，方法代码就带着这些新的变量从头执行。递归调用并不产生方法新的拷贝。只有参数是新的。每当递归调用返回时，旧的局部变量和自变量就从堆栈中清除（就这么不停地入栈出栈），运行从方法中的调用点重新开始。递归方法可以说是像“望远镜”一样，可以自由伸缩。</p><p>许多子程序的递归版本执行时会比它们的迭代版本要慢一点，因为它们增加了额外的方法调用的消耗。对一个方法太多的递归调用会引起堆栈崩溃。因为自变量和局部变量的存储都在堆栈中，每次调用都创建这些变量新的拷贝，堆栈有可能被耗尽。如果发生这种情况，Java 的运行时系统就会产生异常。但是，除非递归子程序疯狂运行，否则你大概不会担心这种情况。</p><h2 id="使用递归的好处"><a href="#使用递归的好处" class="headerlink" title="使用递归的好处"></a>使用递归的好处</h2><p>递归的主要优点在于：某些类型的算法采用递归比采用迭代算法要更加清晰和简单。例如快速排序算法按照迭代方法是很难实现的。还有其他一些问题，特别是人工智能问题，就依赖于递归提供解决方案。最后，有些人认为递归要比迭代简单。</p><blockquote><p>当编写递归方法时，你必须使用 if 条件语句在递归调用不执行时来强制方法返回。如果你不这么做，一旦你调用方法，它将永远不会返回。这类错误在使用递归时是很常见的。尽量多地使用 println() 语句，使你可以了解程序的进程。如果发现错误，立即中止程序运行。</p></blockquote><p>递归的学习是循序渐进的，真正完全掌握怕是要很长时间，总的来说，递归与普通循环的不同就是递归把本属于程序员思考的部分内容推给了机器。</p><p>当遇到使用普通循环不好实现的算法时，可以试着使用递归算法。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>我这个程度的写递归知识是真的不太行，在工作中很少用到，唯一用递归的场景就是遍历系统菜单，这个需求凡是数据管理系统大概都得用到，还是很重要的。对递归感兴趣的话多去看看csdn上的博客，这篇博客我以后会再补充。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;递归算法简单说就是方法调用自己，对递归我也就懂这么一点，学习递归是一个很长的过程，从“学会”、“学好”到“用好”得有很长时间的积累，本篇内容简单说说什么是递归，和什么时候用递归，再深了我也不懂了，以后再补充吧。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十一）——析构方法</title>
    <link href="http://www.mggblog.ink/2020/02/22/javabase31-xgff/"/>
    <id>http://www.mggblog.ink/2020/02/22/javabase31-xgff/</id>
    <published>2020-02-22T01:24:13.000Z</published>
    <updated>2020-02-22T14:00:48.690Z</updated>
    
    <content type="html"><![CDATA[<p><em>析构函数的作用和构造函数相反，析构函数被用来在对象不再被使用时销毁对象，释放内存空间（例如用 new 创造出来的空间），而且系统自动执行。</em></p><a id="more"></a><hr><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>Object 类中提供了一个 finalize() 方法，因为 Object 是所有类的父类，所有类都可以重写这个方法。</p><p>finalize 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//具体操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jdk 文档中给出的解释：</p><blockquote><p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 finalize 方法，以配置系统资源或执行其他清除。 </p><p>finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象 或类的终结操作执行了某个操作。finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。 </p><p>Object 类的 finalize 方法执行非特殊性操作；它仅执行一些常规返回。Object 的子类可以重写此定义。 </p><p>Java 编程语言不保证哪个线程将调用某个给定对象的 finalize 方法。但可以保证在调用 finalize 时，调用 finalize 的线程将不会持有任何用户可见的同步锁定。如果 finalize 方法抛出未捕获的异常，那么该异常将被忽略，并且该对象的终结操作将终止。 </p><p>在启用某个对象的 finalize 方法后，将不会执行进一步操作，直到 Java 虚拟机再次确定尚未终止的任何线程无法再通过任何方法访问此对象，其中包括由准备终止的其他对象或类执行的可能操作，在执行该操作时，对象可能被丢弃。 </p><p>对于任何给定对象，Java 虚拟机最多只调用一次 finalize 方法。 </p><p>finalize 方法抛出的任何异常都会导致此对象的终结操作停止，但可以通过其他方法忽略它。 </p></blockquote><p>对象的 finalize 方法具有以下特点：</p><ul><li>垃圾回收器是否会执行该方法以及何时执行该方法，都是不确定的。</li><li>finalize() 方法有可能使用对象复活，使对象恢复到可触及状态。</li><li>垃圾回收器在执行 finalize() 方法时，如果出现异常，垃圾回收器不会报告异常，程序继续正常运行。</li></ul><p>举个例子：</p><p>计数类 Count ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建对象时计数加一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟销毁对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 销毁对象是变量计数减一</span></span><br><span class="line">count--;</span><br><span class="line">System.out.println(<span class="string">"对象销毁"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数查询方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: getCount</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类 Test ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">Count c = <span class="keyword">new</span> Count();</span><br><span class="line">System.out.println(<span class="string">"创建对象c当前count："</span> + c.getCount());</span><br><span class="line">Count c2 = <span class="keyword">new</span> Count();</span><br><span class="line">System.out.println(<span class="string">"创建对象c2当前count："</span> + c2.getCount());</span><br><span class="line">c.finalize();</span><br><span class="line">System.out.println(<span class="string">"销毁对象c当前count："</span> + c2.getCount());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/22/javabase31-xgff/c.png" alt="模拟对象销毁"></p><p>finalize 方法具有不确定性，如果需要手动对象回收，使用  System.gc() 或者 Runtime.gc()  更好点。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;析构函数的作用和构造函数相反，析构函数被用来在对象不再被使用时销毁对象，释放内存空间（例如用 new 创造出来的空间），而且系统自动执行。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三十）——构造方法</title>
    <link href="http://www.mggblog.ink/2020/02/21/javabase30-gzff/"/>
    <id>http://www.mggblog.ink/2020/02/21/javabase30-gzff/</id>
    <published>2020-02-21T07:59:32.000Z</published>
    <updated>2020-02-21T14:17:54.413Z</updated>
    
    <content type="html"><![CDATA[<p><em>构造方法是类的特殊方法，创建类时会默认创建一个没有参数，没有具体方法体的构造方法，称为无参构造，还可以自己写有参数的构造完成类初始化，下面详细说说构造方法的用法。</em></p><a id="more"></a><hr><p>方法名与类名一模一样的方法称为构造方法。</p><p>构造方法有以下特点：</p><ul><li>方法名必须与类名相同</li><li>可以有 0 个、1 个或多个参数</li><li>没有任何返回值，包括 void</li><li>默认返回类型就是对象类型本身</li><li>只能与 new 运算符结合使用</li></ul><p>值得注意的是，如果为构造方法定义了返回值类型或使用 void 声明构造方法没有返回值，编译时不会出错，但 Java 会把这个所谓的构造方法当成普通方法来处理。</p><p>构造方法是在创建对象时使用的，其他任何修饰符对他来说没有意义。</p><p>构造方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String gender;</span><br><span class="line"><span class="keyword">public</span> String addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"mgg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> addr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String gender, String addr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line"><span class="keyword">this</span>.addr = addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//无参构造</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(person.name);</span><br><span class="line">System.out.println(<span class="string">"下面为有参构造："</span>);</span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Person person2 = <span class="keyword">new</span> Person(<span class="string">"kangkang"</span>,<span class="string">"男"</span>,<span class="string">"幻想乡木吉镇比利街001号"</span>);</span><br><span class="line">System.out.println(person2.name);</span><br><span class="line">System.out.println(person2.gender);</span><br><span class="line">System.out.println(person2.addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/21/javabase30-gzff/c.png" alt="两种构造用法"></p><p>提示：无参数的构造方法也被称为 Nullary 构造方法。只有编译程序自动加入的构造方法，才称为默认构造函数。如果自行编写无参数、没有内容的构造函数，就不称为默认构造函数了（只是 Nullary 构造函数）。虽然只是名词定义，不过认证考试时要区别一下两者的不同。</p><p>如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。</p><p>如果类中写了有参数的构造方法，但是还想使用 Person p = new Person() 创建对象，必须手动在 Person 中添加无参构造。</p><p>有参数的构造方法是对无参构造的重载，前面已经多次提到过了，而且根据需要，可以创建任意参数的构造方法。</p><blockquote><p>重载（overload）的含义：方法名相同参数不同，无论是参数的类别，还是参数的个数。<br>区别于重写（overwrite）：在类继承时可以重写父类方法，方法名和参数完全一致，方法体不同。另一个是在实现了类接口必须重写接口中的抽象方法。</p></blockquote><p>举一个重写父类方法的例子：</p><p>父类 Person 类，新添加了 work 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String gender;</span><br><span class="line"><span class="keyword">public</span> String addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"mgg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> addr</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String gender, String addr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line"><span class="keyword">this</span>.addr = addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: work   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 普通人工作 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Person work"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类 Doctor 类 重写了父类 work 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Doctor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写了父类 work 医生的工作是救人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"healing petients"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建父类对象</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"kangkang"</span>, <span class="string">"男"</span>, <span class="string">"幻想乡木吉镇比利街001号"</span>);</span><br><span class="line">p.work();</span><br><span class="line">Doctor doc = <span class="keyword">new</span> Doctor();</span><br><span class="line">doc.work();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/21/javabase30-gzff/cx.png" alt="重写父类 work 方法"></p><p>重写与重载的区别要记牢，虽然没人去抓概念，但是如果在什么场合说混了那就太难堪了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;构造方法是类的特殊方法，创建类时会默认创建一个没有参数，没有具体方法体的构造方法，称为无参构造，还可以自己写有参数的构造完成类初始化，下面详细说说构造方法的用法。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十九）—— main() 方法</title>
    <link href="http://www.mggblog.ink/2020/02/21/javabase29-main/"/>
    <id>http://www.mggblog.ink/2020/02/21/javabase29-main/</id>
    <published>2020-02-21T01:45:43.000Z</published>
    <updated>2020-02-21T02:37:26.484Z</updated>
    
    <content type="html"><![CDATA[<p><em>Java中，mian 方法是所有程序的入口，与其他方法有很大的不同，从开始到现在 main 方法已经用过很多次了，但是从来没有详细说明过 main 方法的特点，本篇内容来补充这个知识点。</em></p><a id="more"></a><hr><h2 id="Java-main-方法"><a href="#Java-main-方法" class="headerlink" title="Java main() 方法"></a>Java main() 方法</h2><p>main 方法有只有一种写法，格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 main 方法代码发现：</p><ul><li>main 方法是公有的；</li><li>main 方法是静态方法；（在当前类的 main 里调用其他方法，那这个方法也必须是 static 修饰）</li><li>main 方法没有返回值；</li><li>main 方法的参数是字符串数组。（用来接收执行 Java 程序的命令行参数。命令行参数作为字符串，按照顺序依次对应字符串数组中的元素。）</li></ul><p>一定要注意，main 方法的定义中只有参数名 args 是可以改变的，其他都是固定格式，不能添不能少。但是我们约定参数名和java规范中的名字一样，所以 args 也是不能改的。</p><p>注意因为 static 修饰，main 方法里调用的所有方法必是静态方法，否者无法调用，举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">dogJump();</span><br><span class="line">catJump();<span class="comment">//Cannot make a static reference to the non-static method catJump() from the type Test</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dogJump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Dog jump!!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">catJump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Cat jump!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个类，下面通过 Windows 命令行工具，查看 main 方法里参数的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = args.length; <span class="comment">// 获取参数数量</span></span><br><span class="line">System.out.println(<span class="string">"一共有 "</span> + n + <span class="string">" 个参数"</span>);</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 判断参数个数是否大于0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">System.out.println(args[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行过程：<br><img src="/2020/02/21/javabase29-main/m.png" alt="通过控制台输入参数"></p><p>可以发现 main 方法可以通过控制台传递字符串参数。</p><p>一个程序只能有一个 main 方法，通常做测试用，比如写了几个类，需要一个入口来测试类中方法是否正确。我们称为单元测试，单元测试在开发中非常重要。</p><p>后面会遇到 Junit ，一个专门用来做单元测试的工具，到时候再详细介绍用法。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Java中，mian 方法是所有程序的入口，与其他方法有很大的不同，从开始到现在 main 方法已经用过很多次了，但是从来没有详细说明过 main 方法的特点，本篇内容来补充这个知识点。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十八）——类中常见关键字（访问权限、static、final）</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase28-lgjz/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase28-lgjz/</id>
    <published>2020-02-20T11:49:51.000Z</published>
    <updated>2020-02-21T02:27:38.571Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇把类中常用的关键字单独拿出来说说，<strong>内容包含：访问权限控制关键字 private、friendly、protected、public，静态关键字 static，完结器 final 关键字</strong></em></p><a id="more"></a><hr><h2 id="一、访问权限控制修饰符（private、friendly、protected、public）"><a href="#一、访问权限控制修饰符（private、friendly、protected、public）" class="headerlink" title="一、访问权限控制修饰符（private、friendly、protected、public）"></a>一、访问权限控制修饰符（private、friendly、protected、public）</h2><p>前面提到，类是对对象的封装，既然是封装，那出发点肯定是不想让箱子外部随机接触箱内，所以设置访问权限，想让你看的给你看，不想的外部怎么都访看不见。</p><ol><li><p>类修饰符：public，default（不用写出来）<br>这四个关键字并不是随处都能用，其中 public 只能用在类声明中，在类声明中，除了使用 public 还可以什么都不写，不写的话权限默认为 default ，两者的不同为：<strong>public 声明的类可以被其他包调用，default（不加修饰符） 权限的类只能在包内使用</strong>。</p></li><li><p>成员变量与成员方法修饰符（private、friendly、protected、public）</p></li></ol><p>四种修饰符权限差异：</p><table><thead><tr><th>访问范围</th><th>private</th><th>friendly(默认)</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类</td><td>可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>同一包中的其他类</td><td>不可访问</td><td>可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的子类</td><td>不可访问</td><td>不可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>不同包中的非子类</td><td>不可访问</td><td>不可访问</td><td>不可访问</td><td>可访问</td></tr></tbody></table><p>简短叙述一下（权限大小也按1.2.3.4.排，越往下越大）：</p><ol><li><p>private<br>用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用。</p></li><li><p>friendly<br>如果一个类没有访问控制符，说明它具有默认的访问控制特性。这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，即使其他包中有该类的子类。这种访问特性又称为包访问性（package private）。</p></li><li><p>protected<br>用保护访问控制符 protected 修饰的类成员可以被三种类所访问：该类自身、与它在同一个包中的其他类以及在其他包中的该类的子类。使用 protected 修饰符的主要作用，是允许其他包中它的子类来访问父类的特定属性和方法，否则可以使用默认访问控制符。</p></li><li><p>public<br>当一个类被声明为 public 时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用 import 语句引入 public 类，就可以访问和引用这个类。</p></li></ol><blockquote><p>每个程序的主类必须是 public 。</p></blockquote><p>在讲类的时候里面有提到 private 与 public的用法，其他两个用法实在很少用到，做项目不可能吧权限细分的那么清楚，找很多麻烦。</p><h2 id="二、static-关键字（加一个静态导入的知识）"><a href="#二、static-关键字（加一个静态导入的知识）" class="headerlink" title="二、static 关键字（加一个静态导入的知识）"></a>二、static 关键字（加一个静态导入的知识）</h2><p>类中的属性和方法概括为类成员，带有 static 关键字修饰的称为：静态成员，静态成员为类所有，不依赖与任何对象，只要类被加载，就可以被访问。</p><p>前面有用到了 static 修饰的属性和方法，调用语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名.方法/属性;</span><br></pre></td></tr></table></figure><p>再举个例子加深印象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String name = <span class="string">"kangkang"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: run   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 男孩跑步 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">" is running！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: jump   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 男孩跳 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(name + <span class="string">" is jumpping！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//创建两个 boy 对象</span></span><br><span class="line">Boy boy1 = <span class="keyword">new</span> Boy();</span><br><span class="line">Boy boy2 = <span class="keyword">new</span> Boy();</span><br><span class="line">System.out.println(<span class="string">"静态变量 name 值："</span>+Boy.name);</span><br><span class="line">boy1.jump();</span><br><span class="line">boy2.jump();</span><br><span class="line"><span class="comment">// 在这里改变静态变量值</span></span><br><span class="line">Boy.name = <span class="string">"jhon"</span>;</span><br><span class="line">System.out.println(<span class="string">"------静态变量值改变--------"</span>);</span><br><span class="line">System.out.println(<span class="string">"静态变量 name 值："</span>+Boy.name);</span><br><span class="line">boy1.jump();</span><br><span class="line">boy2.jump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/20/javabase28-lgjz/s.png" alt="静态成员不依赖对象"></p><p>我们发现，静态变量值改变时，使用它的每一个对象也会作出相应改变，如果是普通成员变量的话，不同对象的值是没有干扰的。</p><p>静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。</p><p>如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。</p><blockquote><p>除了静态方法静态变量，类中还可以有静态代码块，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">staticCode</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Boy.i); <span class="comment">//结果为 11</span></span><br></pre></td></tr></table></figure><p>在直接使用时，i 已经自加过了，提高了代码效率？我实在不知道有什么用。</p></blockquote><blockquote><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>在 JDK 1.5 之后增加了一种静态导入的语法，用于导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法。如果一个类中的方法全部是使用 static 声明的静态方法，则在导入时就可以直接使用 import static 的方式导入。</p><p>静态导入使用 import static 语句，静态导入也有两种语法，分别用于导入指定类的单个静态成员变量、方法和全部静态成员变量、方法，其中导入指定类的单个静态成员变量、方法的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.ClassName.fieldName|methodName;</span><br></pre></td></tr></table></figure><p>上面语法导入 package.ClassName 类中名为 fieldName 的静态成员变量或者名为 methodName 的静态方法。例如，可以使用import static java.lang.System.out;语句来导入 java.lang.System 类的 out 静态成员变量。</p><p>导入指定类的全部静态成员变量、方法的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> <span class="keyword">package</span>.ClassName.*;</span><br></pre></td></tr></table></figure><p>上面语法中的星号只能代表静态成员变量或方法名。</p><p><strong>说那么多，其实只需与普通 import 对比下就行了，一句话： import 和 import static 的作用，使用 import 可以省略写包名，而使用 import static 可以省略类名。</strong><br>而且在开发过程中，没什么机会让你手动导入。除了遇到大佬自己写的工具类。</p></blockquote><h2 id="三、final-关键字"><a href="#三、final-关键字" class="headerlink" title="三、final 关键字"></a>三、final 关键字</h2><p>final 的意义就是无法再改变，声明为多少就是多少。</p><p>final 有如下限制作用：</p><ul><li><p>如果 final 用在了变量前面，变量就变为常量，无法在改变，</p></li><li><p>如果 final 加在方法前面，表明方法无法被重写，重写的意思就是方法名和参数一样，方法体不一样。</p></li><li><p>如果 final 加在了类前，表明类无法被继承。</p></li></ul><p>但是在使用时应该注意一下几点：</p><ol><li>在变量中，如果使用 final ，成为常量，可以不赋值，但是在使用前必须先赋值，赋值之后就无法改变了。</li><li>对基本类型变量来说是其值不可变，而对对象引用类型变量来说其引用不可再变。</li><li>在开发中我们约定，如果使用 final 定义常量，常量的名字使用全大写字符，如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IP = <span class="string">"192.168.1.1"</span>;</span><br></pre></td></tr></table></figure></li><li>如果 final 修饰了类，就不需要在类方法前加 final 操作没有意义。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本篇把类中常用的关键字单独拿出来说说，&lt;strong&gt;内容包含：访问权限控制关键字 private、friendly、protected、public，静态关键字 static，完结器 final 关键字&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十七）——注释</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase27-doc/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase27-doc/</id>
    <published>2020-02-20T07:24:38.000Z</published>
    <updated>2020-02-21T01:14:44.977Z</updated>
    
    <content type="html"><![CDATA[<p><em>学过了类的各种东西，现在说一个很简单但是很重要的东西，就是注释——javadoc，简单是因为只需要按几下按键就出来了，重要是因为，有注释会给予看程序的其他人极大的方便，其他人不用去猜你写这个类做啥用，这个方法干嘛用。大大提高了程序的可读性，维护起来容易多了。</em></p><a id="more"></a><hr><p>虽然从事开发工作时间不长，但是从我敲第一行代码开始就养成写注释的习惯了，几乎每个方法和类都会写注释，毕竟写个注释用不了几秒。也有遇到大佬不写注释的，类也不写，方法也不写，用到时都要去猜去试，浪费不少时间，大概这就是大佬把，哈哈哈。下面演示一下在 Eclipse 下如何快速生成注释。</p><p>生成注释前必须要先做配置，默认的注释过于简单，配置流程如下：<br><img src="/2020/02/20/javabase27-doc/s1.png" alt="步骤1"><br><img src="/2020/02/20/javabase27-doc/s2.png" alt="步骤2"><br><img src="/2020/02/20/javabase27-doc/s3.png" alt="步骤3"><br><img src="/2020/02/20/javabase27-doc/s4.png" alt="步骤4"><br><img src="/2020/02/20/javabase27-doc/s5.png" alt="步骤5"></p><p>我把我的配置写出来，我就配置了三个，你也可以去百度搜“eclipse 注释模板”挑选自己喜欢的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Files 文件</span></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * All rights Reserved, Designed By www.mggblog.ink</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>:  $&#123;file_name&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> $&#123;package_name&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:Description  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: mgg     </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>:   $&#123;date&#125; $&#123;time&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Copyright</span>: </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Types   类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: $&#123;type_name&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;todo&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> $&#123;user&#125;  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> $&#123;date&#125;  </span></span><br><span class="line"><span class="comment"> * $&#123;tags&#125;  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Methods  方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: $&#123;enclosing_method&#125;   </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: $&#123;todo&#125; </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: $&#123;user&#125;  </span></span><br><span class="line"><span class="comment"> * $&#123;tags&#125;        </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>下面说如何用，上图：<br><img src="/2020/02/20/javabase27-doc/demo.gif" alt="/**+回车"></p><p>然后编辑 Description ,描述作用。方法上生成注释的操作也是一样的，不举例了。</p><p>最后效果</p><p><img src="/2020/02/20/javabase27-doc/sl.png" alt="注释示例"></p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>一定要养成写注释的好习惯啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;学过了类的各种东西，现在说一个很简单但是很重要的东西，就是注释——javadoc，简单是因为只需要按几下按键就出来了，重要是因为，有注释会给予看程序的其他人极大的方便，其他人不用去猜你写这个类做啥用，这个方法干嘛用。大大提高了程序的可读性，维护起来容易多了。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十六）——创建对象（显式、隐式）</title>
    <link href="http://www.mggblog.ink/2020/02/20/javabase26-newobj/"/>
    <id>http://www.mggblog.ink/2020/02/20/javabase26-newobj/</id>
    <published>2020-02-20T03:09:14.000Z</published>
    <updated>2020-02-21T01:14:43.609Z</updated>
    
    <content type="html"><![CDATA[<p><em>把对象创建的过程称为类的实例化，如果类没有实例化，无论是类属性还是方法都无法使用（除了 static 修饰的），本篇内容学习如何创建对象，<strong>主要内容有：三种显式、一种隐式创建方法</strong></em></p><a id="more"></a><hr><h2 id="一、显式创建对象"><a href="#一、显式创建对象" class="headerlink" title="一、显式创建对象"></a>一、显式创建对象</h2><p>显式创建对象有四种：new 、java.lang.Class 类方法创建、对象 clone 方法、 java.io.ObjectlnputStream 对象的 readObject() 方法。</p><h3 id="1-new-关键字创建对象"><a href="#1-new-关键字创建对象" class="headerlink" title="1.new 关键字创建对象"></a>1.new 关键字创建对象</h3><p>这个是最常用的方式，前面也多次使用，这里不再多叙述，new 的语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型 对象名 = <span class="keyword">new</span> 类型();</span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line">String str = <span class="keyword">new</span> String();</span><br><span class="line"><span class="comment">// 有时候用不着对象名 ——匿名对象</span></span><br><span class="line">System.out.print(<span class="keyword">new</span> String(<span class="string">"This is kangkang!!"</span>));</span><br></pre></td></tr></table></figure><blockquote><p><strong>匿名对象</strong><br>没有明确给出对象名，普通对象需要同时在栈和堆中开辟空间，匿名对象只占用堆空间，而且匿名对象时一次性的，如果当前方法里值与需要用到一次对象，可以采用这种写法，通常作为参数使用。</p></blockquote><h3 id="2-使用-newlnstance-方法"><a href="#2-使用-newlnstance-方法" class="headerlink" title="2.使用 newlnstance() 方法"></a>2.使用 newlnstance() 方法</h3><p>借助了 java.lang.Class 类提供的 newInstance 方法，首先创建 Class 对象（注意区分 Class 与 class，Class是一个具体的类，class 是类的概念，一个关键字），Class 对象无法通过 new 新建，需要借助静态方法 .forName 完成对象创建。Class 类功能很强大，支持了 java 中很重要的 “反射机制” ，反射机制后面单独讲。</p><p>用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.Class</span></span><br><span class="line">Class 类对象名称 = Class.forName(要实例化的类全称);</span><br><span class="line">类名 对象名 = (类名)Class类对象名称.newInstance();</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// forname 中参数 一定是类的完整路径，要带包名</span></span><br><span class="line">Class cls = Class.forName(<span class="string">"demo_class.Student"</span>);</span><br><span class="line">Student stu = (Student) cls.newInstance();</span><br><span class="line">stu.study();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到了昨天建的 Student 类，要提醒的是，使用 forName 时，参数是类的完整路径，一定要带包名。</p><blockquote><p>提到包名就要说说包命名规范，通常为 com.公司.项目.[package]…. 这个 com 是 company 的缩写，说明是公司项目，那个人项目呢？</p><p>包命名有如下规范：</p><ol><li>个人的项目命名：</li></ol><ul><li>indi ： 个体项目（individual），指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。 包名为“indi.发起者名.项目名.模块名……”</li><li>onem ： 单人项目（one-man），推荐用indi，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。 包名为“onem.发起者名.项目名.模块名……”</li><li>pers ： 个人项目（personal），指个人发起，独自完成，可分享的项目，copyright主要属于个人。 包名为“pers.个人名.项目名.模块名.……”</li><li>priv ： 私有项目（private），指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。 包名为“priv.个人名.项目名.模块名.……”</li></ul><ol start="2"><li>团体的项目命名:</li></ol><ul><li>team： 团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有。 包名为“team.团队名.项目名.模块名.……”</li><li>com ： 公司项目，copyright由项目发起的公司所有。 包名为“com.公司名.项目名.模块名.……”</li></ul><p>比如上面的测试类所处的包正确的包名为：pers.mgg.demo.test </p></blockquote><p>Student 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do homework"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现接口后 重写 clone方法  右击→ Source → Override/Implement Methods</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="/2020/02/20/javabase26-newobj/gi.png" alt="使用 newInstance 创建 Student 对象"></p><h3 id="3-使用-clone-方法"><a href="#3-使用-clone-方法" class="headerlink" title="3.使用 clone() 方法"></a>3.使用 clone() 方法</h3><p>该方法很少用，使用该方法创建对象时，要实例化的类必须继承 java.lang.Cloneable 接口。 调用对象的 clone() 方法创建对象的语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名对象名 = (类名)已创建好的类对象名.clone();</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">Student stu2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stu2 = (Student) stu1.clone();</span><br><span class="line">&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">stu2.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2020/02/20/javabase26-newobj/gi.png" alt="异常处理"></p><blockquote><p>代码中的 try  catch  是异常处理，详细内容到后面异常处理再说，这里稍微提一下：</p><p><img src="/2020/02/20/javabase26-newobj/yc.png" alt="异常处理"></p><p><img src="/2020/02/20/javabase26-newobj/yc2.png" alt="两种不同的异常处理"></p><p>在实际开发中用 try catch 比较多</p></blockquote><h2 id="二、隐式创建"><a href="#二、隐式创建" class="headerlink" title="二、隐式创建"></a>二、隐式创建</h2><p>隐式创建其实前面经常用了，举个例子就是 String str = “oh! awesome!!” 。</p><p>以及当使用字符串拼接时  str = str+”come on”  也会隐式创建对象，str 已经不是原来的 str 了。</p><p>最后 java 虚拟机在加载 .class 文件时，都会创建一个上面说到的 java.lang.Class 对象，用来封装类在方法区内的数据结构。</p><blockquote><p>垃圾回收（jvm gc）<br>每个对象都是相互独立的，在内存中占有独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成了垃圾，由 Java 虚拟机自带的垃圾回收机制处理。</p></blockquote><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>显式的三种方法，前两种要掌握，clone 方法要了解，隐式就没什么可说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;把对象创建的过程称为类的实例化，如果类没有实例化，无论是类属性还是方法都无法使用（除了 static 修饰的），本篇内容学习如何创建对象，&lt;strong&gt;主要内容有：三种显式、一种隐式创建方法&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十五）—— this 关键字</title>
    <link href="http://www.mggblog.ink/2020/02/19/javabase25-this/"/>
    <id>http://www.mggblog.ink/2020/02/19/javabase25-this/</id>
    <published>2020-02-19T10:09:17.000Z</published>
    <updated>2020-02-21T01:14:17.756Z</updated>
    
    <content type="html"><![CDATA[<p><em>this 关键字是 Java 常用的关键字，可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。<strong>本篇包括：this.属性，this.方法，this.构造方法</strong></em></p><a id="more"></a><hr><h2 id="一、this-属性名"><a href="#一、this-属性名" class="headerlink" title="一、this.属性名"></a>一、this.属性名</h2><p>大部分时候，普通方法访问其他方法、成员变量时无须使用 this 前缀，<strong>但如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用 this 前缀</strong>。</p><p>其实在上一篇说 getter setter的时候已经有遇到这个关键字了，<br>举一个 Person 类的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String gender; <span class="comment">//性别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> tall;  <span class="comment">//身高</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了加上 getter 和 setter 这次加点新的，添一个构造方法和一个 toString。</p><p>直接快速生成：<br><img src="/2020/02/19/javabase25-this/pc.png" alt="快速生成三个方法"></p><p>因为是第一次碰到构造方法，请自己仔细体会方法内部信息</p><p>此时 Person 类变成了 完全体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String gender; <span class="comment">//性别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> tall;  <span class="comment">//身高</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带参数构造方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gender</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tall</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender, <span class="keyword">double</span> tall)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line"><span class="keyword">this</span>.tall = tall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTall</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> tall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTall</span><span class="params">(<span class="keyword">double</span> tall)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tall = tall;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", gender="</span> + gender + <span class="string">", tall="</span> + tall + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，构造方法和 setter 方法内部都有 this 关键字，通过 this.属性 让参数变为类属性的值，编写一个测试类来看一下构造方法的作用。</p><blockquote><p>补充一个问题,当类中只有一个有参构造：<br><img src="/2020/02/19/javabase25-this/t.png" alt="注意只有一个有参构造的情况"></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">// 利用有参数的构造方法直接给Person类对象属性赋值</span></span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"kangkang"</span>, <span class="number">10</span>, <span class="string">"男"</span>, <span class="number">110</span>);</span><br><span class="line">System.out.println(person.getName());</span><br><span class="line">System.out.println(person.getAge());</span><br><span class="line">System.out.println(person.getGender());</span><br><span class="line">System.out.println(person.getTall());</span><br><span class="line"><span class="comment">// 直接使用toString</span></span><br><span class="line">System.out.println(person.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/19/javabase25-this/t1.png" alt="输出结果"></p><p>很明显，通过类中的有参构造，为 Person 类属性赋值，而在构造方法中正是使用了 this 关键字（仔细体会开头的那句话：<strong>如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用 this 前缀</strong>）</p><p><em>提示：当一个类的属性（成员变量）名与访问该属性的方法参数名相同时，则需要使用 this 关键字来访问类中的属性，以区分类的属性和方法中的参数。</em></p><h2 id="二、this-方法名"><a href="#二、this-方法名" class="headerlink" title="二、this.方法名"></a>二、this.方法名</h2><p>this 关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。</p><p>新建一个 Student 类，让其中一个方法调用另一个方法，具体流程为吃晚饭，写作业，睡觉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String name = <span class="string">"Tom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"do homework"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 吃饭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"have a dinner"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 睡觉</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.eat();</span><br><span class="line"><span class="keyword">this</span>.study();</span><br><span class="line">System.out.println(<span class="string">"do sleep"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(Student.name);</span><br><span class="line">stu.sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看结果：<br><img src="/2020/02/19/javabase25-this/t2.png" alt="运行结果"></p><p>在 Student 类中的sleep 方法使用this 关键字调用了其他两个方法，在测试类中只需要调用一个 sleep 就可以完成 三个方法的操作。</p><p>我们发现当 sleep 方法改为这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">eat();</span><br><span class="line">study();</span><br><span class="line">System.out.println(<span class="string">"do sleep"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新运行测试类，发现输出结果一样，<strong>省略 this 前缀只是一种假象，虽然程序员省略了调用 eat()、study() 方法之前的 this，但实际上这个 this 依然是存在的。</strong></p><blockquote><p>注意：对于 static 修饰的方法而言，可以使用类来直接调用该方法，如果在 static 修饰的方法中使用 this 关键字，则这个关键字就无法指向合适的对象。所以，static 修饰的方法中不能使用 this 引用。并且 Java 语法规定，静态成员不能直接访问非静态成员。</p></blockquote><h2 id="三、this-访问构造方法"><a href="#三、this-访问构造方法" class="headerlink" title="三、this 访问构造方法"></a>三、this 访问构造方法</h2><p>将 Student 改为这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 学习</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">this</span>.name+ <span class="string">"  do homework"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无参构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="string">"Tom"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有参构造</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">stu.study();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/19/javabase25-this/t3.png" alt="输出结果"></p><p>无参构造直接通过 this(“Tom”) 给私有属性赋予了值， this(“Tom”) 与 this.Student(“Tom”) 等价，且只能在构造方法中使用，也必是第一条代码。</p><blockquote><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>当在创建无参构造时，会发现方法中有 super();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super 关键字是指向父类的引用，前面说过创建的每一个类都会继承 Object 类，刚才 this() 的用法为指向自己个构造，那么 super() 就会指向父类构造方法，我认为这解释了为什么创建基类对象后，父类方法可以直接使用。</p><p>与 this() 一样，只能在构造方法中使用，也必是第一条代码。</p></blockquote><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>在正常的开发中，用到实体类都会有专门的软件生成，不用自己手写，因为写实体类实在浪费时间。实体类一建生成可以让程序员吧时间放在逻辑代码部分，提高开发效率。但是作为新手的话，还是多写写，多多体会。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;this 关键字是 Java 常用的关键字，可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。&lt;strong&gt;本篇包括：this.属性，this.方法，this.构造方法&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十四）——类的概念、定义、类属性、类方法（含可变参数）</title>
    <link href="http://www.mggblog.ink/2020/02/19/javabase24-oop-class/"/>
    <id>http://www.mggblog.ink/2020/02/19/javabase24-oop-class/</id>
    <published>2020-02-19T00:47:36.000Z</published>
    <updated>2020-02-21T04:12:27.348Z</updated>
    
    <content type="html"><![CDATA[<p><em>在面向对象中，类和对象是最基本、最重要的组成单元。类实际上是表示一个客观世界某类群体的一些基本特征抽象。对象就是表示一个个具体的东西。所以说类是对象的抽象，对象是类的具体。</em></p><a id="more"></a><hr><h2 id="一、类的概念"><a href="#一、类的概念" class="headerlink" title="一、类的概念"></a>一、类的概念</h2><p>类（Class） 就是类别，在上一篇说封装时我们提到类是对象的封装，对象是自然界客观存在的个体，而类是一个概念，并不是可以看得见摸得着的。无论是进口法拉利、兰博基尼、还是国产长城、吉利都属于汽车，汽车是对这些对象的描述，都有外壳、车轮、底盘、方向盘、发动机等，都可以向前跑，向后倒车，鸣喇叭、刹车。类与对象的关系就是 汽车 与这些具体实物的关系，由此可见。</p><ul><li>类是概念模型，定义对象的所有特性和所需的操作，对象是真实的模型，是一个具体的实体。</li><li>类是描述了一组有相同特性（属性）和相同行为（方法）的一组对象的集合。</li></ul><p>我们买车的时候会去了解，动发动机怎么样，座椅舒不舒服，悬挂系统稳不稳，轮胎大小等具体信息，这些事对象的属性。还要去试驾开起来如何，体现了对象中的方法。不同的车属性和驾驶体验各有不同。</p><ul><li>对象或实体所拥有的特征在类中表示时称为类的属性。</li><li>对象执行的操作称为类的方法。</li></ul><p><strong>类是构造面向对象程序的基本单位</strong>，是抽取了同类对象的共同属性和方法所形成的对象或实体的“模板”。而对象是现实世界中实体的描述，对象要创建才存在，有了对象才能对对象进行操作。类是对象的模板，对象是类的实例。</p><p>举一些类的例子：</p><p><img src="/2020/02/19/javabase24-oop-class/cd.png" alt="类"></p><h2 id="二、类的定义"><a href="#二、类的定义" class="headerlink" title="二、类的定义"></a>二、类的定义</h2><p>Java中所有程序都基于类，类是引用类型。定义类的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[public][abstract|final]class&lt;class_name&gt;[extends&lt;class_name&gt;][implements&lt;interface_name&gt;] &#123;</span><br><span class="line">    <span class="comment">// 定义属性部分</span></span><br><span class="line">    &lt;property_type&gt;&lt;property1&gt;;</span><br><span class="line">    &lt;property_type&gt;&lt;property2&gt;;</span><br><span class="line">    &lt;property_type&gt;&lt;property3&gt;;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">// 定义方法部分</span></span><br><span class="line">    function1();</span><br><span class="line">    function2();</span><br><span class="line">    function3();</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述语法中各关键字的描述如下。</p><ul><li>public：表示“共有”的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，作为公共工具供其他类和程序使用的类应定义为 public 类。</li><li>abstract：如果类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用 abstract 修饰的方法）和具体方法（没有使用 abstract 修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。</li><li>final：如果类被 final 修饰，则不允许被继承。</li><li>class：声明类的关键字。</li><li>class_name：类的名称。</li><li>extends：表示继承其他类。</li><li>implements：表示实现某些接口。</li><li>property_type：表示成员变量的类型。</li><li>property：表示成员变量名称。</li><li>function()：表示成员方法名称。</li></ul><p>Java 类名的命名规则：</p><ol><li>类名应该以下划线（_）或字母开头，最好以字母开头。</li><li>第一个字母最好大写，如果类名由多个单词组成，则每个单词的首字母最好都大写。</li><li>类名不能为 Java 中的关键字，例如 boolean、this、int 等。</li><li>类名不能包含任何嵌入的空格或点号以及除了下划线（_）和美元符号（$）字符之外的特殊字符。</li></ol><p>例如定义一个汽车类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">String brand; <span class="comment">// 品牌</span></span><br><span class="line"><span class="keyword">double</span> length;<span class="comment">// 长度</span></span><br><span class="line"><span class="keyword">double</span> width; <span class="comment">// 宽度</span></span><br><span class="line"><span class="keyword">double</span> weight;<span class="comment">// 重量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Runing"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的汽车类的属性为：品牌、长度、宽度、重量；方法为 run()。</p><p>class 前的 public 代表公用的，外部可以随意访问该类，属性中的 private 代表私有，只有本类内部可以访问，方法前的 public 表示该方法可以在任意类中使用。</p><h2 id="三、类的属性和方法"><a href="#三、类的属性和方法" class="headerlink" title="三、类的属性和方法"></a>三、类的属性和方法</h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1. 属性"></a>1. 属性</h3><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>|<span class="keyword">protected</span>|<span class="keyword">private</span>][<span class="keyword">static</span>][<span class="keyword">final</span>]&lt;type&gt;&lt;variable_name&gt;</span><br></pre></td></tr></table></figure><p>各参数的含义如下。</p><ul><li>public、protected、private：用于表示成员变量的访问权限。</li><li>static：表示该成员变量为类变量，也称为静态变量。</li><li>final：表示将该成员变量声明为常量，其值无法更改。</li><li>type：表示变量的类型。</li><li>variable_name：表示变量名称。</li></ul><p>为 Car 类中的属性加上修饰符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brand = <span class="string">"Des Auto"</span>; <span class="comment">//品牌</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> length;<span class="comment">//长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> width; <span class="comment">//宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> weight;<span class="comment">//重量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Runing"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加完修饰符后，品牌 brand 属性变成了一个公有静态的常量，值为“ Des Auto ”，让这个汽车类变成类大众汽车的类，final 声明后品牌信息无法修改。</p><p>其他属性变成类私有属性，只能在类内部访问。</p><p>属性不赋值的话有默认值：</p><ul><li>整数型（byte、short、int 和 long）的基本类型变量的默认值为 0。</li><li>单精度浮点型（float）的基本类型变量的默认值为 0.0f。</li><li>双精度浮点型（double）的基本类型变量的默认值为 0.0d。</li><li>字符型（char）的基本类型变量的默认值为 “\u0000”。</li><li>布尔型的基本类型变量的默认值为 false。</li><li>数组引用类型的变量的默认值为 null。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。</li></ul><p>一般属性名的命名方式与变量一样，采用驼峰式，比如 身份证号 用 personId ，电话号码 用 telNumber， 组合词的话头字母小写，后面单词头字母大写，单个字母的属性名小写就可以了。另外还有中间加下划线的命名方式，如 person_id ，驼峰式命名用的比较广泛，但是具体还是要看项目开发规范的要求，有可能写规范的喜欢用下划线呢。</p><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2. 方法"></a>2. 方法</h3><p>方法表示这个类可以完成哪些动作，比如上面 Car 类里有 run() 方法，语法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>|<span class="keyword">private</span>|<span class="keyword">protected</span>][<span class="keyword">static</span>]&lt;<span class="keyword">void</span>|return_type&gt;&lt;method_name&gt;([paramList]) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>public | private | protected 只能选择一个，代表了不同的访问权限。</p><p>上述代码中一个方法包含 4 部分：方法的返回值、方法名称、方法的参数和方法体。其中 retum_type 是方法返回值的数据类型，数据类型可以是原始的数据类型，即常用的 8 种数据类型，也可以是一个引用数据类型，如一个类、接口和数组等。</p><p>除了这些，一个方法还可以没有返回值，即返回类型为 void，像 main() 方法。method_name 表示自定义的方法名称，方法的名称首先要遵循标识符的命名约定，除此之外，方法的名称第一个单词的第一个字母是小写，第二单词的第一个字母是大写，依此类推。</p><p>paramList 表示参数列表，这些变量都要有自己的数据类型，可以是原始数据类型，也可以是复杂数据类型，一个方法主要依靠参数来传递消息。方法主体是方法中执行功能操作的语句。其他各修饰符的含义如下。</p><ul><li>public、private、protected：表示成员方法的访问权限。</li><li>static：表示限定该成员方法为静态方法。</li><li>final：表示限定该成员方法不能被重写或重载。</li><li>abstract：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类</li></ul><p>这里涉及到的重载，重写，抽象方法后面再做了解。</p><p>我们约定采用驼峰式命名，比如 carRun() 汽车跑的方法：</p><p>为上面的 Car 类重新写个方法 carRun：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String brand = <span class="string">"Des Auto"</span>; <span class="comment">// 品牌</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> length;<span class="comment">// 长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> width; <span class="comment">// 宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> weight;<span class="comment">// 重量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有方法 只能在类内部调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Runing"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公有且静态方法，可以在其他类不创建对象的情况下调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">carRun</span><span class="params">(<span class="keyword">double</span> speed)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;<span class="comment">// 共有的 静态的 无法被重写的 带有参数的 并且带有异常处理的方法</span></span><br><span class="line">System.out.println(<span class="string">"The car is start up!"</span>);<span class="comment">//启动引擎</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);<span class="comment">//等待一秒，线程先不用了解  InterruptedException 异常处理就是因为它 模拟汽车运行</span></span><br><span class="line">run();<span class="comment">//调用了类中的run方法</span></span><br><span class="line">System.out.println(<span class="string">"The car is running with speed: "</span> + speed + <span class="string">"km/s"</span>);<span class="comment">//使用了参数 speed</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"car turn off"</span>; <span class="comment">//返回了 car 的运行状态 执行完毕后 car 熄火了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察上方 run 方法 与 carRun 在修饰上的不同，编写个测试类来演示一下：</p><blockquote><p>当想调用 Car的属性或者方法时发现只有 public 修饰的属性和方法可以访问<br><img src="/2020/02/19/javabase24-oop-class/bl.png" alt="只有public修饰的属性和方法可以访问"></p><p>那如何设置和获得 Car 类 中的私有属性呢？ 需要在 Car内部设置公有的 设置和读取属性的方法（setter 和 getter）。</p><p>现在大多数 IDE 都提供快速生成 setter 和 getter 方法的按钮，以及构造方法。</p><p>进入 Car 类 在其他方法下方右击→Source→Generate getter and setter<br><img src="/2020/02/19/javabase24-oop-class/gs.png" alt="快速生成 getter 和 setter 方法"><br><img src="/2020/02/19/javabase24-oop-class/set.png" alt="快速生成 getter 和 setter 方法"></p><p>保存 然后再返回测试类。</p><p>发现可以为 Car 的属性设置值了 看一下</p><p><img src="/2020/02/19/javabase24-oop-class/t.png" alt="成功通过类方法设置并获取了私有属性值"></p><p>通常凡是类中有属性的都会是这种形式，属性私有，然后创建公有的setter和getter方法。</p></blockquote><p>经过一段小插曲，继续方法 carRun 的测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//由于是静态方法，不需要new Car对象</span></span><br><span class="line">String status = Car.carRun(<span class="number">120.0</span>);  <span class="comment">//速度参数为double型 120.0，然后使用String 新建String变量 status 接收 carRun 方法返回值。</span></span><br><span class="line">System.out.println(status);</span><br><span class="line"><span class="comment">//System.out.println(Car.carRun(120.0));  //不新建变量直接这样也行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/19/javabase24-oop-class/carrun.gif" alt="测试 carRun 方法"></p><p>仔细对比 run 方法与 carRun 方法 体会不同修饰符的意义，体会有返回值方法 return 的用法。</p><blockquote><h3 id="方法中参数的用法"><a href="#方法中参数的用法" class="headerlink" title="方法中参数的用法"></a>方法中参数的用法</h3><p>方法中的参数可以有很多个且类型可以不同，用“ ,” 隔开。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">int</span> i, String str, Car car, <span class="keyword">double</span> d)</span></span>&#123;<span class="comment">// 方法内部的参数叫 形式参数 形参</span></span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用方法时参数的顺序，数量，类型要严格一致，一一对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">10</span>;</span><br><span class="line">String s = <span class="string">"kk"</span>;</span><br><span class="line">Car car1 = <span class="keyword">new</span> Car;</span><br><span class="line"><span class="keyword">double</span> speed =  <span class="number">120.0</span>;</span><br><span class="line"></span><br><span class="line">printf(sum,s,car1,d);<span class="comment">// 调用方法时 给的参数叫 实际参数 实参</span></span><br></pre></td></tr></table></figure></blockquote><p>还要提醒一点：在方法内部注意变量的作用域 看好花括号 “ {} “</p><h3 id="类方法的可变参数"><a href="#类方法的可变参数" class="headerlink" title="类方法的可变参数"></a>类方法的可变参数</h3><p>可变参数的意思就是方法的参数数量可以变化，在开发过程中会经常遇到参数个数无法确定的情况，这时候就需要可变参数了。</p><p>可变参数的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">methodName(&#123;paramList&#125;,paramType…paramName);</span><br></pre></td></tr></table></figure><p>其中，methodName 表示方法名称；paramList 表示方法的固定参数列表；paramType 表示可变参数的类型；… 是声明可变参数的标识；paramName 表示可变参数名称。</p><p><em>注意：可变参数必须定义在参数列表的最后。</em></p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Kbcs</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"有其他参数方法"</span>);</span><br><span class="line">kbParam(<span class="string">"kk"</span>, <span class="number">10</span>, <span class="keyword">new</span> <span class="keyword">double</span>[] &#123; <span class="number">8.8</span>, <span class="number">9.9</span>, <span class="number">123.4</span> &#125;);</span><br><span class="line">System.out.println(<span class="string">"无其他参数方法"</span>);</span><br><span class="line">kbParam2(<span class="number">8.8</span>, <span class="number">9.9</span>, <span class="number">123.4</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: kbParam</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 有其他参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kbParam</span><span class="params">(String name, <span class="keyword">int</span> i, <span class="keyword">double</span>... ds)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"可变参数个数："</span> + ds.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> d : ds) &#123;</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: kbParam2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 无其他参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: MGG</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kbParam2</span><span class="params">(<span class="keyword">double</span>... ds)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"可变参数个数："</span> + ds.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">double</span> d : ds) &#123;</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/19/javabase24-oop-class/cs.png" alt="有无其他参数，带入参数方法不一样"></p><p>当有其他参数时，可变参数要放在后面，并且需要 new 创建对应类型的数组对象，填写参数。</p><p>当没有其他参数时，可以直接写对应类型的参数。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>这部分知识内容多，需要多练，多体会，基础要打牢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在面向对象中，类和对象是最基本、最重要的组成单元。类实际上是表示一个客观世界某类群体的一些基本特征抽象。对象就是表示一个个具体的东西。所以说类是对象的抽象，对象是类的具体。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二十三）——对象概念、面向对象的三个特征</title>
    <link href="http://www.mggblog.ink/2020/02/18/javabase23-oop1/"/>
    <id>http://www.mggblog.ink/2020/02/18/javabase23-oop1/</id>
    <published>2020-02-18T13:37:28.000Z</published>
    <updated>2020-02-23T07:32:31.516Z</updated>
    
    <content type="html"><![CDATA[<p><em>对 Java 语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过相互作用传递信息，实现程序开发。</em></p><a id="more"></a><hr><h2 id="一、对象的概念"><a href="#一、对象的概念" class="headerlink" title="一、对象的概念"></a>一、对象的概念</h2><p>“java是面向对象的语言”这种描述是老生常谈，概念知识没必要长篇大论，个人感觉一个合适的比喻比得过一大段详细的描述。那如何理解“对象”呢？</p><p>对象就是现实世界中的一个实体，比如说人类，每个人都是一个对象，用java程序语言来描述一个人的各种信息与动作，此时称java是面向对象的程序语言。</p><p>每个对象都有自身的特点，以人为例：</p><ul><li>每个人都有性别，名字等（对象的属性），每个正常人都可以吃饭、睡觉（对象的行为）；</li><li>人可以变胖或者变瘦（对象状态变化）；</li><li>每个人都是唯一的，没有完全相同的两个人（对象唯一性）；</li><li>物以类聚，人是生物的一个种类，我只是人类中的一员（对象是类别的实例）；</li><li>自然界除了人，还有花鸟虫鱼野兽等其他类生物，每一个具体的生物都是一个对象（一切皆为对象）。</li></ul><h2 id="二、面向对象的三个特征"><a href="#二、面向对象的三个特征" class="headerlink" title="二、面向对象的三个特征"></a>二、面向对象的三个特征</h2><p>面向对象有散个基本特征：<strong>封装、继承、多态</strong>。首先搞清楚，为什么要面向对象。以人为例：</p><ul><li>有一个人善于弹钢琴，在自己家可以弹，也可以被委派到音乐会去弹，他老婆是老师，每天都要去学校上课（面向对象代码可重复使用，不同种功能分开开发，提高开发效率）</li><li>这个人音乐天赋了得，有个乐团缺个打鼓手，他自学打鼓加入了乐团（面向对象可扩展性）</li><li>乐团按照乐器种类发工资，乐团里每个人都拿到了不同种乐器相应的钱（面向对象易于管理数据与功能的关系）</li></ul><p>以 java 来说，她多次蝉联世界编程语言使用人数第一的宝座，此殊荣说明了 java 的强大，但是成就了 java 如此强大的是她的三个核心特征：封装、继承、多态。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是将对象属性与方法结合起来，外部无法干扰到对象内部的属性信息与方法，保护了该对象不被破坏。有以下优点：</p><ul><li>保护对象，外部在没有权限的情况下无法随意访问对象内部</li><li>隐藏细节信息，如外人只知道我善于弹钢琴，但是他不知道我是如何弹的那么好的。</li><li>有利于建立对象间的耦合关系，还是乐团的例子，我会弹钢琴，别人会其他乐器，一起组了个乐团，合作一起做音乐。</li><li>提高软件复用率，有个乐团出高新招聘钢琴师，我不满意现在的工资跳槽了过去，我并不是只能在这个乐团弹。</li></ul><p>java 中封装的对象称为为类，有权限修饰符 private protect public  来限定外部访问的权限大小，后面再说。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承很容易理解，就以人来说，正常情况下，一个人可以走路，他的儿子应该也会走路，不但会走路，还会开车。放在程序中，就是子类继承了父类的所有属性和方法，并且可以具有父类没有的属性与方法。<strong>在java中每个类只可以继承一个父类（单继承机制）</strong></p><p>举个具体程序的例子：</p><p>有一个 Person 类:<br>类中属性有：姓名，性别，年龄。<br>类中的方法有：吃饭，睡觉。</p><p>我可以使用这个 Person 类完成一个具体的操作“康康是个男生，今年10岁，他正在吃饭，一会要去睡觉。”</p><p>现在我需要一个 Student 类来完成学生的具体操作“小红是个女生，今年9岁，她吃完饭，要去睡觉，睡醒要学习，然后再吃饭睡觉。” 显然 Person 中没有学习的功能，而且 student 类依然需要 person 类中的属性和方法。</p><p>此时只需要创建一个 student 类继承 person 类，然后在 student 类中新增 学习的方法就可以了。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态通过类继承重写方法，和接口的多实现重写抽象方法来实现，具体如何实现到后面会详细说明，简单的举两个例子：</p><p>类的多态：</p><p>Animal类中有 run() 方法，Dog 类和 Cat 类都继承了 Animal 类，然后重写了 run() 方法，分别有了不同的动作方式，这就是类的多态。</p><p>接口的多态：</p><p>有一个 teacher 类 ，类中有一个 teach 的抽象方法（接口中的方法都是抽象的，抽象的意思是只有方法名没有方法体，方法如何执行写在实现接口的类中）</p><p>然后有 englishteacher 类 和 mathteacher 类分别实现了 teacher 接口</p><p>englishteacher 类中的 teach 方法具体表现为 teach english</p><p>mathteacher 类中 teach 方法具体表现为 tech math。</p><p><img src="/2020/02/18/javabase23-oop1/dt.png" alt="接口的实现"></p><p>那么多态有什么什么好处呢，就上面的例子，写接口的人只需考虑老师要做哪些工作，不用考虑具体做什么，英语老师只需要关心教英语，数学老师只需要关心教数学。</p><p>今天的内容只是简单介绍，这些内容，会在后面的学习中有更多的体会。<br>__</p><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>最近掉头发掉的厉害，睡了睡了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;对 Java 语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过相互作用传递信息，实现程序开发。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java面向对象" scheme="http://www.mggblog.ink/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
