<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MggBlog</title>
  
  <subtitle>MggBlog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.mggblog.ink/"/>
  <updated>2020-02-16T08:59:57.112Z</updated>
  <id>http://www.mggblog.ink/</id>
  
  <author>
    <name>Mgg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十九）——数组查询、复制</title>
    <link href="http://www.mggblog.ink/2020/02/16/javabase19-array-s-c/"/>
    <id>http://www.mggblog.ink/2020/02/16/javabase19-array-s-c/</id>
    <published>2020-02-16T07:23:04.000Z</published>
    <updated>2020-02-16T08:59:57.112Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>本篇内容包括：数组查询指定元素，数组复制</strong></em></p><a id="more"></a><hr><h2 id="数组查询指定元素（binarySearch-方法）"><a href="#数组查询指定元素（binarySearch-方法）" class="headerlink" title="数组查询指定元素（binarySearch() 方法）"></a>数组查询指定元素（binarySearch() 方法）</h2><p>两种搜索，一个是查元素返回索引，一个是限定索引范围查元素返回索引。<br><strong>1. binarySearch(Object[] a,Object key)</strong><br>我们以 int 型数组为例：</p><p>使用二分搜索法来搜索指定的 int 型数组，以获得指定的值。<strong>必须在进行此调用之前对数组进行排序（通过 sort(int[]) 方法）</strong>。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。 </p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">55</span>,<span class="number">22</span>,<span class="number">34</span>,<span class="number">77</span>,<span class="number">11</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line">System.out.println(<span class="string">"元素77的索引为："</span>+Arrays.binarySearch(arr, <span class="number">77</span>));</span><br><span class="line">System.out.println(<span class="string">"元素77的索引为："</span>+Arrays.binarySearch(arr, <span class="number">33</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/bs.png" alt="经过排序后77索引为4，如果没有返回负值"></p><p><strong>2. binarySearch(Object[] a,int fromIndex,int toIndex,Object key);</strong><br>我们依然以 int 型数组为例：</p><p>使用二分搜索法来搜索指定的 int 型数组的范围，以获得指定的值。<strong>必须在进行此调用之前对范围进行排序（通过 sort(int[], int, int) 方法）（jdk文档里这么说，我倒觉得不如直接完全排序清楚）</strong>。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个带有指定值的元素，则无法保证找到的是哪一个。</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> fromIndex，<span class="keyword">int</span> endIndex,<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line">Arrays.sort(arr);<span class="comment">// 我们完全排序</span></span><br><span class="line">System.out.println(<span class="string">"元素77的索引为："</span> + Arrays.binarySearch(arr, <span class="number">1</span>, <span class="number">5</span>, <span class="number">34</span>));</span><br><span class="line">System.out.println(<span class="string">"元素77的索引为："</span> + Arrays.binarySearch(arr, <span class="number">1</span>, <span class="number">5</span>, <span class="number">11</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/bs2.png" alt="经过排序后34索引为3，范围内没11，返回负值"></p><h2 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h2><p>数组复制是编程时常见需求，Java 中提供了四种方法：</p><ol><li>Arrays 类的 copyOf() 方法</li><li>Arrays 类的 copyOfRange() 方法</li><li>System 类的 arraycopy() 方法</li><li>Object 类的 clone() 方法  </li></ol><p>下面分别介绍用法：</p><h3 id="copyOf-与-copyOfRange"><a href="#copyOf-与-copyOfRange" class="headerlink" title="copyOf 与 copyOfRange"></a>copyOf 与 copyOfRange</h3><p>copyOf() 方法是复制数组至指定长度，copyOfRange() 方法则将指定数组的指定长度复制到一个新数组中。<strong>注意：目标数组如果已经存在，将会被重构。</strong><br><strong>1. copyOf</strong><br>我们以 int 数组方法为例</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOf(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length);</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOf(arr, <span class="number">7</span>);</span><br><span class="line"><span class="keyword">int</span>[] newArr2 = Arrays.copyOf(arr, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"完全复制的新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n未完全复制的新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr2) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/fzjg1.png" alt="复制结果"></p><p><strong>2. copyOfRange</strong><br>依然以 int 数组为例</p><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOf(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> fromIndex,<span class="keyword">int</span> endIndex);</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = Arrays.copyOfRange(arr,<span class="number">2</span>,<span class="number">10</span>);</span><br><span class="line">System.out.println(<span class="string">"从索引2-5复制的新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/fzjg2.png" alt="复制结果"></p><p>元素一共八个，但是我们结束索引的位置是10，新数组中补充了两个 int数组默认值 0 。</p><h2 id="arraycopy-方法"><a href="#arraycopy-方法" class="headerlink" title="arraycopy 方法"></a>arraycopy 方法</h2><p>arraycopy() 方法位于 java.lang.System 类中，其语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(dataType[] srcArray,<span class="keyword">int</span> srcIndex,<span class="keyword">int</span> destArray,<span class="keyword">int</span> destIndex,<span class="keyword">int</span> length)</span><br></pre></td></tr></table></figure><p>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的源数组到 dest 引用的目标数组，数组组件的一个子序列被复制下来。被复制的组件的编号等于 length 参数。源数组中位置在 srcPos 到 srcPos+length-1 之间的组件被分别复制到目标数组中的 destPos 到 destPos+length-1 位置。</p><p><strong>注意：目标数组不会被覆盖，相当于替换目标数组中元素的值</strong></p><p>Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr = &#123;<span class="number">23</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">90</span>,<span class="number">56</span>,<span class="number">78</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">26</span>,<span class="number">33</span>,<span class="number">66</span>,<span class="number">77</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">"原数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :arr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n目标数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">       <span class="comment">//原函数索引从 0 开始，目标函数索引从2开始，替换长度为 5</span></span><br><span class="line">System.arraycopy(arr, <span class="number">0</span>, newArr, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"\n复制后目标数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/ac.png" alt="复制结果"></p><h2 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone 方法"></a>clone 方法</h2><p>Object类方法，原数组可以直接调用，<strong>目标数组如果已经存在，将会被重构</strong>，由于方法返回值为 Object 型对象，需要强制转换为数组对象（虽然这么说，但是我用过后不用转也可以）。<br>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type[] newArr = arr.clone();</span><br></pre></td></tr></table></figure><p>Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123; <span class="number">55</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">11</span>, <span class="number">66</span>, <span class="number">35</span>, <span class="number">26</span> &#125;;</span><br><span class="line"><span class="keyword">int</span>[] newArr =(<span class="keyword">int</span>[]) arr.clone();</span><br><span class="line">System.out.println(<span class="string">"原数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :arr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n新数组中的元素为"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i :newArr) System.out.print(i+<span class="string">" "</span>);</span><br><span class="line">System.out.println(<span class="string">"\n"</span>+arr.equals(newArr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase19-array-s-c/c.png" alt="复制结果"></p><blockquote><p>注意：以上几种方法都是浅拷贝（浅复制）。浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变。</p></blockquote><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>数组常规操作都有了，下回我们一起学三种排序，冒泡、快速、选择排序，这是算法新手的第一个拦路虎，不同语言有不同的写法，但是思路相同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;strong&gt;本篇内容包括：数组查询指定元素，数组复制&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十八）——二维、多维数组及常用方法</title>
    <link href="http://www.mggblog.ink/2020/02/16/javabase18-array2/"/>
    <id>http://www.mggblog.ink/2020/02/16/javabase18-array2/</id>
    <published>2020-02-16T02:14:12.000Z</published>
    <updated>2020-02-16T08:56:03.363Z</updated>
    
    <content type="html"><![CDATA[<p><em>一维数组显然还无法满足日常数据的存储，最常用的 Excel 有行有列就可以满足普通数据的存储需要，二维数组就是我们需要的表格形式，<strong>本期内容：二维数组、多维数组、数组常用方法（Arrays 类）</strong></em> </p><a id="more"></a><hr><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><h3 id="二维数组声明"><a href="#二维数组声明" class="headerlink" title="二维数组声明"></a>二维数组声明</h3><p>将二维数组理解成一个一维数组的每个元素都是一维数组就可以了，声明方法就是加 [] :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [][] 像一维数组提到的 可以换位置  int[][] arr   或者是 int arr[][]</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][<span class="number">5</span>];<span class="comment">//定义五行五列的int数组</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];<span class="comment">//第二维可以不预设长度，但是用到时要先设置好，否者空指针异常。</span></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">int</span> arr[][]; <span class="comment">//等用到了再初始化 直接给值 或者设定长度</span></span><br></pre></td></tr></table></figure><p>Demo：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> arr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];<span class="comment">//声明时初始化</span></span><br><span class="line"><span class="keyword">int</span> arr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][]; <span class="comment">//声明时第二维没有初始化</span></span><br><span class="line"><span class="keyword">int</span> arr3[][]; <span class="comment">//声明时未初始化</span></span><br><span class="line">arr3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">System.out.println(arr1);</span><br><span class="line">System.out.println(arr2);</span><br><span class="line">System.out.println(arr3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/16/javabase18-array2/csh.png" alt="运行结果"></p><h3 id="二维数组赋值与遍历"><a href="#二维数组赋值与遍历" class="headerlink" title="二维数组赋值与遍历"></a>二维数组赋值与遍历</h3><p>选择初始化时直接赋值或者通过索引赋值。</p><ol><li>直接赋值：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维 int 型数组</span></span><br><span class="line"><span class="keyword">int</span> arr[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li>for 循环赋值<br>一维数组赋值时使用一个 for 循环，二维时就需要再嵌套一个 for 循环：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length;j++) &#123;</span><br><span class="line">arr[i][j] = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>赋值用了两层，那么遍历也需要两层，来练习一下。</p><p>创建一个二维数组，从控制台输入值并且遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> arr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">System.out.println(<span class="string">"请输入第"</span> + (i + <span class="number">1</span>) + <span class="string">"行第"</span> + (j + <span class="number">1</span>) + <span class="string">"列元素："</span>);</span><br><span class="line">arr[i][j] = input.nextInt();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"\n~~~~~~~~~~~~"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"行第"</span> + (j + <span class="number">1</span>) + <span class="string">"列元素="</span> + arr[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果  </p><p><img src="/2020/02/16/javabase18-array2/fzbl.png" alt="二维数组赋值与遍历"></p><p>遍历也可以使用 foreach ,同样要使用两层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] row : arr )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> val : row)&#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个数组元素都会获得了，那获取整行整列也就比较简单了。</p><p>以上面demo为例，获取第一行，只需要使用第一个索引就可以了 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] row = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : row) System.out.println(i);</span><br></pre></td></tr></table></figure><p>如果要获取某一列的值就有点麻烦了，无法直接通过获取数组来遍历了，需要使用 for 循环，访问下标,比如获取第二列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"第"</span>+<span class="number">2</span>+<span class="string">"列："</span>+arr[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>其实类似二维数组的理解，一维数组的每个元素都是一维以上的数组，如每个元素都是二维数组就是三维数组，就这么套娃套下去，只要内存顶得住，想多少维就多少维。<br>举个三维的例子，直接赋值吧，控制台输入就是三层 for 嵌套了，遍历也是三层 for 嵌套，几维就需要几个嵌套。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[][][] = &#123;&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;,&#123;&#123;<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>&#125;&#125;&#125;; <span class="comment">//多维的声明就是加 []</span></span><br></pre></td></tr></table></figure><p>这是一个2X2X2的立体数据块，这么理解就可以了，到了四维数组，脑子是理解不动了，反正将索引 [] 使用数学的排列组合就可以定位到所有元素了。</p><p>说到底无论几维数组，都是一维数组，一直嵌套而已，因为内存存储并没有那么多维度，只分栈和堆。由一维的地址指向值，变成地址指向地址，最后在指向堆内的值。</p><p>掌握一维和二维数组用法足够对付大部分问题了。</p><h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><p>Arrays 类为数组的处理提供了众多方法，例如排序 sort，比较 equals等，里面重载的方法众多，我们挑出代表，重点在于知道这些方法的使用方式，而不是掌握所有方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>asList(T… a)</td><td>返回一个受指定数组支持的固定大小的列表。</td></tr><tr><td>binarySearch(byte[] a, byte key)</td><td>使用二分搜索法来搜索指定的 byte 型数组，以获得指定的值。</td></tr><tr><td>copyOf(boolean[] original, int newLength)</td><td>复制指定的数组，截取或用 false 填充（如有必要），以使副本具有指定的长度。</td></tr><tr><td>copyOfRange(boolean[] original, int from, int to)</td><td>将指定数组的指定范围复制到一个新数组。</td></tr><tr><td>deepEquals(Object[] a1, Object[] a2)</td><td>如果两个指定数组彼此是深层相等 的，则返回 true。</td></tr><tr><td>deepHashCode(Object[] a)</td><td>基于指定数组的“深层内容”返回哈希码。</td></tr><tr><td>deepToString(Object[] a)</td><td>返回指定数组“深层内容”的字符串表示形式。</td></tr><tr><td>equals(boolean[] a, boolean[] a2)</td><td>如果两个指定的 boolean 型数组彼此相等，则返回 true。</td></tr><tr><td>fill(boolean[] a, boolean val)</td><td>将指定的 boolean 值分配给指定 boolean 型数组的每个元素。</td></tr><tr><td>hashCode(boolean[] a)</td><td>基于指定数组的内容返回哈希码。</td></tr><tr><td>sort(byte[] a)</td><td>对指定的 byte 型数组按数字升序进行排序。</td></tr><tr><td>toString(boolean[] a)</td><td>返回指定数组内容的字符串表示形式。</td></tr></tbody></table><p>这是从jdk1.6文档中获得的数据，在网上看博客时得到 jdk8 中 Arrays 得到加强，添加了许多新方法，这就需要下载jdk8 文档，我从其他博客里转载过来一段。</p><p>由于计算机硬件的飞速发展，目前几乎所有家用 PC 都是 4 核、8 核的 CPU，而服务器的 CPU 则具有更好的性能，因此 Java 8 与时俱进地增加了并发支持，并发支持可以充分利用硬件设备来提高程序的运行性能。</p><ol><li>oid parallelPrefix(xxx[] array, XxxBinaryOperator op)<br>该方法使用 op 参数指定的计算公式计算得到的结果作为新的元素。op 计算公式包括 left、right 两个形参，其中 left 代表数组中前一个索引处的元素，right 代表数组中当前索引处的元素，当计算第一个新数组元素时，left 的值默认为 1。</li><li>void parallelPrefix(xxx[] array, int fromIndex, int toIndex, XxxBinaryOperator op)<br>该方法与上一个方法相似，区别是该方法仅重新计算 fromIndex 到 toIndex 索引的元素。</li><li>void setAll(xxx[] array, IntToXxxFunction generator)<br>该方法使用指定的生成器（generator）为所有数组元素设置值，该生成器控制数组元素的值的生成算法。</li><li>void parallelSetAll(xxx[] array, IntToXxxFunction generator)<br>该方法的功能与上一个方法相同，只是该方法增加了并行能力，可以利用多 CPU 并行来提高性能。</li><li>void parallelSort(xxx[] a)<br>该方法的功能与 Arrays 类以前就有的 sort() 方法相似，只是该方法增加了并行能力，可以利用多 CPU 并行来提高性能。</li><li>void parallelSort(xxx[] a，int fromIndex, int toIndex)<br>该方法与上一个方法相似，区別是该方法仅对 fromIndex 到 toIndex 索引的元素进行排序。</li><li>Spliterator.OfXxx spliterator(xxx[] array)<br>将该数组的所有元素转换成对应的 Spliterator 对象。</li><li>Spliterator.OfXxx spliterator(xxx[] array, int startInclusive, int endExclusive)<br>该方法与上一个方法相似，区别是该方法仅转换 startInclusive 到 endExclusive 索引的元素。</li><li>XxxStream stream(xxx[] array)<br>该方法将数组转换为 Stream，Stream 是 Java 8 新增的流式编程的 API。</li><li>XxxStream stream(xxx[] array, int startInclusive, int endExclusive)<br>该方法与上一个方法相似，区别是该方法仅将 fromIndex 到 toIndex 索引的元索转换为 Stream。</li></ol><p>上面方法列表中，所有以 parallel 开头的方法都表示该方法可利用 CPU 并行的能力来提高性能。上面方法中的 xxx 代表不同的数据类型，比如处理 int[] 型数组时应将 xxx 换成 int，处理 long[] 型数组时应将 XXX 换成 long。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>虽然写了这么多方法，如果不用还是没用，脑袋记和容易网，能做到多翻文档就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;一维数组显然还无法满足日常数据的存储，最常用的 Excel 有行有列就可以满足普通数据的存储需要，二维数组就是我们需要的表格形式，&lt;strong&gt;本期内容：二维数组、多维数组、数组常用方法（Arrays 类）&lt;/strong&gt;&lt;/em&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十七）——数组简介和一维数组</title>
    <link href="http://www.mggblog.ink/2020/02/15/javabase17-array/"/>
    <id>http://www.mggblog.ink/2020/02/15/javabase17-array/</id>
    <published>2020-02-15T08:30:43.000Z</published>
    <updated>2020-02-16T08:56:24.700Z</updated>
    
    <content type="html"><![CDATA[<p><em>一个数据用变量存储，如果10个人名呢，建十个变量也谈不上麻烦，那100个呢？这时候就需要引入一个新的工具来存储数据了，Java为我们提供了数组工具，<strong>本篇内容：数组简介，一维数组。</strong></em></p><a id="more"></a><hr><h2 id="数组简介"><a href="#数组简介" class="headerlink" title="数组简介"></a>数组简介</h2><p>数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。</p><h3 id="数组特征"><a href="#数组特征" class="headerlink" title="数组特征"></a>数组特征</h3><p>数组主要有三个基本特征：</p><ol><li>一个数组内部存放的数据类型一致，如一个元素是 int 型，其他元素也只能是 int 型。</li><li>数组内元素有序排列，这里说的有序是指索引有序，索引从 0 开始，最大值为元素个数 -1。</li><li>初始化数组后，数组的元素个数不能再变化。</li></ol><p>数组大概是这个样子：<br><img src="/2020/02/15/javabase17-array/sl.png" alt="一维和多维数组"></p><p>而且还有几个特点：</p><ol><li>数组可分为一维数组、二维数组和多维数组。</li><li>数值元素默认值为 0 ，引用元素默认为 null，字符型默认为’\u0000’。</li><li>数组内元素可以为数组，这也是多维数组的原理。</li><li>数组是 Array 的派生类。可以使用 Array 类方法处理数组</li></ol><h3 id="数组的内存存储"><a href="#数组的内存存储" class="headerlink" title="数组的内存存储"></a>数组的内存存储</h3><p>数组为引用类型，变量名保存在栈中，元素值保存在堆中。<br>以整型数组为例：  </p><p><img src="/2020/02/15/javabase17-array/szcf.png" alt="int 型数组内存存放"></p><p>如果初始化了一个空数组，堆内数据都为默认值。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>上面说了数组是引用类型，所以使用数组时一定要记住需要声明和初始化。</p><h3 id="定义一维数组"><a href="#定义一维数组" class="headerlink" title="定义一维数组"></a>定义一维数组</h3><p>定义数组形式有三种：</p><ol><li>直接定义和初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> [] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li><li>指定数组长度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String [] strs = <span class="keyword">new</span> String [<span class="number">3</span>]; <span class="comment">//当然可以先定义用的时候再初始化 如String [] strs =null ; strs = new String [3];</span></span><br></pre></td></tr></table></figure></li><li>不设定长度<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[] &#123; <span class="string">"kk"</span>, <span class="string">"jj"</span> &#125;; <span class="comment">//实在鸡肋方法</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>“ [] “ 在定义中可以变位置，如 int a [] = new int[3];  </li><li>一旦声明了数组的大小，就不能再修改。这里的数组长度也是必需的，不能少。  </li></ul></blockquote></li></ol><h3 id="数组元素赋值与遍历"><a href="#数组元素赋值与遍历" class="headerlink" title="数组元素赋值与遍历"></a>数组元素赋值与遍历</h3><p>数组中每个元素都有索引且索引从 0 开始，使用中括号 [] 读取索引，如 arr[1] 代表着数组 arr 的第二个元素。赋值与遍历是与索引分不开的，写个例子练习一下，其实前面有写过。</p><p>写个Demo，通过控制台给数组赋值，然后再遍历出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String strs[] = <span class="keyword">new</span> String[<span class="number">3</span>];</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strs.length ;i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"请输入第"</span>+(i+<span class="number">1</span>)+<span class="string">"个元素："</span>);</span><br><span class="line">strs[i] = input.nextLine();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"~~~~~~~~~~~~~~\n遍历结果为："</span>);</span><br><span class="line"><span class="keyword">for</span>(String s : strs) System.out.println(s);  <span class="comment">//只遍历数据可以用foreach ,需要通过索引操作还是for循环方便。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/15/javabase17-array/szfz.png" alt="数组元素赋值与遍历"></p><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><p>Jdk文档中有 Arrays 类定义了大量的数组 sort 方法，可对数组进行排序，感兴趣要去看看 Arrays 类中排序方法的源代码，在这里只说怎么用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">44</span>,<span class="number">55</span>,<span class="number">22</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">80</span>&#125;;</span><br><span class="line">Arrays.sort(arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : arr) System.out.println((i+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/15/javabase17-array/sx.png" alt="按升序排列"></p><p>后面我们会详细学三种排序算法（冒泡排序、快速排序、选择排序），先看看源码获得启发。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>数组这边要多练习，非常重要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;一个数据用变量存储，如果10个人名呢，建十个变量也谈不上麻烦，那100个呢？这时候就需要引入一个新的工具来存储数据了，Java为我们提供了数组工具，&lt;strong&gt;本篇内容：数组简介，一维数组。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数组" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十六）——数据类型封装类</title>
    <link href="http://www.mggblog.ink/2020/02/15/javabase16-sjfzl/"/>
    <id>http://www.mggblog.ink/2020/02/15/javabase16-sjfzl/</id>
    <published>2020-02-15T02:00:05.000Z</published>
    <updated>2020-02-15T04:23:04.953Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>本篇内容：Integer 类、Float 类、Double 类、Number 类、Character 类、Boolean 类、 Byte 类。</strong></em></p><a id="more"></a><hr><h2 id="Integer-类"><a href="#Integer-类" class="headerlink" title="Integer 类"></a>Integer 类</h2><p>Integer 类在对象中包装了一个基本类型 int 的值。Integer 类型的对象包含一个 int 类型的字段。</p><h3 id="两个带参数构造："><a href="#两个带参数构造：" class="headerlink" title="两个带参数构造："></a>两个带参数构造：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="keyword">int</span> val);<span class="comment">//参数为整型</span></span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(String val);<span class="comment">//参数为字符串型</span></span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>byte  byteValue()</td><td>以 byte 类型返回该 Integer 的值</td></tr><tr><td>short shortValue()</td><td>以 short 类型返回该 Integer 的值</td></tr><tr><td>int  intValue()</td><td>以 int 类型返回该 Integer 的值</td></tr><tr><td>String  toString()</td><td>返回一个表示该 Integer 值的 String 对象</td></tr><tr><td>boolean  equals(Object obj)</td><td>比较此对象与指定对象是否相等</td></tr><tr><td>int  compareTo(Integer anotherlnteger)</td><td>在数字上比较两个 Integer 对象，如相等，则返回 0；小于返回负值大于返回正值</td></tr><tr><td>Integer  valueOf(String s)</td><td>返回保存指定的 String 值的 Integer 对象</td></tr><tr><td>int  parseInt(String s)</td><td>将数字字符串转换为 int 数值</td></tr></tbody></table><p>其中有几个方法我们在前面 String 与 int 互转已经用过很多次了，看看其他方法是什么个效果：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="string">"100"</span>);</span><br><span class="line">System.out.println(integer.compareTo(<span class="keyword">new</span> Integer(<span class="string">"200"</span>)));</span><br><span class="line">System.out.println(integer.doubleValue());</span><br><span class="line">System.out.println(integer.byteValue());</span><br><span class="line">System.out.println(integer.floatValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/integer.png" alt="运行结果">  </p><h3 id="Integer常量"><a href="#Integer常量" class="headerlink" title="Integer常量"></a>Integer常量</h3><p> 常用常量：</p><ul><li>MAX_VALUE：值为 231-1 的常量，它表示 int 类型能够表示的最大值。</li><li>MIN_VALUE：值为 -231 的常量，它表示 int 类型能够表示的最小值。</li><li>SIZE：用来以二进制补码形式表示 int 值的比特位数。</li><li>TYPE：表示基本类型 int 的 Class 实例。</li></ul><h2 id="Float-类"><a href="#Float-类" class="headerlink" title="Float 类"></a>Float 类</h2><p>Float 类在对象中包装一个基本类型 float 的值。Float 类型的对象包含一个 float 类型的字段。 </p><p>此外，此类提供了几种方法，可将 float 类型与 String 类型互相转换，还提供了处理 float 类型时非常有用的其他一些常量和方法。 </p><h3 id="Float-类的三个构造方法："><a href="#Float-类的三个构造方法：" class="headerlink" title="Float 类的三个构造方法："></a>Float 类的三个构造方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Float float1 = <span class="keyword">new</span> Float(<span class="keyword">double</span> value);    <span class="comment">// 以 double 类型的变量作为参数创建 Float 对象</span></span><br><span class="line">Float float2 = <span class="keyword">new</span> Float(<span class="keyword">float</span> value);    <span class="comment">// 以 float 类型的变量作为参数创建 Float 对象</span></span><br><span class="line">Float float3 = <span class="keyword">new</span> Float(String s);    <span class="comment">// 以 String 类型的变量作为参数创建 Float 对象</span></span><br></pre></td></tr></table></figure><h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>Float 同样提供了与字符串之间相互转换的方法，以及用于比较的 equlas方法，来学一下其他方法：</p><table><thead><tr><th>方法</th><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>byteValue()</td><td>byte</td><td>以 byte 类型返回该 Float 的值</td></tr><tr><td>doubleValue()</td><td>double</td><td>以 double 类型返回该 Float 的值</td></tr><tr><td>floatValue()</td><td>float</td><td>以 float 类型返回该 Float 的值</td></tr><tr><td>intValue()</td><td>int</td><td>以 int 类型返回该 Float 的值（强制转换为 int 类型）</td></tr><tr><td>longValue()</td><td>long</td><td>以 long 类型返回该 Float 的值（强制转换为 long 类型）</td></tr><tr><td>shortValue()</td><td>short</td><td>以 short 类型返回该 Float 的值（强制转换为 short 类型）</td></tr><tr><td>isNaN()</td><td>boolean</td><td>如果此 Float 值是一个非数字值，则返回 true，否则返回 false</td></tr><tr><td>isNaN(float v)</td><td>boolean</td><td>如果指定的参数是一个非数字值，则返回 true，否则返回 false</td></tr><tr><td>toString()</td><td>String</td><td>返回一个表示该 Float 值的 String 对象</td></tr><tr><td>valueOf(String s)</td><td>Float</td><td>返回保存指定的 String 值的 Float 对象</td></tr><tr><td>parseFloat(String s)</td><td>float</td><td>将数字字符串转换为 float 数值</td></tr></tbody></table><p>写个 float 与 String 转化demo加深印象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"12.3"</span>;</span><br><span class="line"><span class="keyword">float</span> num = Float.parseFloat(str); <span class="comment">// 将字符串转换为 float 类型的数值</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">45.6f</span>;</span><br><span class="line">String s = Float.toString(f); <span class="comment">// 将 float 类型的数值转换为字符串</span></span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/s.png" alt="运行结果">  </p><h3 id="Float-常量"><a href="#Float-常量" class="headerlink" title="Float 常量"></a>Float 常量</h3><p>在 Float 类中包含了很多常量，其中较为常用的常量如下。</p><ul><li>MAX_VALUE：值为 1.4E38 的常量，它表示 float 类型能够表示的最大值。</li><li>MIN_VALUE：值为 3.4E-45 的常量，它表示 float 类型能够表示的最小值。</li><li>MAX_EXPONENT:有限 float 变量可能具有的最大指数。</li><li>MIN_EXPONENT：标准化 float 变量可能具有的最小指数。</li><li>MIN_NORMAL：保存 float 类型数值的最小标准值的常量，即 2-126。</li><li>NaN：保存 float 类型的非数字值的常量。</li><li>SIZE：用来以二进制补码形式表示 float 值的比特位数。</li><li>TYPE：表示基本类型 float 的 Class 实例。</li></ul><p>输出看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">float</span> max_value = Float.MAX_VALUE; <span class="comment">// 获取 float 类型可取的最大值</span></span><br><span class="line"><span class="keyword">float</span> min_value = Float.MIN_VALUE; <span class="comment">// 获取 float 类型可取的最小值</span></span><br><span class="line"><span class="keyword">float</span> min_normal = Float.MIN_NORMAL; <span class="comment">// 获取 float 类型可取的最小标准值</span></span><br><span class="line"><span class="keyword">float</span> size = Float.SIZE; <span class="comment">// 获取 float 类型的二进制位</span></span><br><span class="line">System.out.println(max_value);</span><br><span class="line">System.out.println(min_value);</span><br><span class="line">System.out.println(min_normal);</span><br><span class="line">System.out.println(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/f.png" alt="运行结果">  </p><h2 id="Double-类"><a href="#Double-类" class="headerlink" title="Double 类"></a>Double 类</h2><p>Double 类在对象中包装一个基本类型 double 的值。每个 Double 类型的对象都包含一个 double 类型的字段。 </p><p>此外，该类还提供多个方法，可以将 double 转换为 String，将 String 转换为 double，也提供了其他一些处理 double 时有用的常量和方法。</p><h3 id="两个构造方法："><a href="#两个构造方法：" class="headerlink" title="两个构造方法："></a>两个构造方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Double d = <span class="keyword">new</span> Double(<span class="keyword">double</span> value);<span class="comment">//构造一个新分配的 Double 对象，它表示基本的 double 参数</span></span><br><span class="line">Double d = <span class="keyword">new</span> Double(String s); <span class="comment">//构造一个新分配的 Double 对象，表示用字符串表示的 double 类型的浮点值。该方法与 valueOf 方法一样，可将字符串转换为 double 值。</span></span><br></pre></td></tr></table></figure><p>如果字符串有数字以外的字符就会抛出异常。</p><h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><p>这些包装类的类方法基本都差不多：<br><img src="/2020/02/15/javabase16-sjfzl/df.png" alt="Double 类常用方法"><br>double 型 与 String 互转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"123.4"</span>;</span><br><span class="line"><span class="keyword">double</span> num = Double.parseDouble(str);    <span class="comment">// 将字符串转换为 double 类型的数值</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">56.78</span>;</span><br><span class="line">String s = Double.toString(d);    <span class="comment">// 将double类型的数值转换为字符串</span></span><br><span class="line">System.out.println(Double.isNaN(d));  <span class="comment">//验证</span></span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/d.png" alt="运行结果">  </p><h3 id="Double-类常量"><a href="#Double-类常量" class="headerlink" title="Double 类常量"></a>Double 类常量</h3><p>基本个Float一样：</p><ul><li>MAX_VALUE:值为 1.8E308 的常量，它表示 double 类型的最大正有限值的常量。</li><li>MIN_VALUE：值为 4.9E-324 的常量，它表示 double 类型数据能够保持的最小正非零值的常量。</li><li>NaN：保存 double 类型的非数字值的常量。</li><li>NEGATIVE_INFINITY：保持 double 类型的负无穷大的常量。</li><li>POSITIVE_INFINITY：保持 double 类型的正无穷大的常量。</li><li>SIZE：用秦以二进制补码形式表示 double 值的比特位数。</li><li>TYPE：表示基本类型 double 的 Class 实例。</li></ul><h2 id="Number-类"><a href="#Number-类" class="headerlink" title="Number 类"></a>Number 类</h2><p>抽象类 Number 是 BigDecimal、BigInteger、Byte、Double、Float、Integer、Long 和 Short 类的超类。 </p><p>Number 的子类必须提供将表示的数值转换为 byte、double、float、int、long 和 short 的方法。 </p><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p><img src="/2020/02/15/javabase16-sjfzl/n.png" alt="Number 类方法">  </p><p>因为是抽象类，不能自己实例化，要依靠子类，方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number num = <span class="keyword">new</span> Integer(); <span class="comment">//Integer 可以换为任何子类；</span></span><br></pre></td></tr></table></figure><h2 id="Character-类"><a href="#Character-类" class="headerlink" title="Character 类"></a>Character 类</h2><p>Character 类在对象中包装一个基本类型 char 的值。Character 类型的对象包含类型为 char 的单个字段。 </p><p>此外，该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然。 </p><p>编码参照 Unicode 标准，我前面说 char 是 ASCII 码，其实没什么问题，Unicode 是 ASCII 码优化来的，都是机器码。</p><h3 id="一个构造方法"><a href="#一个构造方法" class="headerlink" title="一个构造方法"></a>一个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Character c = <span class="keyword">new</span> Character(<span class="keyword">char</span> value); <span class="comment">//构造一个新分配的 Character 对象，用以表示指定的 char 值。</span></span><br></pre></td></tr></table></figure><h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><p>无论是字符处理还是判断这些方法都是很重要且常用的,方法都是静态方法，可以直接用。<br><img src="/2020/02/15/javabase16-sjfzl/n2.png" alt="Character 类方法"> </p><p>写个demo，验证字符串大小写，并处理为大写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>[] c = &#123; <span class="string">'K'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (Character.isLowerCase(c[i])) &#123;</span><br><span class="line">c[i] = Character.toUpperCase(c[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch : c) &#123;</span><br><span class="line">System.out.print(ch + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/15/javabase16-sjfzl/k.png" alt="运行结果"> </p><h2 id="Boolean-类"><a href="#Boolean-类" class="headerlink" title="Boolean 类"></a>Boolean 类</h2><p>Boolean 类将基本类型为 boolean 的值包装在一个对象中。一个 Boolean 类型的对象只包含一个类型为 boolean 的字段。 </p><p>此外，此类还为 boolean 和 String 的相互转换提供了许多方法，并提供了处理 boolean 时非常有用的其他一些常量和方法。 </p><h3 id="两个构造方法"><a href="#两个构造方法" class="headerlink" title="两个构造方法"></a>两个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean b = <span class="keyword">new</span> Boolean(<span class="keyword">boolean</span> value); <span class="comment">// 分配一个表示 value 参数的 Boolean 对象。 </span></span><br><span class="line">Boolean b = <span class="keyword">new</span> Boolean(String s); <span class="comment">//如果 String 参数不为 null 且在忽略大小写时等于 "true"，则分配一个表示 true 值的 Boolean 对象。否则分配一个表示 false 值的 Boolean 对象.</span></span><br></pre></td></tr></table></figure><p>注：一般情况下都不宜使用 new Boolean(boolean value) 构造方法。若不需要新新的实例，则静态工厂 valueOf(boolean) 通常是一个更好的选择。这有可能显著提高空间和时间性能。 </p><p>注： new Boolean(String s) 字符串参数只能为 true/false 不能时其他，比如 yes/no ，ok 什么的。</p><h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><p>相对其他数据类型方法少的多：<br><img src="/2020/02/15/javabase16-sjfzl/b.png" alt="Boolean 常用方法"><br>其中还有一些静态方法很少用到，不再举例。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>三个常量，经常用：</p><ul><li>TRUE：对应基值 true 的 Boolean 对象。</li><li>FALSE：对应基值 false 的 Boolean 对象。</li><li>TYPE：表示基本类型 boolean 的 Class 对象。</li></ul><h2 id="Byte-类"><a href="#Byte-类" class="headerlink" title="Byte 类"></a>Byte 类</h2><p>Byte 类将基本类型 byte 的值包装在一个对象中。一个 Byte 类型的对象只包含一个类型为 byte 的字段。 </p><p>此外，该类还为 byte 和 String 的相互转换提供了几种方法，并提供了处理 byte 时非常有用的其他一些常量和方法。 </p><h3 id="两个个构造方法"><a href="#两个个构造方法" class="headerlink" title="两个个构造方法"></a>两个个构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Byte b = <span class="keyword">new</span> Byte(<span class="keyword">byte</span> value);<span class="comment">//构造一个新分配的 Byte 对象，以表示指定的 byte 值。 </span></span><br><span class="line">Byte b = <span class="keyword">new</span> Byte(String s); <span class="comment">//构造一个新分配的 Byte 对象，以表示 String 参数所指示的 byte 值。该字符串以使用基数 10 的 parseByte 方法所使用的方式被转换成一个 byte 值。</span></span><br></pre></td></tr></table></figure><p>new Byte(String s) 如果字符串不是 byte值会抛出异常。</p><h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><p>都是一些转换方法：<br><img src="/2020/02/15/javabase16-sjfzl/b1.png" alt="Byte 常用方法"><br>另外还有很多静态方法，感兴趣打开文档看看去。</p><h3 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h3><p>在 Byte 类中包含了很多的常量，其中较为常用的常量如下。</p><ul><li>MIN_VALUE：byte 类可取的最小值。</li><li>MAX_VALUE：byte 类可取的最大值。</li><li>SIZE：用于以二进制补码形式表示的 byte 值的位数。</li><li>TYPE：表示基本类 byte 的 Class 实例。</li></ul><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>内置包装类整完了，看着很多，其实并没多少东西，而且各个类方法都有互通之处，记住一个类就可以了，一般用的的方法都一样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;strong&gt;本篇内容：Integer 类、Float 类、Double 类、Number 类、Character 类、Boolean 类、 Byte 类。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java内置包装类" scheme="http://www.mggblog.ink/tags/Java%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十五）——Object类和System类</title>
    <link href="http://www.mggblog.ink/2020/02/14/javabase15-obj-sys/"/>
    <id>http://www.mggblog.ink/2020/02/14/javabase15-obj-sys/</id>
    <published>2020-02-14T14:36:42.000Z</published>
    <updated>2020-02-14T17:04:49.741Z</updated>
    
    <content type="html"><![CDATA[<p><em>Object类是所有类的父类，System类是系统类，把这俩类放一块写。剩下的数据类型包装类放一块，下回写。</em></p><a id="more"></a><hr><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><p>类 Object 是类层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法（他是所有类的爸爸）。<br>比如随便新建一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实等价于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下他的类方法有哪些：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Object clone()</td><td>创建与该对象的类相同的新对象</td></tr><tr><td>boolean equals(Object)</td><td>比较两对象是否相等</td></tr><tr><td>void finalize()</td><td>当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法</td></tr><tr><td>Class getClass()</td><td>返回一个对象运行时的实例类</td></tr><tr><td>int hashCode()</td><td>返回该对象的散列码值</td></tr><tr><td>void notify()</td><td>激活等待在该对象的监视器上的一个线程</td></tr><tr><td>void notifyAll()</td><td>激活等待在该对象的监视器上的全部线程</td></tr><tr><td>String toString()</td><td>返回该对象的字符串表示</td></tr><tr><td>void wait()</td><td>在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待</td></tr></tbody></table><p>因为 Object 类是所有类的父类，所以这些方法所有类都可以直接用，其中 getClass、equals、toString比较常用。线程相关方法不会出现在业务代码里，用的也比较少，我们写到线程再学：  </p><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p.toString());</span><br><span class="line">System.out.println(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">String name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase15-obj-sys/ts.png" alt="运行结果"><br>结果发现用不用 toString 方法输出结果都是一样的，，这时候我们可以在 Person 类里重写 toString 方法，让他输出一些有价值的东西（这里涉及后面继承的知识，先看看，不理解后面再学，当前重点在 toString ）。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p.toString());</span><br><span class="line">System.out.println(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">String name = <span class="string">"kangkang"</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行<br><img src="/2020/02/14/javabase15-obj-sys/ts2.png" alt="运行结果">  </p><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a>equals() 方法</h3><p>文档中解释：</p><blockquote><p>指示其他某个对象是否与此对象“相等”。<br>equals 方法在非空对象引用上实现相等关系： </p><ul><li>自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 </li><li>对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 </li><li>传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 </li><li>一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 </li><li>对于任何非空引用值 x，x.equals(null) 都应返回 false。 </li><li>Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。<br>注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。 </li></ul></blockquote><p>巴拉巴拉一大堆，以我理解，就是相当于 == 的效果，没什么用，我们在各个包装类里的 equals 方法都被重写了，没什么好说的，拿出来说的目的是提醒这个方法和我们平时用的 equals 不一样。</p><h3 id="getClass-方法"><a href="#getClass-方法" class="headerlink" title="getClass() 方法"></a>getClass() 方法</h3><p>getClass 返回一个 Class 对象，所以这个方法要配合Class 类方法使用，举个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">""</span>;</span><br><span class="line">System.out.println(str.getClass());<span class="comment">// 获取Class对象</span></span><br><span class="line">Method[] ms = str.getClass().getMethods();<span class="comment">//获取所有方法</span></span><br><span class="line">System.out.println(str.getClass().getName()); <span class="comment">//获取Class对象名称</span></span><br><span class="line"><span class="keyword">for</span> (Method m :ms ) &#123;</span><br><span class="line">System.out.println(m.getName()); <span class="comment">// 遍历方法名</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase15-obj-sys/ff.png" alt="运行结果">  </p><p>这个 getclass 到后面反射机制的时候会用到。</p><h2 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h2><p>System 类包含一些有用的类字段和方法。它不能被实例化。   </p><p>在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。 </p><p>我们经常用的 System.out.println() 以及 在控制台输入时 System.in ，那么我们再来了解了解其他常用的系统级方法：</p><h3 id="arraycopy-方法"><a href="#arraycopy-方法" class="headerlink" title="arraycopy() 方法"></a>arraycopy() 方法</h3><p>该方法的作用是数组复制，即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。该方法的具体定义如下：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,<span class="keyword">int</span> srcPos,Object dest,<span class="keyword">int</span> destPos,<span class="keyword">int</span> length)</span></span></span><br></pre></td></tr></table></figure><p>其中，src 表示源数组，srcPos 表示从源数组中复制的起始位置，dest 表示目标数组，destPos 表示要复制到的目标数组的起始位置，length 表示复制的个数。<br>来试一下：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] srcArray = &#123;<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] destArray = &#123;<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>,<span class="string">'H'</span>&#125;;</span><br><span class="line">        System.arraycopy(srcArray,<span class="number">1</span>,destArray,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"源数组："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; srcArray.length;i++) &#123;</span><br><span class="line">            System.out.print(srcArray[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"\n目标数组："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; destArray.length;j++) &#123;</span><br><span class="line">            System.out.print(destArray[j]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line">   </span><br><span class="line">![运行结果](javabase15-obj-sys/cp.png)  </span><br><span class="line">  </span><br><span class="line">### currentTimeMillis() 方法</span><br><span class="line">返回最准确的可用系统计时器的当前值，以毫微秒为单位。与时钟时间无关系，多用于测试代码执行时间。</span><br><span class="line">```java</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000000</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> time = end - start;</span><br><span class="line">        System.out.println(<span class="string">"程序执行时间"</span> + time + <span class="string">"秒"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase15-obj-sys/sj.png" alt="运行结果"> </p><h3 id="exit-方法"><a href="#exit-方法" class="headerlink" title="exit() 方法"></a>exit() 方法</h3><p>终止当前正在运行的 Java 虚拟机。<br>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span></span><br></pre></td></tr></table></figure><p>根据惯例，非 0 的状态码表示异常终止。<br>该方法调用 Runtime 类中的 exit 方法。该方法永远不会正常返回。<br>调用 System.exit(n) 实际上等效于调用： Runtime.getRuntime().exit(n)</p><h3 id="gc-方法"><a href="#gc-方法" class="headerlink" title="gc() 方法"></a>gc() 方法</h3><p>定义：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>运行垃圾回收器。 Java 比 C++ 好的地方之一是有这个 gc 自动回收内存，不用自己管，非要自己调用gc的话用吧，</p><p>调用 gc 方法暗示着 Java 虚拟机做了一些努力来回收未用对象，以便能够快速地重用这些对象当前占用的内存。当控制权从方法调用中返回时，虚拟机已经尽最大努力从所有丢弃的对象中回收了空间。<br>调用 System.gc() 实际上等效于调用： Runtime.getRuntime().gc()</p><h3 id="getProperty-方法"><a href="#getProperty-方法" class="headerlink" title="getProperty() 方法"></a>getProperty() 方法</h3><p>这个方法常用，获取系统中已有的键值对的值。<br>定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getProperty</span><span class="params">(String key)</span></span></span><br></pre></td></tr></table></figure><p>常见系统属性：  </p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>java.version</td><td>Java 运行时环境版本</td></tr><tr><td>java.home</td><td>Java 安装目录</td></tr><tr><td>os.name</td><td>操作系统的名称</td></tr><tr><td>os.version</td><td>操作系统的版本</td></tr><tr><td>user.name</td><td>用户的账户名称</td></tr><tr><td>user.home</td><td>用户的主目录</td></tr><tr><td>user.dir</td><td>用户的当前工作目录</td></tr></tbody></table><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(System.getProperty(<span class="string">"java.home"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase15-obj-sys/jh.png" alt="运行结果"> </p><p>就这样吧，不一一距举例了。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>下一篇一次性把几个数组类型的包装类弄了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Object类是所有类的父类，System类是系统类，把这俩类放一块写。剩下的数据类型包装类放一块，下回写。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java内置包装类" scheme="http://www.mggblog.ink/tags/Java%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十四）——包装类、装箱拆箱</title>
    <link href="http://www.mggblog.ink/2020/02/14/javabase14-bz-zxcx/"/>
    <id>http://www.mggblog.ink/2020/02/14/javabase14-bz-zxcx/</id>
    <published>2020-02-14T11:02:20.000Z</published>
    <updated>2020-02-14T12:25:50.135Z</updated>
    
    <content type="html"><![CDATA[<p><em>Java提倡一切皆对象，是面向对象的语言，但是从数据类型来看，引用型数据有对应的对象类，如String，而基本型数据无法被称为对象，为解决这个尴尬问题，Java为每个基本型数据类提供了对应的类，称为包装类，顾名思义就是给它们外面裹一层。<strong>本篇内容：装箱拆箱，包装类应用。</strong></em></p><a id="more"></a><hr><p>首先我们要对每个基本类型的包装类是什么有所了解，Java提供的包装类除了 int 和 char 的包装类分别为 Integer 和 Character 外，其他包装类都是首字母变大写，还是比较好记的，如下表。</p><table><thead><tr><th>类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><p>这些包装类为对应的数据类型提供了丰富的类方法，比如我们在 String 与 int 类型互转用到的 toString 方法，这么多类型不在一一举例，详情我们后面单独说。</p><h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>顾名思义，装箱是将东西装进去，拆箱是将东西拿出来，对应到包装类操作就分别是：基本型→包装类和包装类→基本型，从jdk1.5版本以来提供了自动装箱拆箱支持，下面来看看如何操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">Integer integer = i; <span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> j = integer; <span class="comment">//自动拆箱</span></span><br><span class="line">System.out.println(<span class="string">"拆箱后j="</span>+j);</span><br><span class="line">Integer integer2 = <span class="keyword">new</span> Integer(j);<span class="comment">//手动装箱</span></span><br><span class="line"><span class="keyword">int</span> k = integer2.intValue(); <span class="comment">//手动拆箱</span></span><br><span class="line">System.out.println(<span class="string">"拆箱后k="</span>+k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase14-bz-zxcx/zxcx.png" alt="运行结果"></p><h2 id="包装类应用"><a href="#包装类应用" class="headerlink" title="包装类应用"></a>包装类应用</h2><p>手动自动拆装都试过了，装箱为的是使用箱子给提供的方法，最常用就是类型转换，在这里用 int String 互转举例，后面我们在详细说各个包装类：</p><ol><li><p>int 类型数据 转为 String ,我们以后都用自动装箱。<br>要用到 Integer 类中 toString();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">Integer integer = i; <span class="comment">// 自动装箱</span></span><br><span class="line">String str = integer.toString();</span><br><span class="line">System.out.println(<span class="string">"装换后字符串："</span> + str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase14-bz-zxcx/izs.png" alt="运行结果">  </p></li><li><p>String 转 int ，使用 Integer.parseInt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"100"</span>;</span><br><span class="line"><span class="keyword">int</span> i =  Integer.parseInt(str);<span class="comment">// 自动拆箱，不拆也没关系</span></span><br><span class="line">System.out.println(<span class="string">"str*2="</span>+i*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase14-bz-zxcx/szi.png" alt="运行结果">  </p></li></ol><p>拆箱装箱的目的就是要使用类方法达到一定目的，到后面封装方法也是一样的目的。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>这篇内容比较少，主要做个介绍，虽然两个概念词听起来很高大上，其实我们前面已经用到过了，后面的各个包装类，我打算分两次弄完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Java提倡一切皆对象，是面向对象的语言，但是从数据类型来看，引用型数据有对应的对象类，如String，而基本型数据无法被称为对象，为解决这个尴尬问题，Java为每个基本型数据类提供了对应的类，称为包装类，顾名思义就是给它们外面裹一层。&lt;strong&gt;本篇内容：装箱拆箱，包装类应用。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java内置包装类" scheme="http://www.mggblog.ink/tags/Java%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十三）——时间日期处理（Date、Calendar、时间格式化）</title>
    <link href="http://www.mggblog.ink/2020/02/14/javabase13-szcl/"/>
    <id>http://www.mggblog.ink/2020/02/14/javabase13-szcl/</id>
    <published>2020-02-14T02:04:05.000Z</published>
    <updated>2020-02-14T11:17:12.790Z</updated>
    
    <content type="html"><![CDATA[<p><em>在开发中做数据持久化时常常需要统一的时间格式，统一查询口径，方便查询，Java提供了日期处理类 Date 和 Calendar ，Date类封装了系统时间，Calendar 根据系统日历解释 Date 对象，两个类处理时间的思路不一样。<strong>本篇内容包括：Date 类与 Calendar 类使用介绍，日期格式化</strong></em></p><a id="more"></a><hr><h2 id="Date-类"><a href="#Date-类" class="headerlink" title="Date 类"></a>Date 类</h2><p>类 Date 表示特定的瞬间，精确到毫秒(Java中还有一个 Date 类，全称为java.sql.Date,这个类是sql相关时间类，我们平时用到的是java.util.Date,导包的时候注意别导错了)。它表示时间的顺序是星期、月、日、小时、分、秒、年。打开jdk帮助文档，我们发现 Date 类未过时的构造方法有两个，分别是：</p><ul><li>Date()  分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒）。</li><li>Date(long date)  分配 Date 对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即 1970 年 1 月 1 日 00:00:00 GMT）以来的指定毫秒数。<br>举个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">Date d2 = <span class="keyword">new</span> Date(<span class="number">80000000</span>);</span><br><span class="line">System.out.println(d1);</span><br><span class="line">System.out.println(d2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/02/14/javabase13-szcl/sj1.png" alt="输出结果"></li></ul><p>同样我们看到文档中大量方法已经过时，我在下面整理出来可以正常用的：  </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean after(Date when)</td><td>判断此日期是否在指定日期之后</td></tr><tr><td>boolean before(Date when)</td><td>判断此日期是否在指定日期之前</td></tr><tr><td>int compareTo(Date anotherDate)</td><td>比较两个日期的顺序</td></tr><tr><td>boolean equals(Object obj)</td><td>比较两个日期的相等性</td></tr><tr><td>long getTime()</td><td>返回自 1970 年 1 月 1 日 00:00:00 GMT 以来，此 Date 对象表示的毫秒数</td></tr><tr><td>String toString()</td><td>把此 Date 对象转换为以下形式的 String: dow mon dd  hh:mm:ss zzz yyyy。其中 dow 是一周中的某一天(Sun、Mon、Tue、Wed、Thu、Fri 及 Sat)</td></tr></tbody></table><p>做个练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Date d1 = <span class="keyword">new</span> Date();</span><br><span class="line">Date d2 = <span class="keyword">new</span> Date(<span class="number">80000000</span>);</span><br><span class="line">System.out.println(d1.after(d2));</span><br><span class="line">System.out.println(d1.before(d2));</span><br><span class="line">System.out.println(d1.compareTo(d2));<span class="comment">// 相等返回 0 大于返回1 小于返回-1</span></span><br><span class="line">System.out.println(d1.equals(d2));</span><br><span class="line">System.out.println(d1.getTime());</span><br><span class="line">System.out.println(d1.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/14/javabase13-szcl/sj2.png" alt="输出结果"></p><h2 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h2><p>Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 </p><p>因为 Calendar 是一个抽象类，无法像普通类一样 new 一个对象出来，它提供了 getInstance() 方法来完成对象创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar c  = Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>Calendar 提供了众多时间处理方法，我们有个大致了解： </p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void add(int field, int amount)</td><td>根据日历的规则，为给定的日历字段 field 添加或减去指定的时间量 amount</td></tr><tr><td>boolean after(Object when)</td><td>判断此 Calendar 表示的时间是否在指定时间 when 之后，并返回判断结果</td></tr><tr><td>boolean before(Object when)</td><td>判断此 Calendar 表示的时间是否在指定时间 when 之前，并返回判断结果</td></tr><tr><td>void clear()</td><td>清空 Calendar 中的日期时间值</td></tr><tr><td>int compareTo(Calendar anotherCalendar)</td><td>比较两个 Calendar 对象表示的时间值（从格林威治时间 1970 年 01 月 01 日00 时 00 分 00 秒至现在的毫秒偏移量），大则返回 1，小则返回 -1，相等返回 0</td></tr><tr><td>int get(int field)</td><td>返回指定日历字段的值</td></tr><tr><td>int getActualMaximum(int field)</td><td>返回指定日历字段可能拥有的最大值</td></tr><tr><td>int getActualMinimum(int field)</td><td>返回指定日历字段可能拥有的最小值</td></tr><tr><td>int getFirstDayOfWeek()</td><td>获取一星期的第一天。根据不同的国家地区，返回不同的值</td></tr><tr><td>static Calendar getInstance()</td><td>使用默认时区和语言坏境获得一个日历</td></tr><tr><td>static Calendar getInstance(TimeZone zone)</td><td>使用指定时区和默认语言环境获得一个日历</td></tr><tr><td>static Calendar getInstance(TimeZone zone,Locale aLocale)</td><td>使用指定时区和语言环境获得一个日历</td></tr><tr><td>Date getTime()</td><td>返回一个表示此 Calendar 时间值（从格林威治时间 1970 年 01 月 01 日 00 时00 分 00 秒至现在的毫秒偏移量）的 Date 对象</td></tr><tr><td>long getTimeInMillis()</td><td>返回此 Calendar 的时间值，以毫秒为单位</td></tr><tr><td>void set(int field, int value)</td><td>为指定的日历字段设置给定值</td></tr><tr><td>void set(int year, int month, int date)</td><td>设置日历字段 YEAR、MONTH 和 DAY_OF_MONTH 的值</td></tr><tr><td>void set(int year, int month, int date, int hourOfDay,int minute, int second)</td><td>设置字段 YEAR、MONTH、DAY_OF_MONTH、HOUR、 MINUTE 和 SECOND 的值</td></tr><tr><td>void setFirstDayOfWeek(int value)</td><td>设置一星期的第一天是哪一天</td></tr><tr><td>void setTimeInMillis(long millis)</td><td>用给定的 long 值设置此 Calendar 的当前时间值</td></tr></tbody></table><p>Calendar 对象可以调用 set() 方法将日历翻到任何一个时间，当参数 year 取负数时表示公元前。Calendar 对象调用 get() 方法可以获取有关年、月、日等时间信息，参数 field 的有效值由 Calendar 静态常量指定。</p><p><strong>Calendar 类中定义了许多常量，分别表示不同的意义。</strong></p><ul><li>Calendar.YEAR：年份。</li><li>Calendar.MONTH：月份。</li><li>Calendar.DATE：日期。</li><li>Calendar.DAY_OF_MONTH：日期，和上面的字段意义完全相同。</li><li>Calendar.HOUR：12小时制的小时。</li><li>Calendar.HOUR_OF_DAY：24 小时制的小时。</li><li>Calendar.MINUTE：分钟。</li><li>Calendar.SECOND：秒。</li><li>Calendar.DAY_OF_WEEK：星期几。</li></ul><p>例如我们要获取当前月份：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> month = Calendar.getInstance().get(Calendar.MONTH);</span><br></pre></td></tr></table></figure><p>方法都用用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Calendar calendar = Calendar.getInstance(); <span class="comment">// 如果不设置时间，则默认为当前时间</span></span><br><span class="line">calendar.setTime(<span class="keyword">new</span> Date()); <span class="comment">// 将系统当前时间赋值给 Calendar 对象</span></span><br><span class="line">System.out.println(<span class="string">"现在时刻："</span> + calendar.getTime()); <span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="keyword">int</span> year = calendar.get(Calendar.YEAR); <span class="comment">// 获取当前年份</span></span><br><span class="line">System.out.println(<span class="string">"现在是"</span> + year + <span class="string">"年"</span>);</span><br><span class="line"><span class="keyword">int</span> month = calendar.get(Calendar.MONTH) + <span class="number">1</span>; <span class="comment">// 获取当前月份（月份从 0 开始，所以加 1）</span></span><br><span class="line">System.out.print(month + <span class="string">"月"</span>);</span><br><span class="line"><span class="keyword">int</span> day = calendar.get(Calendar.DATE); <span class="comment">// 获取日</span></span><br><span class="line">System.out.print(day + <span class="string">"日"</span>);</span><br><span class="line"><span class="keyword">int</span> week = calendar.get(Calendar.DAY_OF_WEEK) - <span class="number">1</span>; <span class="comment">// 获取今天星期几（以星期日为第一天）</span></span><br><span class="line">System.out.print(<span class="string">"星期"</span> + week);</span><br><span class="line"><span class="keyword">int</span> hour = calendar.get(Calendar.HOUR_OF_DAY); <span class="comment">// 获取当前小时数（24 小时制）</span></span><br><span class="line">System.out.print(hour + <span class="string">"时"</span>);</span><br><span class="line"><span class="keyword">int</span> minute = calendar.get(Calendar.MINUTE); <span class="comment">// 获取当前分钟</span></span><br><span class="line">System.out.print(minute + <span class="string">"分"</span>);</span><br><span class="line"><span class="keyword">int</span> second = calendar.get(Calendar.SECOND); <span class="comment">// 获取当前秒数</span></span><br><span class="line">System.out.print(second + <span class="string">"秒"</span>);</span><br><span class="line"><span class="keyword">int</span> millisecond = calendar.get(Calendar.MILLISECOND); <span class="comment">// 获取毫秒数</span></span><br><span class="line">System.out.print(millisecond + <span class="string">"毫秒"</span>);</span><br><span class="line"><span class="keyword">int</span> dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH); <span class="comment">// 获取今天是本月第几天</span></span><br><span class="line">System.out.println(<span class="string">"今天是本月的第 "</span> + dayOfMonth + <span class="string">" 天"</span>);</span><br><span class="line"><span class="keyword">int</span> dayOfWeekInMonth = calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH); <span class="comment">// 获取今天是本月第几周</span></span><br><span class="line">System.out.println(<span class="string">"今天是本月第 "</span> + dayOfWeekInMonth + <span class="string">" 周"</span>);</span><br><span class="line"><span class="keyword">int</span> many = calendar.get(Calendar.DAY_OF_YEAR); <span class="comment">// 获取今天是今年第几天</span></span><br><span class="line">System.out.println(<span class="string">"今天是今年第 "</span> + many + <span class="string">" 天"</span>);</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">c.set(<span class="number">2008</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment">// 设置年月日，时分秒将默认采用当前值</span></span><br><span class="line">System.out.println(<span class="string">"设置日期为 2008-8-8 后的时间："</span> + c.getTime()); <span class="comment">// 输出时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/14/javabase13-szcl/sj3.png" alt="输出结果"></p><p>到后面我们专门写个日历的博客，以现在的进度放在这里写有点不合适（先挖个坑）。</p><h2 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h2><p>大多数时候我们不能直接使用 Date 类提供的时间格式，Date 原时间格式用的最多的时候应该是写系统日志，这是专门给人看的，只要可以分辨就可以了。但是大多数业务逻辑下，时间都是要存入数据库，要通过时间来查询，如果直接存时间戳进去，数据库sql写着比较麻烦，还要转格式，比如我把日期用String格式存起来（20200214000000），写查询sql的时候就可以直接用了。</p><p>Java为我们提供了 DateFormat 类和它的子类 SimpleDateFormat 类来完成日期格式化，下面我们一起来看一看。</p><h3 id="DateFormat-类"><a href="#DateFormat-类" class="headerlink" title="DateFormat 类"></a>DateFormat 类</h3><p>DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。将日期表示为 Date 对象，或者表示为从 GMT（格林尼治标准时间）1970 年 1 月 1 日 00:00:00 这一刻开始的毫秒数。 </p><p>因为是抽象类，所以也不能使用 new 来创建实例对象，使用静态类方法 getDateInstance() :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateFormat df = DateFormat.getDatelnstance();</span><br></pre></td></tr></table></figure><p>创建完对象，我们来看一下它的类方法：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>String format(Date date)    将 Date 格式化日期/时间字符串</td><td></td></tr><tr><td>Calendar getCalendar()</td><td>获取与此日期/时间格式相关联的日历</td></tr><tr><td>static DateFormat getDateInstance()</td><td>获取具有默认格式化风格和默认语言环境的日期格式</td></tr><tr><td>static DateFormat getDateInstance(int style)</td><td>获取具有指定格式化风格和默认语言环境的日期格式</td></tr><tr><td>static DateFormat getDateInstance(int style,Locale locale)</td><td>获取具有指定格式化风格和指定语言环境的日期格式</td></tr><tr><td>static DateFormat getDateTimeInstance()</td><td>获取具有默认格式化风格和默认语言环境的日期/时间格式</td></tr><tr><td>static DateFormat getDateTimeInstance(int dateStyle,int timeStyle)</td><td>获取具有指定日期/时间格式化风格和默认语言环境的日期/时间格式</td></tr><tr><td>static DateFormat getDateTimeInstance(int dateStyle,int timeStyle,Locale locale)</td><td>获取具有指定日期/时间格式化风格和指定语言环境的日期/时间格式</td></tr><tr><td>static DateFormat getTimeInstance()</td><td>获取具有默认格式化风格和默认语言环境的时间格式</td></tr><tr><td>static DateFormat getTimeInstance(int style)</td><td>获取具有指定格式化风格和默认语言环境的时间格式</td></tr><tr><td>static DateFormat getTimeInstance(int style,Locale locale)</td><td>获取具有指定格式化风格和指定语言环境的时间格式</td></tr><tr><td>void setCalendar(Calendar newCalendar)</td><td>为此格式设置日历</td></tr><tr><td>Date parse(String source)</td><td>将给定的字符串解析成日期/时间</td></tr></tbody></table><p>格式化样式主要通过 DateFormat 常量设置。将不同的常量传入到表 1 所示的方法中，以控制结果的长度。DateFormat 类的常量如下。</p><ul><li>SHORT：完全为数字，如 12.5.10 或 5:30pm。</li><li>MEDIUM：较长，如 May 10，2016。</li><li>LONG：更长，如 May 12，2016 或 11:15:32am。</li><li>FULL：是完全指定，如 Tuesday、May 10、2012 AD 或 11:l5:42am CST。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获取不同格式化风格和中国环境的日期</span></span><br><span class="line">DateFormat df1 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line">DateFormat df2 = DateFormat.getDateInstance(DateFormat.FULL, Locale.CHINA);</span><br><span class="line">DateFormat df3 = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.CHINA);</span><br><span class="line">DateFormat df4 = DateFormat.getDateInstance(DateFormat.LONG, Locale.CHINA);</span><br><span class="line"><span class="comment">// 获取不同格式化风格和中国环境的时间</span></span><br><span class="line">DateFormat df5 = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line">DateFormat df6 = DateFormat.getTimeInstance(DateFormat.FULL, Locale.CHINA);</span><br><span class="line">DateFormat df7 = DateFormat.getTimeInstance(DateFormat.MEDIUM, Locale.CHINA);</span><br><span class="line">DateFormat df8 = DateFormat.getTimeInstance(DateFormat.LONG, Locale.CHINA);</span><br><span class="line"><span class="comment">// 将不同格式化风格的日期格式化为日期字符串</span></span><br><span class="line">String date1 = df1.format(<span class="keyword">new</span> Date());</span><br><span class="line">String date2 = df2.format(<span class="keyword">new</span> Date());</span><br><span class="line">String date3 = df3.format(<span class="keyword">new</span> Date());</span><br><span class="line">String date4 = df4.format(<span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">// 将不同格式化风格的时间格式化为时间字符串</span></span><br><span class="line">String time1 = df5.format(<span class="keyword">new</span> Date());</span><br><span class="line">String time2 = df6.format(<span class="keyword">new</span> Date());</span><br><span class="line">String time3 = df7.format(<span class="keyword">new</span> Date());</span><br><span class="line">String time4 = df8.format(<span class="keyword">new</span> Date());</span><br><span class="line"><span class="comment">// 输出日期</span></span><br><span class="line">System.out.println(<span class="string">"SHORT："</span> + date1 + <span class="string">" "</span> + time1);</span><br><span class="line">System.out.println(<span class="string">"FULL："</span> + date2 + <span class="string">" "</span> + time2);</span><br><span class="line">System.out.println(<span class="string">"MEDIUM："</span> + date3 + <span class="string">" "</span> + time3);</span><br><span class="line">System.out.println(<span class="string">"LONG："</span> + date4 + <span class="string">" "</span> + time4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/14/javabase13-szcl/sj4.png" alt="输出结果"></p><p>虽然输出的时间更容易理解了，但是并不能达到要求，我们还需要更加定制化的时间格式，这时候就要有请 Calendar的儿子 SimpleDateFormat 类上场了。</p><h3 id="SimpleDateFormat-类"><a href="#SimpleDateFormat-类" class="headerlink" title="SimpleDateFormat 类"></a>SimpleDateFormat 类</h3><p>SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。</p><p>这个类是最常用的类了，至少我在格式化时间的时候都用它，功能强大，随心所欲。<br>SimpleDateFormat 有四个构造方法，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下三种构造依赖语言环境，可能无法适应特定的语言环境</span></span><br><span class="line">SimpleDateFormat sdf  = SimpleDateFormat();</span><br><span class="line">SimpleDateFormat sdf  = SimpleDateFormat(String pattern);</span><br><span class="line">SimpleDateFormat sdf  = SimpleDateFormat(String pattern,Locale locale);</span><br><span class="line"><span class="comment">//用给定的模式和日期符号构造 SimpleDateFormat。</span></span><br><span class="line">SimpleDateFormat sdf  = SimpleDateFormat(String pattern,DateFormatSymbols formatSymbols);</span><br></pre></td></tr></table></figure><p>要用文本解析时间或者时间解析文本就要有文本规范，不能随便写，SimpleDateFormat 解析文本通过字母符号组成的文本，字母文本都比较好记：</p><p><img src="/2020/02/14/javabase13-szcl/sjzm.png" alt="字母意义与示例"></p><p>以及解析字符串的例子，以美国时间模式为例（这就是上面说的语言环境）：</p><p><img src="/2020/02/14/javabase13-szcl/sjzfc.png" alt="字符串解析示例"></p><p>我们举一个最常用到方法的例子， 按2020-02-14 12:00:00 形式输出当前时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">String time = df.format(d);</span><br><span class="line">System.out.print(time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/14/javabase13-szcl/now.png" alt="运行结果">  </p><p>只要记住大小写字母代表的意义就可以了，记不住差文档也可以，反正这种时间格式化的代码不会天天写，而且现在有专门时间格式化的开源包，比如我用过的 <a href="https://www.joda.org/joda-time/userguide.html">JodaTime</a> ,感兴趣可以了解一下，虽然自己不用处理时间，但是我还是感觉 时间统一用 “ yyyyMMddHHmmss “这种格式简单粗暴，省了好多事。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>时间处理知道这些足够了，忘了就翻文档，搜博客，还有一种需求是求特定的哪一天是周几啊，距离现在几天啊这种。这就是思想延伸的东西了，这里就不介绍了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;在开发中做数据持久化时常常需要统一的时间格式，统一查询口径，方便查询，Java提供了日期处理类 Date 和 Calendar ，Date类封装了系统时间，Calendar 根据系统日历解释 Date 对象，两个类处理时间的思路不一样。&lt;strong&gt;本篇内容包括：Date 类与 Calendar 类使用介绍，日期格式化&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java时间日期处理" scheme="http://www.mggblog.ink/tags/Java%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十二）——数字处理类（Math，Random，BigInteger，BigDecimal）</title>
    <link href="http://www.mggblog.ink/2020/02/13/javabase12-math/"/>
    <id>http://www.mggblog.ink/2020/02/13/javabase12-math/</id>
    <published>2020-02-13T11:52:36.456Z</published>
    <updated>2020-02-14T11:17:20.167Z</updated>
    
    <content type="html"><![CDATA[<p><em>只用四则运算符无法完成三角、对数、指数等复杂运算，以及非常大的数字运算，Java提供Math等类解决问题，<strong>本篇内容有：Math类常用方法，随机数生成，数字格式化，大数字运算。</strong></em></p><a id="more"></a><hr><h2 id="Math类常用方法"><a href="#Math类常用方法" class="headerlink" title="Math类常用方法"></a>Math类常用方法</h2><p>挑一些经常用到的，有静态常量（自然数e，圆周率π）、求最大最小值和绝对值、求整、三角函数、指数运算，其实最常用的就是最大最小值和求整了。</p><h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><p>自然数e和圆周率π：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//e</span></span><br><span class="line">Math.E;</span><br><span class="line"><span class="comment">//π</span></span><br><span class="line">Math.PI;</span><br></pre></td></tr></table></figure><p>我们控制台输出看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"e="</span>+Math.E);</span><br><span class="line">System.out.println(<span class="string">"π="</span>+Math.PI);</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/epi.png" alt="输出结果"></p><h2 id="求最大最小值和绝对值"><a href="#求最大最小值和绝对值" class="headerlink" title="求最大最小值和绝对值"></a>求最大最小值和绝对值</h2><p>最常用功能，几个函数搞定，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.方法名;</span><br></pre></td></tr></table></figure><p>函数与说明：   </p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>static int abs(int a)</td><td>返回 a 的绝对值</td></tr><tr><td>static long abs(long a)</td><td>返回 a 的绝对值</td></tr><tr><td>static float abs(float a)</td><td>返回 a 的绝对值</td></tr><tr><td>static double abs(double a)</td><td>返回 a 的绝对值</td></tr><tr><td>static int max(int x,int y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static double max(double x,double y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static long max(long x,long y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static float max(float x,float y)</td><td>返回 x 和 y 中的最大值</td></tr><tr><td>static int min(int x,int y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static long min(long x,long y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static double min(double x,double y)</td><td>返回 x 和 y 中的最小值</td></tr><tr><td>static float min(float x,float y)</td><td>返回 x 和 y 中的最小值</td></tr></tbody></table><p>实践一下，分别求一下最大值最小值与绝对值：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">29</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">98</span>;</span><br><span class="line">  <span class="keyword">int</span> k = -<span class="number">200</span>;</span><br><span class="line">  System.out.println(Math.max(i, j));</span><br><span class="line">  System.out.println(Math.min(i, j));</span><br><span class="line">  System.out.println(Math.abs(k));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/jd.png" alt="输出结果"></p><h3 id="求整运算"><a href="#求整运算" class="headerlink" title="求整运算"></a>求整运算</h3><p>多用在需要不要求高精度数据展示的时候，使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.方法名;</span><br></pre></td></tr></table></figure><p>函数与说明：  </p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>static double ceil(double a)</td><td>返回大于或等于 a 的最小整数</td></tr><tr><td>static double floor(double a)</td><td>返回小于或等于 a 的最大整数</td></tr><tr><td>static double rint(double a)</td><td>返回最接近 a 的整数值，如果有两个同样接近的整数，则结果取偶数</td></tr><tr><td>static int round(float a)</td><td>将参数加上 1/2 后返回与参数最近的整数</td></tr><tr><td>static long round(double a)</td><td>将参数加上 1/2 后返回与参数最近的整数，然后强制转换为长整型</td></tr></tbody></table><p>实践一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      <span class="keyword">double</span> num = input.nextDouble();</span><br><span class="line">      System.out.println(<span class="string">"大于或等于 "</span>+ num +<span class="string">" 的最小整数："</span> + Math.ceil(num));</span><br><span class="line">      System.out.println(<span class="string">"小于或等于 "</span>+ num +<span class="string">" 的最大整数："</span> + Math.floor(num));</span><br><span class="line">      System.out.println(<span class="string">"将 "</span>+ num +<span class="string">" 加上 0.5 之后最接近的整数："</span> + Math.round(num));</span><br><span class="line">      System.out.println(<span class="string">"最接近 "</span>+num+<span class="string">" 的整数："</span> + Math.rint(num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/qz.png" alt="输出结果"></p><h3 id="三角函数运算"><a href="#三角函数运算" class="headerlink" title="三角函数运算"></a>三角函数运算</h3><p>大概要做加密，或者数学运算软件才会用到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.方法名;</span><br></pre></td></tr></table></figure><p>函数与说明：   </p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>static double sin(double a)</td><td>返回角的三角正弦值，参数以孤度为单位</td></tr><tr><td>static double cos(double a)</td><td>返回角的三角余弦值，参数以孤度为单位</td></tr><tr><td>static double asin(double a)</td><td>返回一个值的反正弦值，参数域在 [-1,1]，值域在 [-PI/2,PI/2]</td></tr><tr><td>static double acos(double a)</td><td>返回一个值的反余弦值，参数域在 [-1,1]，值域在 [0.0,PI]</td></tr><tr><td>static double tan(double a)</td><td>返回角的三角正切值，参数以弧度为单位</td></tr><tr><td>static double atan(double a)</td><td>返回一个值的反正切值，值域在 [-PI/2,PI/2]</td></tr><tr><td>static double toDegrees(double angrad)</td><td>将用孤度表示的角转换为近似相等的用角度表示的角</td></tr><tr><td>staticdouble toRadians(double angdeg)</td><td>将用角度表示的角转换为近似相等的用弧度表示的角</td></tr></tbody></table><p>来实践一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  System.out.println(<span class="string">"90 度的正弦值："</span> + Math.sin(Math.PI/<span class="number">2</span>));</span><br><span class="line">      System.out.println(<span class="string">"0 度的余弦值："</span> + Math.cos(<span class="number">0</span>));</span><br><span class="line">      System.out.println(<span class="string">"0.5 的反正切值："</span> + Math.atan(<span class="number">0.5</span>));</span><br><span class="line">      System.out.println(<span class="string">"120 度的弧度值："</span> + Math.toRadians(<span class="number">120.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/pi.png" alt="输出结果"></p><h3 id="指数与对数运算"><a href="#指数与对数运算" class="headerlink" title="指数与对数运算"></a>指数与对数运算</h3><p>也是很少用到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.方法名;</span><br></pre></td></tr></table></figure><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>static double exp(double a)</td><td>返回 e 的 a 次幂</td></tr><tr><td>static double pow(double a,double b)</td><td>返回以 a 为底数，以 b 为指数的幂值</td></tr><tr><td>static double sqrt(double a)</td><td>返回 a 的平方根</td></tr><tr><td>static double cbrt(double a)</td><td>返回 a 的立方根</td></tr><tr><td>static double log(double a)</td><td>返回 a 的自然对数，即 lna 的值</td></tr><tr><td>static double log10(double a)</td><td>返回以 10 为底 a 的对数</td></tr></tbody></table><p>实践一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">      System.out.println(<span class="string">"2 的立方值："</span> + Math.pow(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">      System.out.println(<span class="string">"10 的平方根："</span> + Math.sqrt(<span class="number">10</span>));</span><br><span class="line">      System.out.println(<span class="string">"10 为底 2 的对数："</span> + Math.log10(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/log.png" alt="输出结果"></p><blockquote><p>观察发现Java并没有提供log a（b）的方法，因为Java提供的两个对数方法已经足够计算机算对数用了，如果需要计算普通对数，我们可以变通一下，利用高中数学里用到的换底公式，log a (b) = log n (b) / log n (a) ,我们把 n 代为自然数 e 就可以了,当然log10()也是可以的。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">  &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">    System.out.println(&quot;8 为底 2 的对数：&quot; + (Math.log(8) &#x2F; Math.log(2))); &#x2F;&#x2F; 3.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h2><p>随机数也是非常常用的功能，比如需要从数据库随机抓取数据，Java中的 Random 类提供众多生成随机数的方法，另外 Math 类也提供了一个生成随机数的方法 Math.random()，还有一种野路子，使用 currentTimeMillis（时间处理会用到，可以先了解一下） 获取毫秒值 取模生成随机数。一般情况下生成整数随机数的需求比较多一点。</p><h3 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h3><p>如果只是随便生成一个 float 随机数，那用这个是非常合适的选择，因为 Math 是静态类，不用new 来新建对象。这个方法返回带正号的 double 值，该值大于等于 0.0 且小于 1.0，但是我们可以通过乘法来扩大数值，然后通过加减运算再取整函数来获得一个符合预期的随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  System.out.println(Math.random()); <span class="comment">//0.24037287785722083</span></span><br><span class="line">  <span class="comment">//比如我想要一个100 以内的随机数</span></span><br><span class="line">  System.out.println((<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>)); <span class="comment">//39</span></span><br><span class="line">  <span class="comment">//想得到一个50-100的随机数</span></span><br><span class="line">  System.out.println((<span class="keyword">int</span>)(<span class="number">50</span>+(Math.random()*(<span class="number">100</span>-<span class="number">50</span>)))); <span class="comment">//68</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论是这个方法取随机还是用 Random类 生成特定范围内的随机数，算法都是一样的 <strong>( int )(min + ( 方法 *( max - main )))</strong> 。用 currentTimeMillis() 略有不同 把中间乘号改为取模( % )。</p></blockquote><h3 id="Random-类方法"><a href="#Random-类方法" class="headerlink" title="Random 类方法"></a>Random 类方法</h3><p>Random 类为我们提供了整套的随机数生成方案，足够日常业务需求使用。我们打开JDK帮助文档看看吧（变懒了不想手写表格了），首先是用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先需要新建 Random 对象</span></span><br><span class="line">Random rd = newRandom();</span><br><span class="line"><span class="comment">//重载构造 带种子的对象</span></span><br><span class="line">Random rd = newRandom(<span class="keyword">long</span> seed);</span><br><span class="line"><span class="comment">//然后调用方法</span></span><br><span class="line">类型 变量名 = rd.方法;</span><br></pre></td></tr></table></figure><p>看图：<br><img src="/2020/02/13/javabase12-math/rd.png" alt="random 类"></p><p>方法我们不做详细说明等会直接写个demo，我们说一下这个种子是什么鬼。种子在这里可能是翻译问题，用标识说更贴切，如 new Random(1) 当运行的时候用 1 的标识生成的随机数，即使再运行也不会变；如果是 new Random() 同个方法每次运行生成的随机数都会不一样。  </p><p>我们把这段代码运行两次：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  Random rd1 = <span class="keyword">new</span> Random(<span class="number">1</span>);</span><br><span class="line">  Random rd2 = <span class="keyword">new</span> Random();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    System.out.print(rd1.nextInt(<span class="number">100</span>)+<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"\n~~~~~~~~~~~~~~"</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    System.out.print(rd2.nextInt(<span class="number">100</span>)+<span class="string">" "</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行第一次<br><img src="/2020/02/13/javabase12-math/r1.png" alt="第一次"><br>运行第二次<br><img src="/2020/02/13/javabase12-math/r2.png" alt="第二次">  </p><p>我们看到使用种子创建对象的类方法产生的随机数是一样的，在实际使用的时候还是不带种子的多一些。</p><p>把其他方法都跑一下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  Random r = <span class="keyword">new</span> Random();</span><br><span class="line">  <span class="keyword">double</span> d1 = r.nextDouble(); <span class="comment">// 生成[0,1.0]区间的小数</span></span><br><span class="line">  <span class="keyword">double</span> d2 = r.nextDouble() * <span class="number">7</span>; <span class="comment">// 生成[0,7.0]区间的小数</span></span><br><span class="line">  <span class="keyword">int</span> i1 = r.nextInt(<span class="number">10</span>); <span class="comment">// 生成[0,10]区间的整数</span></span><br><span class="line">  <span class="keyword">int</span> i2 = r.nextInt(<span class="number">18</span>) - <span class="number">3</span>; <span class="comment">// 生成[-3,15]区间的整数</span></span><br><span class="line">  <span class="keyword">long</span> l1 = r.nextLong(); <span class="comment">// 生成一个随机长整型值</span></span><br><span class="line">  <span class="keyword">boolean</span> b1 = r.nextBoolean(); <span class="comment">// 生成一个随机布尔型值</span></span><br><span class="line">  <span class="keyword">float</span> f1 = r.nextFloat(); <span class="comment">// 生成一个随机浮点型值</span></span><br><span class="line">  System.out.println(<span class="string">"生成的[0,1.0]区间的小数是："</span> + d1);</span><br><span class="line">  System.out.println(<span class="string">"生成的[0,7.0]区间的小数是："</span> + d2);</span><br><span class="line">  System.out.println(<span class="string">"生成的[0,10]区间的整数是："</span> + i1);</span><br><span class="line">  System.out.println(<span class="string">"生成的[-3,15]区间的整数是："</span> + i2);</span><br><span class="line">  System.out.println(<span class="string">"生成一个随机长整型值："</span> + l1);</span><br><span class="line">  System.out.println(<span class="string">"生成一个随机布尔型值："</span> + b1);</span><br><span class="line">  System.out.println(<span class="string">"生成一个随机浮点型值："</span> + f1);</span><br><span class="line">  System.out.print(<span class="string">"下期七星彩开奖号码预测："</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = r.nextInt(<span class="number">9</span>); <span class="comment">// 生成[0,9]区间的整数</span></span><br><span class="line">    System.out.print(num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/sj.png" alt="运行结果"></p><h3 id="currentTimeMillis"><a href="#currentTimeMillis" class="headerlink" title="currentTimeMillis()"></a>currentTimeMillis()</h3><p>这是个牛逼的野路子，大佬的思路我们不懂，一般我们也不会用这个，不详细说了，举个例子带过吧。</p><p>方法返回从1970年1月1日0时0分0秒（这与UNIX系统有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> max = <span class="number">100</span>, min = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">long</span> randomNum = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">int</span> ran3 = (<span class="keyword">int</span>) (randomNum % (max - min) + min);</span><br><span class="line">  System.out.println(ran3);<span class="comment">// 60</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h2><p>数字的格式在解决实际问题时使用非常普遍，这时可以使用 DecimalFormat 类对结果进行格式化处理。例如，将小数位统一成 2 位，不足 2 位的以 0 补齐。<br>DecimalFormat 是 NumberFormat 的一个子类，用于格式化十进制数字。DecimalFormat 类包含一个模式和一组符号，常用符号看图<br><img src="/2020/02/13/javabase12-math/sjgs.png" alt="常用符号"><br>举个例子：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化DecimalFormat类的对象，并指定格式</span></span><br><span class="line">  DecimalFormat df1 = <span class="keyword">new</span> DecimalFormat(<span class="string">"0.0"</span>);</span><br><span class="line">  DecimalFormat df2 = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.#"</span>);</span><br><span class="line">  DecimalFormat df3 = <span class="keyword">new</span> DecimalFormat(<span class="string">"000.000"</span>);</span><br><span class="line">  DecimalFormat df4 = <span class="keyword">new</span> DecimalFormat(<span class="string">"###.###"</span>);</span><br><span class="line">  Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">  System.out.print(<span class="string">"请输入一个float类型的数字："</span>);</span><br><span class="line">  <span class="keyword">float</span> f = scan.nextFloat();</span><br><span class="line">  <span class="comment">// 对输入的数字应用格式，并输出结果</span></span><br><span class="line">  System.out.println(<span class="string">"0.0 格式："</span> + df1.format(f));</span><br><span class="line">  System.out.println(<span class="string">"#.# 格式："</span> + df2.format(f));</span><br><span class="line">  System.out.println(<span class="string">"000.000 格式："</span> + df3.format(f));</span><br><span class="line">  System.out.println(<span class="string">"###.### 格式："</span> + df4.format(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/sjgsh.png" alt="运行结果"></p><h2 id="大数字运算"><a href="#大数字运算" class="headerlink" title="大数字运算"></a>大数字运算</h2><p>Java提供两个类进行大数字处理，BigInteger 类和 BigDecimal 类，解决 int 范围问题（任何数字数据类型都有范围 Java中 int 是-2147483648 ~ 2147483647 这和计算机二进制补码计算有关，感兴趣可以了解一下，用2147483647+1看看会得到什么结果）。</p><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>使用方法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象  val 是十进制数字 但是注意参数格式是字符串</span></span><br><span class="line">BigInteger bi = BigInteger(String val)</span><br></pre></td></tr></table></figure><p>文档里方法太多了我挑些常用的方法（和 int不同的地方在于不能使用运算符计算，要用方法计算）：<br><img src="/2020/02/13/javabase12-math/bi.png" alt="BigInteger 类方法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">"999999999999999"</span>);</span><br><span class="line">    <span class="comment">// 加一</span></span><br><span class="line">    System.out.println(<span class="string">"加1结果："</span> + bi.add(<span class="keyword">new</span> BigInteger(<span class="string">"1"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/bi1.png" alt="运行结果"></p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>BigDecimal 多用于算钱，在数量较大时又能保证高精度（支持任何精度），比 BigInteger 更为实用，用法和 BigInteger 基本一样，先建对象，再使用方法计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象  val 是十进制数字 但是注意参数格式是字符串</span></span><br><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(String val)</span><br></pre></td></tr></table></figure><p>计算方法(文档里太难看了我放到excel)：<br><img src="/2020/02/13/javabase12-math/bdjs.png" alt="加减乘除"><br>其中，divide() 方法的 3 个参数分别表示除数、商的小数点后的位数和近似值处理模式。</p><p>BigDecimal 还提供了计算模式，各种模式满足你算钱的需求（看了文档才知道这么厉害，我以前也就用它加加减减）：<br><img src="/2020/02/13/javabase12-math/bdjsms.png" alt="计算模式"></p><p>举个例子描述结束今天的学习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  BigDecimal bi = <span class="keyword">new</span> BigDecimal(<span class="string">"999999999999999.345678"</span>);</span><br><span class="line">  <span class="comment">// 加法</span></span><br><span class="line">  System.out.println(<span class="string">"加法结果："</span> + bi.add(<span class="keyword">new</span> BigDecimal(<span class="string">"1.3465"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/13/javabase12-math/bdjf.png" alt="运行结果"></p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>这些内容可以分俩博客讲的，但是我觉得东西不多，就直接塞一块儿了，夜深了，睡觉了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;只用四则运算符无法完成三角、对数、指数等复杂运算，以及非常大的数字运算，Java提供Math等类解决问题，&lt;strong&gt;本篇内容有：Math类常用方法，随机数生成，数字格式化，大数字运算。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java数字处理" scheme="http://www.mggblog.ink/tags/Java%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十一）——Java正则表达式</title>
    <link href="http://www.mggblog.ink/2020/02/13/javabase11-zzbds/"/>
    <id>http://www.mggblog.ink/2020/02/13/javabase11-zzbds/</id>
    <published>2020-02-13T01:55:42.000Z</published>
    <updated>2020-02-14T11:17:25.947Z</updated>
    
    <content type="html"><![CDATA[<p><em>Java正则表达式也是字符串处理的内容，但是并不几个方法就能说清楚的，所以单独拿出来说一说。正则表达式多用于数据筛选，数据验证等，重要且用途广泛。但是Java正则表达式内容很多，以我的三脚猫功夫怕是讲不出个所以然，在我看博客学正则时看到一个几万字的博客，虽然他也是转载的吧，<a href="https://www.cnblogs.com/xyou/p/7427779.html">正则表达式详解</a>,作为初学者我们只需要记住几个常见的正则写法：电话，邮箱，用户名，密码，等真的需要考虑特别复杂情况的正则时再翻书学习，因为并不是天天写正则，现在学个大概，到用时差不多也忘光了。本篇大量引用了<a href="http://c.biancheng.net/view/5812.html">c语言中文网-Java正则表达式</a>,同时推荐去看一下<a href="https://www.runoob.com/java/java-regular-expressions.html">菜鸟教程。</a></em></p><a id="more"></a><hr><p>正则表达式（regex）由普通字符与特殊字符组成，用来匹配一个或多个字符，如：”^\d+(.\d+)?”,可以匹配带小数点的数。</p><p>String 类提供了几个特殊的字符串匹配方法，这些方法依赖于Java对正则表达式的支持：</p><ul><li>boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。</li><li>String replaceAll(String regex, String replacement)：将该字符串中所有匹配 regex 的子串替换成 replacement。</li><li>String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配 regex 的子串替换成 replacement。</li><li>String[] split(String regex)：以 regex 作为分隔符，把该字符串分割成多个子串。</li></ul><p>上面举的匹配小数的正则表达式例子看上去很复杂，其实并不复杂，随便一个字符串就是一个正则表达式，如”abc”，只是它只能匹配”abc”而已，功能强大的正则表达式，只是一个特殊的字符串，那我们应该如何创建正则表达式呢？</p><h2 id="正则表达式的构成"><a href="#正则表达式的构成" class="headerlink" title="正则表达式的构成"></a>正则表达式的构成</h2><ol><li>组成正则表达式的合法字符<table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>X</td><td>字符x（x 可代表任何合法的字符)</td></tr><tr><td>\0mnn</td><td>八进制数 0mnn 所表示的字符</td></tr><tr><td>\xhh</td><td>十六进制值 0xhh 所表示的字符</td></tr><tr><td>\uhhhh</td><td>十六进制值 0xhhhh 所表示的 Unicode 字符</td></tr><tr><td>\t</td><td>制表符（“\u0009”）</td></tr><tr><td>\n</td><td>新行（换行）符（‘\u000A’）</td></tr><tr><td>\r</td><td>回车符（‘\u000D’)</td></tr><tr><td>\f</td><td>换页符（‘\u000C’）</td></tr><tr><td>\a</td><td>报警（bell）符（‘\u0007’）</td></tr><tr><td>\e</td><td>Escape 符（‘\u001B’）</td></tr><tr><td>\cx</td><td>x 对应的的控制符。例如，\cM匹配 Ctrl-M。x 值必须为 A~Z 或 a~z 之一。</td></tr></tbody></table></li><li>特殊字符，使用特殊字符时要加转义字符“\”<table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>匹配一行的结尾。要匹配 $ 字符本身，请使用\$</td></tr><tr><td>^</td><td>匹配一行的开头。要匹配 ^ 字符本身，请使用\^</td></tr><tr><td>()</td><td>标记子表达式的开始和结束位置。要匹配这些字符，请使用\(和\)</td></tr><tr><td>[]</td><td>用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用\[和\]</td></tr><tr><td>{}</td><td>用于标记前面子表达式的出现频度。要匹配这些字符，请使用\{和\}</td></tr><tr><td>*</td><td>指定前面子表达式可以出现零次或多次。要匹配 * 字符本身，请使用\*</td></tr><tr><td>+</td><td>指定前面子表达式可以出现一次或多次。要匹配 + 字符本身，请使用\+</td></tr><tr><td>?</td><td>指定前面子表达式可以出现零次或一次。要匹配 ？字符本身，请使用\?</td></tr><tr><td>.</td><td>匹配除换行符\n之外的任何单字符。要匹配.字符本身，请使用.</td></tr><tr><td>\</td><td>用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配\字符，请用\\</td></tr><tr><td>|</td><td>指定两项之间任选一项。如果要匹配丨字符本身，请使用\|</td></tr></tbody></table></li><li>上面所说的只能匹配单个字符，通配符让正则表达式真正的强大起来。<table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\.</td><td>可以匹配任何字符</td></tr><tr><td>\d</td><td>匹配 0~9 的所有数字</td></tr><tr><td>\D</td><td>匹配非数字</td></tr><tr><td>\s</td><td>匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等</td></tr><tr><td>\S</td><td>匹配所有的非空白字符</td></tr><tr><td>\w</td><td>匹配所有的单词字符，包括 0~9 所有数字、26 个英文字母和下画线_</td></tr><tr><td>\W</td><td>匹配所有的非单词字符</td></tr></tbody></table></li></ol><p>上面的 7 个预定义字符其实很容易记忆，其中：</p><ul><li>d 是 digit 的意思，代表数字。</li><li>s 是 space 的意思，代表空白。</li><li>w 是 word 的意思，代表单词。</li><li>d、s、w 的大写形式恰好匹配与之相反的字符。<br>我们举个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c\\wt    <span class="comment">// 可以匹配cat、cbt、cct、cOt、c9t等一批字符串</span></span><br><span class="line">\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d    <span class="comment">// 匹配如 000-000-0000 形式的电话号码</span></span><br></pre></td></tr></table></figure>在一些特殊情况下，例如，若只想匹配 a~f 的字母，或者匹配除 ab 之外的所有小写字母，或者匹配中文字符，上面这些预定义字符就无能为力了，此时就需要使用方括号表达式，方括号表达式有几种形式。<table><thead><tr><th>方括号表达式</th><th>说明</th></tr></thead><tbody><tr><td>表示枚举</td><td>例如[abc]表示 a、b、c 其中任意一个字符；[gz]表示 g、z 其中任意一个字符</td></tr><tr><td>表示范围：-</td><td>例如[a-f]表示 a~f 范围内的任意字符；[\u0041-\u0056]表示十六进制字符 \u0041 到 \u0056 范围的字符。范围可以和枚举结合使用，如[a-cx-z]，表示 a~c、x~z 范围内的任意字符</td></tr><tr><td>表示求否：^</td><td>例如[^abc]表示非 a、b、c 的任意字符；[^a-f]表示不是 a~f 范围内的任意字符</td></tr><tr><td>表示“与”运算：&amp;&amp;</td><td>例如 [a-z&amp;&amp;[def]]是 a~z 和 [def] 的交集，表示 d、e f[a-z&amp;&amp;^bc]]是 a~z 范围内的所有字符，除 b 和 c 之外 [ad-z] [a-z&amp;&amp;[m-p]]是 a~z 范围内的所有字符，除 m~p 范围之外的字符</td></tr><tr><td>表示“并”运算</td><td>并运算与前面的枚举类似。例如[a-d[m-p]]表示 [a-dm-p]</td></tr></tbody></table></li></ul><p>方括号表达式比前面的预定义字符灵活多了，几乎可以匹配任何字符。例如，若需要匹配所有的中文字符，就可以利用 [\u0041-\u0056] 形式——因为所有中文字符的 Unicode 值是连续的，只要找出所有中文字符中最小、最大的 Unicode 值，就可以利用上面形式来匹配所有的中文字符。</p><p>正则表达式还支持圆括号，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符|。例如，正则表达式“((public)|(protected)|(private))”用于匹配 Java 的三个访问控制符其中之一。</p><p>除此之外，Java 正则表达式还支持几个边界匹配符:</p><table><thead><tr><th>边界匹配符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>行的开头</td></tr><tr><td>$</td><td>行的结尾</td></tr><tr><td>\b</td><td>单词的边界</td></tr><tr><td>\B</td><td>非单词的边界</td></tr><tr><td>\A</td><td>输入的开头</td></tr><tr><td>\G</td><td>前一个匹配的结尾</td></tr><tr><td>\Z</td><td>输入的结尾，仅用于最后的结束符</td></tr><tr><td>\z</td><td>输入的结尾</td></tr></tbody></table><p>前面例子中需要建立一个匹配 000-000-0000 形式的电话号码时，使用了 \d\d\d-\d\d\d-\d\d\d\d 正则表达式，这看起来比较烦琐。实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。</p><ul><li>Greedy（贪婪模式）：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。</li><li>Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。</li><li>Possessive（占有模式）：用加号后缀（+）表示，目前只有 Java 支持占有模式，通常比较少用。</li></ul><p>如图：<br><img src="/2020/02/13/javabase11-zzbds/szms.png" alt="三种模式的数量表示符"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"hello,java!"</span>;</span><br><span class="line"><span class="comment">// 贪婪模式的正则表达式</span></span><br><span class="line">System.out.println(str.replaceFirst(<span class="string">"\\w*"</span> , <span class="string">"■"</span>));    <span class="comment">//输出■,java!</span></span><br><span class="line"><span class="comment">// 勉强模式的正则表达式</span></span><br><span class="line">System.out.println(str.replaceFirst(<span class="string">"\\w*?"</span> , <span class="string">"■"</span>)); <span class="comment">//输出■hello, java!</span></span><br></pre></td></tr></table></figure><p>当从“hello java!”字符串中查找匹配\w<em>子串时，因为\w</em>使用了贪婪模式，数量表示符<em>会一直匹配下去，所以该字符串前面的所有单词字符都被它匹配到，直到遇到空格，所以替换后的效果是“■，Java!”；如果使用勉强模式，数量表示符</em>会尽量匹配最少字符，即匹配 0 个字符，所以替换后的结果是“■hello，java!”。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>这正则表达式文章让我自己写，我还很菜，写不出来，所以参考了其他博客的文章，毕竟我写代码一年多，还没用到过比较复杂的正则表达式，而且一般正则表达式可以在百度搜出来，但是又不能不写这内容，我自己这段时间学一学，学成回来补充或者重写本篇。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Java正则表达式也是字符串处理的内容，但是并不几个方法就能说清楚的，所以单独拿出来说一说。正则表达式多用于数据筛选，数据验证等，重要且用途广泛。但是Java正则表达式内容很多，以我的三脚猫功夫怕是讲不出个所以然，在我看博客学正则时看到一个几万字的博客，虽然他也是转载的吧，&lt;a href=&quot;https://www.cnblogs.com/xyou/p/7427779.html&quot;&gt;正则表达式详解&lt;/a&gt;,作为初学者我们只需要记住几个常见的正则写法：电话，邮箱，用户名，密码，等真的需要考虑特别复杂情况的正则时再翻书学习，因为并不是天天写正则，现在学个大概，到用时差不多也忘光了。本篇大量引用了&lt;a href=&quot;http://c.biancheng.net/view/5812.html&quot;&gt;c语言中文网-Java正则表达式&lt;/a&gt;,同时推荐去看一下&lt;a href=&quot;https://www.runoob.com/java/java-regular-expressions.html&quot;&gt;菜鸟教程。&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（十）——字符串处理（3）</title>
    <link href="http://www.mggblog.ink/2020/02/12/javabase10-zfccl3/"/>
    <id>http://www.mggblog.ink/2020/02/12/javabase10-zfccl3/</id>
    <published>2020-02-12T13:49:55.000Z</published>
    <updated>2020-02-14T11:17:31.502Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>本篇内容：字符串的比较和查找。</strong>字符串比较在代码中非常常见，多用于判断和验证，如根据字符串内容执行不同的代码，验证是否符合逻辑规则否则抛出异常等等，下面我们根据实际方法来说一下。</em></p><a id="more"></a><hr><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>字符串比较是否相等，比较大小，比较前缀后缀，非常常见，Java为我们提供了三个字符串比较方法，分别是equals() 方法、equalsIgnoreCase() 方法、 compareTo() 方法，方法的返回值都是布尔类型（boolean），下面我们分开介绍。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>只比较两个字符串的值是否相等，用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1.equals(str2);</span><br></pre></td></tr></table></figure><p>比如小羊们需要验证是谁在敲门：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">  String str = input.nextLine();</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">"mother"</span>.equals(str)) &#123;</span><br><span class="line">    System.out.println(<span class="string">"open the door"</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"call 110"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/12/javabase10-zfccl3/xy.png" alt="是妈妈，开门"></p><blockquote><p><strong>这里我们说一下 equals() 与 “ == “的区别，equals() 比较的是字符串的内容，而” == “比较的是对象实例，使用” == “比较两个对象即使字符串相同，返回结果也会是 false，简言之基础类型用==，String 类型用 equals()。举个例子：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line"><span class="comment">//基础类型数据使用 == 比较</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">System.out.println(str1.equals(str2)); <span class="comment">//true</span></span><br><span class="line">System.out.println(str1 == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(i == j); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/javabase10-zfccl3/ccc.png" alt="运行结果"></p></blockquote><h3 id="equalsIgnoreCase"><a href="#equalsIgnoreCase" class="headerlink" title="equalsIgnoreCase()"></a>equalsIgnoreCase()</h3><p>本方法与 equals() 用法形式相同，用法区别于笨方法不区分大小写，我想不需要举例解释了吧。</p><h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h3><p>比较两个字符串谁大谁小，形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.compareTo(String otherstr);</span><br></pre></td></tr></table></figure><p>str 值在参数 otherstr 值前 结果为负，否则为正，两个字符串相等结果为零，举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str1 = <span class="string">"abc"</span>;</span><br><span class="line">  System.out.println(str1.compareTo(<span class="string">"bcd"</span>));</span><br><span class="line">  System.out.println(str1.compareTo(<span class="string">"abc"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/12/javabase10-zfccl3/ct.png" alt="结果"></p><h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><p>String 类的 indexOf() 方法和 lastlndexOf() 方法用于在字符串中获取匹配字符（串）的索引值。</p><h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><p>indexOf() 方法用于返回字符（串）在指定字符串中首次出现的索引位置，如果能找到，则返回索引值，否则返回 -1。该方法主要有两种重载形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.indexOf(value);</span><br><span class="line">str.indexOf(value,<span class="keyword">int</span> fromIndex);</span><br></pre></td></tr></table></figure><p>其中，str 表示指定字符串；value 表示待查找的字符（串）；fromIndex 表示查找时的起始索引，如果不指定 fromIndex，则默认从指定字符串中的开始位置（即 fromIndex 默认为 0）开始查找。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str = <span class="string">"hello world"</span>;</span><br><span class="line">  <span class="keyword">int</span> i = str.indexOf(<span class="string">"o"</span>);</span><br><span class="line">  <span class="keyword">int</span> j = str.indexOf(<span class="string">"o"</span>,<span class="number">5</span>);</span><br><span class="line">  System.out.println(i);</span><br><span class="line">  System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/javabase10-zfccl3/i2.png" alt="结果"></p><h3 id="lastlndexOf"><a href="#lastlndexOf" class="headerlink" title="lastlndexOf()"></a>lastlndexOf()</h3><p>lastIndexOf() 方法用于返回字符（串）在指定字符串中最后一次出现的索引位置，如果能找到则返回索引值，否则返回 -1。该方法也有两种重载形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.lastIndexOf(value)</span><br><span class="line">str.lastlndexOf(value, <span class="keyword">int</span> fromIndex)</span><br></pre></td></tr></table></figure><p>lastIndexOf() 方法的查找策略是从右往左查找，如果不指定起始索引，则默认从字符串的末尾开始查找。举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str = <span class="string">"hello world"</span>;</span><br><span class="line">  <span class="keyword">int</span> i = str.lastIndexOf(<span class="string">"o"</span>);</span><br><span class="line">  <span class="keyword">int</span> j = str.lastIndexOf(<span class="string">"o"</span>,<span class="number">5</span>);</span><br><span class="line">  System.out.println(i);</span><br><span class="line">  System.out.println(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/javabase10-zfccl3/i3.png" alt="结果"></p><h3 id="补充：根据索引查找"><a href="#补充：根据索引查找" class="headerlink" title="补充：根据索引查找"></a>补充：根据索引查找</h3><p>String 类的 charAt() 方法可以在字符串内根据指定的索引查找字符，形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.charAt(<span class="keyword">int</span> index);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str = <span class="string">"hello world"</span>;</span><br><span class="line">  <span class="keyword">char</span> c = str.charAt(<span class="number">6</span>);</span><br><span class="line">  System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/12/javabase10-zfccl3/i4.png" alt="结果"></p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>字符串处理写完了，方法众多不可能说全部记下来，多练的意义在于加深印象，遇到相关需求的时候知道有这么个方法可以解决问题，不要到时候发出“这可咋办的呼喊”，又到深夜了，加油！奥利给！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;&lt;strong&gt;本篇内容：字符串的比较和查找。&lt;/strong&gt;字符串比较在代码中非常常见，多用于判断和验证，如根据字符串内容执行不同的代码，验证是否符合逻辑规则否则抛出异常等等，下面我们根据实际方法来说一下。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java字符串处理" scheme="http://www.mggblog.ink/tags/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（九）——字符串处理（2）</title>
    <link href="http://www.mggblog.ink/2020/02/12/javabase9-zfccl2/"/>
    <id>http://www.mggblog.ink/2020/02/12/javabase9-zfccl2/</id>
    <published>2020-02-12T05:45:47.000Z</published>
    <updated>2020-02-14T11:17:36.380Z</updated>
    
    <content type="html"><![CDATA[<p><em>接着上篇字符串处理继续,<strong>本篇内容包括字符串的大小写转换、除去空格、子字符串提取、分割和替换</strong>。我们说这些方法的目的不是记住这个方法如何使用，而是在于看过后心里能有个印象，有这个方法可以用，下次有用到时直接去查文档就行了，由于不想篇幅过长，还剩字符串比较和查找，下一篇再说。</em></p><a id="more"></a><hr><h2 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h2><p>Java 提供 toLowerCase() 和 toUpperCase() 两个方法分别用来转小写与转大写，转换时其他字符串不会受到影响：</p><h3 id="大写转小写-toLowerCase"><a href="#大写转小写-toLowerCase" class="headerlink" title="大写转小写 toLowerCase()"></a>大写转小写 toLowerCase()</h3><p>使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.toLowerCase();</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str = <span class="string">"Oh!Awesome!!"</span>;</span><br><span class="line">System.out.println(str.toLowerCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="/2020/02/12/javabase9-zfccl2/dzx.png" alt="大转小"></p><h3 id="小写转大写-toUpperCase"><a href="#小写转大写-toUpperCase" class="headerlink" title="小写转大写 toUpperCase()"></a>小写转大写 toUpperCase()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.toUpperCase();</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str = <span class="string">"Oh!Awesome!!"</span>;</span><br><span class="line">  System.out.println(str.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><img src="/2020/02/12/javabase9-zfccl2/xzd.png" alt="小转大"></p><h2 id="字符串除去空格"><a href="#字符串除去空格" class="headerlink" title="字符串除去空格"></a>字符串除去空格</h2><p>这种需求通常再数据要标准化的时候用到，如果传了头尾有空格的数据放入有长度限制数据库，会导致数据库报异常，然而用眼看不出来（我曾经被这样的数据害惨了，一个bug调半天），Java提供 trim() 方法除去空格（我门说的空格在字符串的头尾）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.trim();</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str = <span class="string">"  Oh!Awesome!! "</span>;</span><br><span class="line">  <span class="comment">//我们借用长度表现</span></span><br><span class="line">  System.out.println(str.length());</span><br><span class="line">  System.out.println(str.trim().length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/12/javabase9-zfccl2/ckg.png" alt="从长度看出空格已经除去"></p><h2 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h2><p>比如你需要从一个身份证号截取到籍贯、出生日期等信息,Java提供了 substring() 方法来解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//范围有前有后</span></span><br><span class="line">str.substring(<span class="keyword">int</span> beginIndex,<span class="keyword">int</span> endIndex);</span><br><span class="line"><span class="comment">//范围只有开始</span></span><br><span class="line">str.substring(<span class="keyword">int</span> beginIndex);</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，substring()方法 beginIndex 从 0 开始，而 endIndex 从 1 开始，使用时要特别注意。然后还要注意其他语言也有substr方法，参数可能不一样别搞混。</p></blockquote><p>例如从身份证提取信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String personId = <span class="string">"130523202001012233"</span>;</span><br><span class="line">  String city = <span class="string">""</span>;</span><br><span class="line">  String birth = personId.substring(<span class="number">6</span>, <span class="number">14</span>);<span class="comment">// 20200101</span></span><br><span class="line">  <span class="comment">// 预习一下这个字符串比较方法equals（），后面专门说一下</span></span><br><span class="line">  <span class="keyword">if</span> (personId.substring(<span class="number">0</span>, <span class="number">6</span>).equals(<span class="string">"130523"</span>)) &#123;</span><br><span class="line">    city = <span class="string">"河北省邢台市"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"这个人的籍贯是："</span> + city);</span><br><span class="line">  System.out.println(</span><br><span class="line">      <span class="string">"这个人的出生日期是："</span> + birth.substring(<span class="number">0</span>, <span class="number">4</span>) + <span class="string">"年"</span> + birth.substring(<span class="number">4</span>, <span class="number">6</span>) + <span class="string">"月"</span> + birth.substring(<span class="number">6</span>) + <span class="string">"日"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/12/javabase9-zfccl2/jq.png" alt="出生地和出生日期"></p><h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><p>字符串中包含几个人名用逗号隔开了，现在需要分割开，Java提供了 split() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要数组来接收很好理解</span></span><br><span class="line">String[] strs = str.split(String sign);</span><br><span class="line"><span class="comment">//limit 可以限制个数</span></span><br><span class="line">String[] strs = str.split(String sign , <span class="keyword">int</span> limit);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str = <span class="string">"kangkang,john,jan"</span>;</span><br><span class="line">  String[] names = str.split(<span class="string">","</span>);</span><br><span class="line">  String[] names1 = str.split(<span class="string">","</span>,<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class="line">  <span class="keyword">for</span>(String name : names1) &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/12/javabase9-zfccl2/qg.png" alt="分割"><br>可以看到如果限制个数的话，最后一个元素是切割剩下的所有字符串。</p><blockquote><p>如果字符串是用 “.”或“|” 来分割的，以为他俩都是转义字符，需要在加上“\\”,如“\\.”、“\\|”,如果 str.split(“”) ,得到的是一个一个单个字符。</p></blockquote><h2 id="字符串的替换"><a href="#字符串的替换" class="headerlink" title="字符串的替换"></a>字符串的替换</h2><p>Java为字符串替换提供了三个方法，分别是 replace()、replaceFirst() 和 replaceAll()。</p><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replace(String oldChar, String newChar);</span><br></pre></td></tr></table></figure><p>例如一个经过简单加密的密码 “1$2$3$4$5$6$7$8$9”,需要转换为正常密码 “123456789” ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String str = <span class="string">"1$2$3$4$5$6$7$8$9"</span>;</span><br><span class="line">  String pwd = str.replace(<span class="string">"$"</span>, <span class="string">""</span>);</span><br><span class="line">  System.out.println(pwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/12/javabase9-zfccl2/r1.png" alt="替换完成"></p><h3 id="replaceFirst"><a href="#replaceFirst" class="headerlink" title="replaceFirst()"></a>replaceFirst()</h3><p>replaceFirst() 方法用于将目标字符串中匹配某正则表达式的第一个子字符串替换成新的字符串，其语法形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replaceFirst(String regex, String replacement);</span><br></pre></td></tr></table></figure><p>其中，regex 表示正则表达式；replacement 表示用于替换的字符串。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String words = <span class="string">"i am kangkang,i am rich ,kangkang is rich"</span>;</span><br><span class="line">  String newStr = words.replaceFirst(<span class="string">"rich"</span>, <span class="string">"poverty"</span>);</span><br><span class="line">  System.out.println(newStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果 ：<br><img src="/2020/02/12/javabase9-zfccl2/r2.png" alt="只替换了第一个rich"></p><h3 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a>replaceAll()</h3><p>看方法名就知道，相对 replaceFirst 这是个完全替换的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.replaceAll(String regex, String replacement);</span><br></pre></td></tr></table></figure><p>我们继续使用上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  String words = <span class="string">"i am kangkang,i am rich ,kangkang is rich"</span>;</span><br><span class="line">  String newStr = words.replaceFirst(<span class="string">"rich"</span>, <span class="string">"poverty"</span>);</span><br><span class="line">  System.out.println(newStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="/2020/02/12/javabase9-zfccl2/r3.png" alt="完全替换"></p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>看新闻新冠肺炎确诊数已经连续7天下降了，感谢广大医疗工作者的付出，我在家啥也帮不上真是惭愧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;接着上篇字符串处理继续,&lt;strong&gt;本篇内容包括字符串的大小写转换、除去空格、子字符串提取、分割和替换&lt;/strong&gt;。我们说这些方法的目的不是记住这个方法如何使用，而是在于看过后心里能有个印象，有这个方法可以用，下次有用到时直接去查文档就行了，由于不想篇幅过长，还剩字符串比较和查找，下一篇再说。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java字符串处理" scheme="http://www.mggblog.ink/tags/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（八）——字符串处理（1）</title>
    <link href="http://www.mggblog.ink/2020/02/11/javabase8-zfccl1/"/>
    <id>http://www.mggblog.ink/2020/02/11/javabase8-zfccl1/</id>
    <published>2020-02-11T08:18:36.000Z</published>
    <updated>2020-02-14T11:17:43.461Z</updated>
    
    <content type="html"><![CDATA[<p><em>我们在敲第一个Java程序”Helloworld”的时候就用到了字符串，后面程序举例中很多动作直接用字符串模拟，字符串广泛应用于日常编程，Java中无内置字符串类型，提供了 一个专门创建和操作的类 String ，我们单独拿出来说一说。由于内容较多，需要一点一点讲，<strong>本篇内容包括字符串的定义与获取字符串长度，字符串拼接，String 类型与 int 类型转换</strong>。</em></p><a id="more"></a><hr><h2 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a>字符串的定义</h2><p>字符串有两种定义方式，直接定义和使用 String 类定义，无论是哪种定义方式，它的所有对象都是不可变对象，变量值的每一次改变都会指向一个新的对象，旧的对象还在内存里面（前面提到过引用型数据内存存储方法<a href="http://www.mggblog.ink/2020/02/06/javabase3-bsfgjzclbltj/">筑基到修仙（三）</a>）。</p><blockquote><p>简单说明一下，Java内存有一块特殊的区域，常量池，在编译时用来存储 final型数据和对象字面量，String类型数据就是对象字面量，常量池专门存储这些在编译时就已经能够确定的数据，防止频繁的创建于销毁对象，影响内存性能。有兴趣就要去详细了解虚拟机内存机制，对后期提升有帮助，我也只是略懂皮毛,下面说一下我对这个不可变对象的理解。</p><blockquote><p>在介绍数据类型时我们说过，内存内分为堆和栈，而引用型将变量名存放于栈上，使用指针指向位于堆上的对象，结合常量池我们举个例子比如：</p><p>首先有 String str = “abc” ， 新建另一个变量时 Sting str1 = “abc”  会现在常量池中搜索是否有”abc”,如果有就不会创建新的对象，只是添加一个指针引用。当变量重新赋值 str = “def” ，就会修改指针指向（常量池有就直接指向，没有就新建“def”对象），但是内存堆中 “abc” 依然存在，所以现在这个str与原str是两个对象。  </p><p>用 String str3 = new String(“abc”) 这种方式创建，至少产生了一个对象，编译时会在常量池中查找是否有”abc”,有就指向，没有就创建，在运行时因为有 new 又会重新创建一个“abc”对象，所以说至少创建了一个，可能创建了俩对象。<br>举个例子更清楚：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 &#x3D; &quot;abc&quot;;</span><br><span class="line">String str2 &#x3D; &quot;abc&quot;;</span><br><span class="line">String str3 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str2); &#x2F;&#x2F;true</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str3); &#x2F;&#x2F;false</span><br><span class="line">str2 &#x3D; &quot;bcd&quot;;</span><br><span class="line">System.out.println(str1 &#x3D;&#x3D; str2); &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure><p>这里面又有一个坑就是字符串使用”==”比较其实是比较对象，只比较字符串值得话我们在后面<a href="http://www.mggblog.ink/2020/02/12/javabase10-zfccl3">筑基到修仙（十）</a>再做详细说明。</p></blockquote></blockquote><h3 id="直接定义字符串"><a href="#直接定义字符串" class="headerlink" title="直接定义字符串"></a>直接定义字符串</h3><p>直接定义就是使用 “” 号，引号内部是字符串内容，既可以直接声明变量与值，也可以先声明变量再赋值，举例如下：</p><ol><li>直接赋值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"Oh!owesome!"</span></span><br></pre></td></tr></table></figure></li><li>先声明变量再赋值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str;</span><br><span class="line">str = <span class="string">"Oh!owesome!"</span></span><br></pre></td></tr></table></figure>字符串必须经过初始化才可以使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str;</span><br><span class="line">System.out.println(str);<span class="comment">//The local variable str may not have been initialized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>举一个正常使用的例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str;</span><br><span class="line">str = <span class="string">"Oh!awesome!"</span>;</span><br><span class="line">String str1 = <span class="string">"这是我独享的moment"</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(str1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/02/11/javabase8-zfccl1/str1.png" alt="运行结果"></li></ol><h3 id="使用-String-类定义（包含了使用-length-方法获取字符串长度）"><a href="#使用-String-类定义（包含了使用-length-方法获取字符串长度）" class="headerlink" title="使用 String 类定义（包含了使用.length 方法获取字符串长度）"></a>使用 String 类定义（包含了使用.length 方法获取字符串长度）</h3><p>直接定义的字符串和使用 String 类定义产生的都是 String 类对象，我们打开jdk API帮助文档来认识一下这个 String 类。<br>首先说明是 String 类的身份信息和初始化示例：<br><img src="/2020/02/11/javabase8-zfccl1/strapi1.png" alt="基本信息"><br>然后是构造方法摘要，包含构造方法和众多重载构造方法（重载我们后面再说，就是和构造方法名相同，参数不同）：<br><img src="/2020/02/11/javabase8-zfccl1/strapi2.png" alt="构造方法"><br>方法摘要，包含当前jdk支持的所有方法，jdk版本不同包含的方法不一样，有的会过时，也有会新增，但是不会有特别大的变化，通过 对象.方法（）; 调用。<br><img src="/2020/02/11/javabase8-zfccl1/strapi3.png" alt="方法摘要"><br>最后是构造详解与方法详解：<br><img src="/2020/02/11/javabase8-zfccl1/gzxj.png" alt="构造详解"><br><img src="/2020/02/11/javabase8-zfccl1/ffxj.png" alt="方法详解"><br>我们通过例子学习如何使用 String 类，和 String 类方法，下面代码使用了获取字符串长度的类方法，获取字符串长度在很多地方非常重要，比如数据迭代，数据输入长度限制等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str = <span class="keyword">new</span> String();</span><br><span class="line">str = <span class="string">"i am kangkang"</span>;</span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"i am jhon"</span>);<span class="comment">//使用重载构造方法</span></span><br><span class="line"><span class="keyword">int</span> long1 = str.length();<span class="comment">//调用length方法获取字符串长度</span></span><br><span class="line"><span class="keyword">int</span> long2 = str1.length();</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(str1);</span><br><span class="line">System.out.println(<span class="string">"str的长度是："</span>+long1);</span><br><span class="line">System.out.println(<span class="string">"str1的长度是："</span>+long2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/11/javabase8-zfccl1/gzcs.png" alt="运行结果"><br>还有其他常用构造方法，比如用字符数组初始化字符串，再此不再举例，读者自己练一下，体会一下如何使用帮助文档（字符数组声明  char[] ch ={‘a’,’a’,’b’} 或者 {56，80} 看一下如果里面不带单引号的数字输出时什么，涉及到ASCII码知识）。</p><blockquote><p>我们说一下另两个也会用到的字符串类 StringBuffer 和 StringBuilder：</p><p>这两个类最常用的是StringBuffer，一句话表述两个的区别是，StringBuffer 为线程安全类，StringBuilder 非线程安全类，因为还没说到线程我们不多做解释，字面意思，两个类功能差不多的化你使用哪个，肯定是安全的那个，所以通常 StringBuilder 很少用到。</p><p>因为有文档，我们不在这里长篇叙述 StringBuffer 类的各种信息，只说什么时候使用，使用时与 String  类有什么不同：</p><ol><li>StringBuffer 类是我们需要特别长字符串的时候使用，比如要通过字符串写一段超长的SQL语句（数据库查询语言），由于内存存储机制，使用 String 类对象可能会导致内存性能下降(说是这么说，我到现在还没遇到过出问题)，这时候我们用 StringBuffer。buffer的意思是缓冲区，就是在创建对象时就创建缓冲区，对内存进行优化。</li><li>String 对象可以直接赋值，而且对象不可变（在内存中栈的位置不变，变得是堆中数据得位置），改变对象值就相当于建了一个新的对象。StringBuffer 需要通过构造方法来初始化，而且对象可变，值得改变不会新建对象，不会浪费内存性能，所以当有大量需要拼接得字符串时推荐使用StringBuffer。</li><li>最常用得不同点，拼接方法不同，StringBuffer 不能用 “+”拼接，需要append()方法。<br>写个Demo:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">StringBuffer str = <span class="keyword">new</span> StringBuffer(<span class="string">" i am kangkang ,"</span>);</span><br><span class="line">str .append(<span class="string">"i am a handsome boy"</span>);</span><br><span class="line"><span class="comment">//拼接方法也不一样</span></span><br><span class="line">String str1 = <span class="string">" i am sicong ,"</span>;</span><br><span class="line">str1 += <span class="string">"i am rich"</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(str1);</span><br><span class="line">&#125;</span><br><span class="line">&gt; </span><br></pre></td></tr></table></figure>运行结果<br><img src="/2020/02/11/javabase8-zfccl1/buffer.png" alt="运行结果"></li></ol></blockquote><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>在开发中字符串拼接的需求太多了，比如说参数传过来人员相关数据，需要拼接各个属性成为一个完整的句子，那我们来实践一下吧。</p><ol><li>String 类型字符串使用 “+” 来拼接，这个方法我们用过很多次了，不举例了。</li><li>String 类型字符串使用concat（）方法来拼接，这个我们还没有提到过，从他开始吧：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String[] person = &#123; <span class="string">" he was "</span>, <span class="string">" kangkang,"</span>, <span class="string">" handsome "</span>, <span class="string">" and "</span>, <span class="string">"rich"</span> &#125;;</span><br><span class="line">String boy = <span class="string">"the boy said that:"</span>;</span><br><span class="line"><span class="keyword">for</span> (String str : person) &#123;</span><br><span class="line"><span class="comment">// boy += str ;</span></span><br><span class="line">boy = boy.concat(str);<span class="comment">// 与“+”效果一样</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(boy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>结果和 + 效果没有区别<br><img src="/2020/02/11/javabase8-zfccl1/hand.png" alt="运行结果"><br>这两种方法喜欢哪种用哪种。</li><li>StringBuffer 刚才我们说过了，使用 append（） 方法也不再举例了。</li><li>其他类型与字符串拼接，直接拼就行了，其他类型会自动转为字符串类型（隐式转换），有不能拼的编译器会给提示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">0.99</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'A'</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span> ;</span><br><span class="line"><span class="keyword">float</span> f = <span class="number">9.9999f</span>;</span><br><span class="line">System.out.println(<span class="string">"test is "</span>+i+d+c+b+f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/02/11/javabase8-zfccl1/pj.png" alt="运行结果"></li></ol><h2 id="String-与-int-类型转换"><a href="#String-与-int-类型转换" class="headerlink" title="String 与 int 类型转换"></a>String 与 int 类型转换</h2><ul><li>首先说 String 类型转 int 类型，有两种方法：</li></ul><ol><li>使用 Integer 类，Integer 是 int 的封装类，它提供了类型转换的方法，Integer.parseInt(str)；</li><li>Integer.valueOf(str).intValue()，同样是用到 Integer 类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">String str = <span class="string">"100"</span>;</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(str);</span><br><span class="line"><span class="keyword">int</span> j = Integer.valueOf(str).intValue();</span><br><span class="line">++i;</span><br><span class="line">j += <span class="number">2</span>;</span><br><span class="line">System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">System.out.println(<span class="string">"j = "</span> + j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/02/11/javabase8-zfccl1/sti.png" alt="运行结果"></li></ol><ul><li>然后是 int 转 String 有三种方法：</li></ul><ol><li>简单粗暴直接使用 String i=i+””, 用字符串拼接;</li><li>使用Integer.toString(i);</li><li>使用String().valueOf(i);<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">String str1 = i + <span class="string">""</span>;</span><br><span class="line">String str2 = Integer.toString(i);</span><br><span class="line">String str3 = String.valueOf(i);</span><br><span class="line">System.out.println(<span class="string">"str1:"</span>+str1);</span><br><span class="line">System.out.println(<span class="string">"str2:"</span>+str2);</span><br><span class="line">System.out.println(<span class="string">"str3:"</span>+str3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/02/11/javabase8-zfccl1/its.png" alt="运行结果"></li></ol><p>这些个方法都是Java开发人员慢慢添加上来的，如果愿意你可以 ctrl+左击 点到方法内部去看看，领会一下开发精神，学习一下代码逻辑，之所以现在Java这么好用，完全是因为我们站在巨人的肩膀上啊，那现在Java不足的地方就靠我们了，加油，奥里给！！</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>全国疫情都在慢慢好转了，这几天我这里小区封门无法出去，加上年前宅了几天我有将近20天没出门了，不过早已习惯，上学时除了上课可以一个月不出宿舍，已经练出来了，但是当我都感觉到有些宅时，其他人应该都有些受不了了吧，哈哈哈！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;我们在敲第一个Java程序”Helloworld”的时候就用到了字符串，后面程序举例中很多动作直接用字符串模拟，字符串广泛应用于日常编程，Java中无内置字符串类型，提供了 一个专门创建和操作的类 String ，我们单独拿出来说一说。由于内容较多，需要一点一点讲，&lt;strong&gt;本篇内容包括字符串的定义与获取字符串长度，字符串拼接，String 类型与 int 类型转换&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
      <category term="Java字符串处理" scheme="http://www.mggblog.ink/tags/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（七）——Debug</title>
    <link href="http://www.mggblog.ink/2020/02/10/javabase7-debug/"/>
    <id>http://www.mggblog.ink/2020/02/10/javabase7-debug/</id>
    <published>2020-02-10T15:34:00.000Z</published>
    <updated>2020-02-13T16:47:57.426Z</updated>
    
    <content type="html"><![CDATA[<p><em>人生病了找医生，而且“望闻问切”不再是中医的专利，医生只有对病人身体了解的够清楚，才能找出病灶所在。程序也是一样，随着代码越来越复杂，出了问题很难用眼找出来，特别是逻辑问题相当难找，程序问题称为“bug”我们把给程序找毛病的行为叫“Debug”，中文叫调试。</em></p><a id="more"></a><hr><p>咱们生病了有专门的医生看病，但是程序病了可没有专门帮你调bug的人，所以debug的事在是太重要了，说着我就打开了eclipse。<br>eclipse 上 debug 的操作比较简单我们先使用debug来查看一下程序如何运行，变量如何变化，熟悉一下使用到的各个按钮，我们用一个简单的循环，昨天的俯卧撑：<br>使用调试首先要打断点，在代码行最前双击，举个最简单的例子，我们看一下循环中，变量 i 如何变化：<br><img src="/2020/02/10/javabase7-debug/ddd.png" alt="打上断点"><br><img src="/2020/02/10/javabase7-debug/zan.png" alt="工具栏里找run，然后点debug"><br><img src="/2020/02/10/javabase7-debug/dkts.png" alt="遇到弹框点打开"><br><img src="/2020/02/10/javabase7-debug/qj.png" alt="简单看一下全局页面"><br>因为当前代码里没有实例方法调用，直接点下一步就行了step into 用在比如有一行代码是 jump()方法 可以通过into 跳到jump()方法内部查看。这里我们直接点step over就行了。<br><img src="/2020/02/10/javabase7-debug/into.png" alt="step into"><br><img src="/2020/02/10/javabase7-debug/over.png" alt="step over"><br><img src="/2020/02/10/javabase7-debug/jj.png" alt="随着不断点击变量i一直在增加"><br>偶们知道了，i++后，i增加了1。<br><img src="/2020/02/10/javabase7-debug/kzt.png" alt="控制台一段一段打出来"><br>疯狂点完二十下<br><img src="/2020/02/10/javabase7-debug/over1.png" alt="debug完了"><br>好了本次debug就算完成了，最重要的是要在debug中观察变量的变化是否符合逻辑，通常都会有恍然大悟的感觉。后面我回再补充遇到问题代码如何调试，本篇先告诉读者有这个东西，简单怎么使用。（我实在熬不动了）</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>今天想把博客从github移到服务器上，本来想用gitlab的，但是调了半天搭好gitlab，page页总是配不好，不能用，最后晚上放弃了，采用了git仓库+nginx的方法，也有很多坑要填，熬到现在，熬不动了，特殊时期不敢生病啊。晚安！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;人生病了找医生，而且“望闻问切”不再是中医的专利，医生只有对病人身体了解的够清楚，才能找出病灶所在。程序也是一样，随着代码越来越复杂，出了问题很难用眼找出来，特别是逻辑问题相当难找，程序问题称为“bug”我们把给程序找毛病的行为叫“Debug”，中文叫调试。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（六）——循环</title>
    <link href="http://www.mggblog.ink/2020/02/09/javabase6-xh/"/>
    <id>http://www.mggblog.ink/2020/02/09/javabase6-xh/</id>
    <published>2020-02-09T12:30:39.000Z</published>
    <updated>2020-02-14T11:17:55.816Z</updated>
    
    <content type="html"><![CDATA[<p><em>从这篇内容开始Java核心内容——循环结构的学习，日常生活中的循环很常见，墙上钟表的指针一圈一圈的不停的转是一种循环，人体内的水每时每刻都在循环，再如鲁迅曾经说过“人类的本质是复读机”，复读也是循环。<strong>本篇要求做到如下几点：理解循环含义;会用while结构;会用for/foreach结构。</strong></em>  </p><a id="more"></a><hr><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>while循环的一般形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件) &#123;</span><br><span class="line">循环操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环条件判断为true他就一直循环直到为false为止，特点是先判断再执行。<br>为了锻炼肾体，我每天都坚持做俯卧撑和深蹲，各做20个，别嘲笑我菜。我们用while来做20个俯卧撑，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">20</span> ) &#123;</span><br><span class="line">System.out.println(<span class="string">"第"</span>+i+<span class="string">"个俯卧撑！"</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/09/javabase6-xh/fwc.png" alt="运行结果"><br>就是这么简单，如果没有循环，我需要20个 System.out.println 改中间的数值烦死了，有没有发现，现在科技的的进步都是”懒“来驱动的，尤其在it行业，哈哈哈。<br>趁热打铁，再做个练习，计算一下5门考试科目的平均成绩，具体哪科就不说了啊，我们控制台输入五个数求平均值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>,score = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">5</span> ) &#123;</span><br><span class="line">score += input.nextInt();</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> avg = score/i;</span><br><span class="line">System.out.println(<span class="string">"五科的平均分是："</span>+avg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/09/javabase6-xh/pjf.png" alt="运行结果"><br>我们上面用的是 while 的常见形式，先判断后执行，它还有另一种先执行后判断的形式————“ do……while”形式，不过基本上很少用到。<br>do……while循环的一般形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">循环操作</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(循环条件)</span><br></pre></td></tr></table></figure><p>才做了20个俯卧撑，还有20个深蹲要做，我们用do……while来做一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"第"</span> + i + <span class="string">"个深蹲！"</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有没有发现基本和上面while代码一模一样，还多了个do，所以用do……while多此一举，没必要，但是照顾到有些人善于顺时思维，有些人善于逆时思维，想用那个那个，可以达到一样的效果。</p><p>while的代码结构很简单，但是有需要特别注意的问题即使，在写循环条件时一定要谨慎，否则会出现死循环或者不执行循环操作，死循环会导致程序崩溃。</p><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>除了while循环，还有for循环，for循环的循环条件可以使用局部变量，也可以使用外部变量，当使用局部变量时，程序最多循环多少次是已知的，而while循环只能使用外部变量，无法判断循环多少次。<br>for循环的一般形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(赋值语句;条件语句;迭代语句)&#123;</span><br><span class="line">循环操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用for循环来做俯卧撑20下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"第"</span>+i+<span class="string">"个俯卧撑"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/09/javabase6-xh/for.png" alt="运行结果"><br>不一样的实现方法，和 while 循环对比记忆，效果更佳。另外，for 语句中赋值、循环条件以及迭代部分都可以为空语句（但分号不能省略），三者均为空的时候，相当于一个无限循环。我们来思考一下当赋值语句，条件语句，迭代语句分别为空时，做20个俯卧撑要怎么写。</p><ol><li>赋值语句为空<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">//就是简单的放到外面</span></span><br><span class="line"><span class="keyword">for</span> (; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"第"</span>+i+<span class="string">"个俯卧撑"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>条件语句为空（又见 break 关键字）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//这里我们碰到了昨天在 switch 语句中出现的 break 关键字，在这里的作用是结束循环，如果没有它，没有循环条件限制，循环就会一直下去。</span></span><br><span class="line">System.out.println(<span class="string">"第"</span> + i + <span class="string">"个俯卧撑"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>迭代语句为空<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20</span>;) &#123;</span><br><span class="line">System.out.println(<span class="string">"第"</span> + i + <span class="string">"个俯卧撑"</span>);</span><br><span class="line">i++;<span class="comment">//简单的放到里面就可以了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>三个代码都跑过了，没问题，不再上图了。请读者自己用for循环写个计算平均数的小程序，用上Scanner类，控制台输入数据。另外思考一下，空三个条件又该怎么写呢？（从三段代码里找答案）</li></ol><h4 id="for-嵌套"><a href="#for-嵌套" class="headerlink" title="for 嵌套"></a>for 嵌套</h4><p>for 也是可以嵌套的，用来解决复杂的循环逻辑，比如冒泡排序，就要用到双层for循环，我们到后面再说冒泡排序，我们今天举个输出九九乘法表的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//外循环，第一个因数取值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt;= <span class="number">9</span> ; i++) &#123;</span><br><span class="line"><span class="comment">//内循环，第二个因数取值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= i; j++) &#123;</span><br><span class="line"><span class="comment">//输出算式</span></span><br><span class="line">System.out.print(i+<span class="string">"*"</span>+j+<span class="string">"="</span>+i*j+<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//换行</span></span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/09/javabase6-xh/99cf.png" alt="乘法表"><br>不仅可以嵌套两套，for可以嵌套任意多套，但是随着层数增加，算法复杂度指数增加，也很少有嵌套多层的算法需求。</p><h2 id="forEach-循环"><a href="#forEach-循环" class="headerlink" title="forEach 循环"></a>forEach 循环</h2><p>forEach 循环时for循环的特殊形式，多用于数组、列表等数据结构迭代，非常好用。它的一般结构是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(类型 变量名:集合) &#123;</span><br><span class="line">    语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们举个数组迭代的例子，还没讲到数据结构，但是在这里必须找个例子用，遍历一个字符串数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//举个字符串数组</span></span><br><span class="line">String[] names = &#123;<span class="string">"kangkang"</span>,<span class="string">"tom"</span>,<span class="string">"john"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(String name : names) &#123;</span><br><span class="line">System.out.println(<span class="string">"i am "</span>+name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/09/javabase6-xh/foreach.png" alt="轻松处理并输出"><br>for绝对可以完成foreach的工作，但是用for遍历数组的话就要通过数组下标循环遍历，还是 foreach 好用，程序员”懒”就是生产力啊！<br>循环结构就这么多内容，到这里，逻辑思考就多了起来，多多练习，祝早日变大佬！！</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>憋尿博客，部署完赶紧溜了。完整版“巨魔吟唱”：当我们遇到什么困难都不要怕，微笑着面对它，战胜困难的唯一办法就是面对困难，坚持就是胜利，加油！奥力给！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;从这篇内容开始Java核心内容——循环结构的学习，日常生活中的循环很常见，墙上钟表的指针一圈一圈的不停的转是一种循环，人体内的水每时每刻都在循环，再如鲁迅曾经说过“人类的本质是复读机”，复读也是循环。&lt;strong&gt;本篇要求做到如下几点：理解循环含义;会用while结构;会用for/foreach结构。&lt;/strong&gt;&lt;/em&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（五）——条件结构</title>
    <link href="http://www.mggblog.ink/2020/02/08/javabase5-tjjg/"/>
    <id>http://www.mggblog.ink/2020/02/08/javabase5-tjjg/</id>
    <published>2020-02-08T11:57:27.000Z</published>
    <updated>2020-02-13T16:47:55.456Z</updated>
    
    <content type="html"><![CDATA[<p><em>条件结构和后面的循环结构我们统称为流程控制。条件结构式代码中最频繁使用的代码块，功能简单粗暴，有说去年再steam上大卖的《太吾绘卷》就是用一堆条件代码写的，哈哈哈谁知道是不是真的呢。</em></p><a id="more"></a><hr><h2 id="if……else……"><a href="#if……else……" class="headerlink" title="if……else……"></a>if……else……</h2><p>为什么需要条件结构，举个例子，过年小明家有邻居来拜年，邻居带着女儿，小姐姐甚是漂亮，小明想要搭话，那该怎么称呼呢，姐姐？还是小姐姐？这就需要来个年龄判断了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> mm = input.nextInt();</span><br><span class="line"><span class="comment">//小明今年10岁</span></span><br><span class="line"><span class="keyword">int</span> xm = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (mm&gt;xm) &#123;</span><br><span class="line">System.out.println(<span class="string">"该叫姐姐"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"该叫小姐姐"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小明10岁，妹妹9岁<br><img src="/2020/02/08/javabase5-tjjg/if.png" alt="咋也不能叫妹妹啊"><br>最简单的条件结构连else都不需要，符合条件就执行内部代码，不符合就直接跳过，当然如果有众多条件判断就要加入 else if 看格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( )&#123; ...&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( ) &#123;... &#125;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">else</span> &#123; ...&#125;</span><br></pre></td></tr></table></figure><p>花括弧中式代码段，如果只有一段代码（一段代码的意思是只有一个“;”）,那就不用加“{}”看：<br><img src="/2020/02/08/javabase5-tjjg/ifwkh.png" alt="不加括弧"><br>多段代码一定要加括弧，不然编译不通过，语法错误。有括弧就可以为所欲为，我可以在里面再写一个if语句，搞个嵌套，这种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(表达式<span class="number">2</span>) &#123;</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(表达式<span class="number">3</span>) &#123;</span><br><span class="line">        语句块<span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">4</span>) &#123;</span><br><span class="line">        语句块<span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(表达式n) &#123;</span><br><span class="line">            语句块n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            语句块n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if条件结构较容易，多写几个练习就掌握了，比如说判断三个数中的最大值，请读者自己写一写，写好了那四个数呢，还有如果是多个条件一起做判断呢（提示多个条件需要用到“&amp;&amp;”、“||”，否定条件开头加“！”）？</p><h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>switch…case是多路分支语句，当然用if也可以达到一样的效果，但是当条件判断项众多时，大量的if…else大大降低了程序的可读性，通俗地说 if 是 两个路口的岔路，case是多个路口的岔路。<br>switch语句的一般形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">case</span> 值n:</span><br><span class="line">        语句块n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句块n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，switch、case、default、break 都是 Java 的关键字。一一介绍一下：</p><ol><li><em>switch</em><br>表示“开关”，这个开关就是 switch 关键字后面小括号里的值，小括号里要放一个整型变量或字符型变量。表达式必须为 byte，short，int，char类型。Java7 增强了 switch 语句的功能，允许 switch 语句的控制表达式是 java.lang.String 类型的变量或表达式。只能是 java.lang.String 类型，不能是 StringBuffer 或 StringBuilder 这两种字符串的类型。</li><li><em>case</em><br>表示“情况，情形”，case 标签可以是：</li></ol><ul><li>类型为 char、byte、 short 或 int 的常量表达式。</li><li>枚举常量。注意：case 值不能重复</li><li>从 Java SE 7 开始， case 标签还可以是字符串字面量。</li></ul><ol start="3"><li><em>default</em><br>表示“默认”，即其他情况都不满足。default 后要紧跟冒号，default 块和 case 块的先后顺序可以变动，不会影响程序执行结果。通常，default 块放在末尾，也可以省略不写。</li><li><em>break</em><br>表示“停止”，即跳出当前结构。<br>如果在 case 分支语句的末尾没有 break 语句，有可能触发多个 case 分支。那么就会接着执行下一个 case 分支语句。这种情况相当危险，常常会引发错误。所以不到非使用不可，咱不用这个。</li></ol><p>我们举两个例子来结束switch的学习，一个正确用法，一个错误用法。<br>小明期末考试结束，成绩90分以上算优秀，他妈说考一个优秀对应奖励一本寒假作业，一个都没有奖励3本，还有一顿打（小明太幸福了），小明这个寒假过的快不快乐呢？我们用switch语句演示一下。<br>先来正确的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(<span class="string">"请输入小明获优个数："</span>);</span><br><span class="line"><span class="keyword">int</span> best = input.nextInt();</span><br><span class="line"><span class="comment">// 我们假设小明一共考三个科目。</span></span><br><span class="line"><span class="keyword">if</span> (best &gt; <span class="number">3</span> || best &lt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"小明：谢谢别乱输入！"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (best) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">"奖励一本"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">System.out.println(<span class="string">"奖励两本"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">System.out.println(<span class="string">"奖励三本"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//0个</span></span><br><span class="line">System.out.println(<span class="string">"奖励三本，一顿毒打"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输入2，看结果：<br><img src="/2020/02/08/javabase5-tjjg/2bjl.png" alt="小明得到两本"><br>如果我们忘了加break会怎样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(<span class="string">"请输入小明获优个数："</span>);</span><br><span class="line"><span class="keyword">int</span> best = input.nextInt();</span><br><span class="line"><span class="comment">// 我们假设小明一共考三个科目。</span></span><br><span class="line"><span class="keyword">if</span> (best &gt; <span class="number">3</span> || best &lt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"小明：谢谢别乱输入！"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (best) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">System.out.println(<span class="string">"奖励一本"</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">System.out.println(<span class="string">"奖励两本"</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">System.out.println(<span class="string">"奖励三本"</span>);</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//0个</span></span><br><span class="line">System.out.println(<span class="string">"奖励三本，一顿毒打"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续输入2：<br><img src="/2020/02/08/javabase5-tjjg/mb.png" alt="小明获得了叠加奖励"><br>小明这下要高兴坏了呢，哈哈哈。忘记break，从匹配那条开始下面的代码都会执行，这是严重的逻辑错误。</p><p>另外代码中if判断的地方为要判断多个条件做了实例，用上了“||”短路或，还有花括号内部用了 return 。“return” 在Java中代表结束，在一个方法中，出现return意味着方法的结束，return 可用在任何方法里， return null/true/false/“”/…  则需要用在有返回值的方法里。方法前有“void”关键字 则说明无返回值，否则有返回值，需要返回什么类型的返回值就要把“void” 换成什么类型，简单举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String who = str();<span class="comment">//声明变量来获得返回值</span></span><br><span class="line">System.out.println(who);</span><br><span class="line">System.out.println(str());<span class="comment">//也可以不用新建对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">str</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"This is kangkang"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/08/javabase5-tjjg/fhz.png" alt="体会一下"></p><h2 id="if-or-switch"><a href="#if-or-switch" class="headerlink" title="if or switch ?"></a>if or switch ?</h2><p>if 和 switch 可以变通，那该怎么选择呢？理论上，条件分支越多，switch 的优势越明显，所以本着物尽其用的原则，在分支少的时候用 if ,分支多的时候用 switch 。</p><p>如果没有编程基础，确实不太容易接收，“无论遇到什么困难我们都不要怕……加油！奥力给！！！”（巨魔吟唱）。随着内容越来越深入，代码越来越复杂，为保证写代码美观、快捷，在此说两个eclipse里常用快捷键，”Alt+/“代码提示，”ctrl+shift+f”代码自动格式化，以及自己设置额key 用 sout 回车打出 System.out.println，注释模板等；感兴趣可以去百度搜一搜，挺好玩的。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>每天一篇，坚持住，今天自己搭个gitlab+本地nginx看了一堆博客随便点开，内容图片都一样，我承认优秀博客不少，但是又相当多的博客都是整篇抄来抄去，自己都不去操作验证，导致找一个适合自己电脑环境而且方法完整正确好难好难，浪费了大量时间。我的知识也都是网络上学的，知道网络博客一大抄的坑，所以我想让我写的每篇博客的内容都有自己实践过，保证正确性。看csdn的博客真的太难了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;条件结构和后面的循环结构我们统称为流程控制。条件结构式代码中最频繁使用的代码块，功能简单粗暴，有说去年再steam上大卖的《太吾绘卷》就是用一堆条件代码写的，哈哈哈谁知道是不是真的呢。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（四）——运算符</title>
    <link href="http://www.mggblog.ink/2020/02/07/javabase4-ysf/"/>
    <id>http://www.mggblog.ink/2020/02/07/javabase4-ysf/</id>
    <published>2020-02-07T06:54:43.000Z</published>
    <updated>2020-02-13T16:47:54.377Z</updated>
    
    <content type="html"><![CDATA[<p><em>觉得上篇概念性的东西讲的太多了，参考了别的地方的资料，过了一天看了看感觉没必要将那么多概念，直接上代码加注释效果更佳，这篇我们讲运算符，分为算术运算符，赋值运算符，关系运算符，逻辑运算符，位逻辑运算符和三目运算符。</em>  </p><a id="more"></a><hr><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>故名思意，就是算数用的，加减乘除，分为一元和二元两种：</p><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><p>一元运算符就是一个元素就可以用，有三个 -、++（自增运算符）、--（自减运算符），自增、自减我们一起带过，不再单独说。<br><img src="/2020/02/07/javabase4-ysf/yyysf.png" alt="一元运算符"><br>++a表示a=a+1,--a表示a=a-1，除了 - 其他两个有运算先后之分，在变量前面先计算,在变量后面则要运行完本条代码后再计算，举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">System.out.println(-a);<span class="comment">//取反</span></span><br><span class="line">System.out.println(++a);<span class="comment">//先运算a=a+1，再输出，输出2;  a=2</span></span><br><span class="line">System.out.println(a++);<span class="comment">//先输出a,输出2,再运算a=a+1,   a=3</span></span><br><span class="line">System.out.println(--a);<span class="comment">//先运算a=a-1,再输出，输出2;   a=2,</span></span><br><span class="line">System.out.println(a--);<span class="comment">//先输出a，输出2，再运算a=a-1, a=1;</span></span><br><span class="line">System.out.println(a);<span class="comment">//输出a,a=1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/07/javabase4-ysf/yyys.png" alt="运行结果"></p><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><p>就是常见的加减乘除等形式，另外还有求模。<br><img src="/2020/02/07/javabase4-ysf/eyysf.png" alt="二元运算符"><br>加减乘除的运算优先级和数学上是一样的，括号内有最高优先级。进行算术运算时应注意以下两点：</p><ul><li>求余（％）运算要求参与运算的两个操作数均为整型，不能为其他类型。</li><li>两个整数进行除法运算，其结果仍为整数。如果整数与实数进行除法运算，则结果为实数。<br>举个例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">float</span> k = <span class="number">1f</span>;</span><br><span class="line">System.out.println(j/i);</span><br><span class="line">System.out.println(k/i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>运行结果<br><img src="/2020/02/07/javabase4-ysf/zylx.png" alt="变量类型不同结果不同"><br>建议写几个加减乘除综合运算（带上取余），用上不同类型，看看结果是不是和想象中一样，光看或者复制我的代码是效果不会很好。</li></ul><h2 id="赋值运算符（-）"><a href="#赋值运算符（-）" class="headerlink" title="赋值运算符（=）"></a>赋值运算符（=）</h2><p>赋值是这种格式 [变量名称=表达式内容] ，不要把 = 想象成数学中的等号，比如 a=b+1 要理解成将b+1的值赋予a,读代码顺序从右往左。<br>赋值运算符可以与算数运算符组合，如 a+=2 等同于 a=a+2 下面列举了常用组合：<br><img src="/2020/02/07/javabase4-ysf/fzzh.png" alt="变量类型不同结果不同"><br>这样的好处是让代码更简洁，易读，易维护，我们动手试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">double</span> price = <span class="number">10.25</span>; <span class="comment">// 定义商品的单价，赋值为10.25</span></span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">0</span>; <span class="comment">// 定义总价初始为0</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">2</span>; <span class="comment">// 定义购买数量，赋值为2</span></span><br><span class="line">    price -= <span class="number">1.25</span>; <span class="comment">// 减去降价得到当前单价</span></span><br><span class="line">    count *= <span class="number">5</span>; <span class="comment">// 现在需要购买10个，即原来数量的5倍</span></span><br><span class="line">    total = price * count; <span class="comment">// 总价=当前单价*数量</span></span><br><span class="line">    System.out.printf(<span class="string">"商品当前的单价为：%4.2f \n"</span>, price); <span class="comment">// 输出当前单价</span></span><br><span class="line">    System.out.printf(<span class="string">"购买商品的数量为：%d \n"</span>, count); <span class="comment">// 输出购买数量</span></span><br><span class="line">    System.out.printf(<span class="string">"总价为：%4.2f \n"</span>, total); <span class="comment">// 输出总价</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/07/javabase4-ysf/zhys.png" alt="组合运算"></p><h2 id="逻辑运算符（-amp-amp-、-、-）"><a href="#逻辑运算符（-amp-amp-、-、-）" class="headerlink" title="逻辑运算符（&amp;&amp;、||、!）"></a>逻辑运算符（&amp;&amp;、||、!）</h2><p>逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。包含逻辑与、或、非和短路与、或。逻辑运算符是对布尔型变量进行运算，其结果也是布尔型：<br><img src="/2020/02/07/javabase4-ysf/ljysf.png" alt="逻辑运算符"><br>短路的意思我们举个例子解释一下：</p><ul><li>&amp;&amp; 与 &amp; 区别：如果 a 为 false，则不计算 b（因为不论 b 为何值，结果都为 false）</li><li>|| 与 | 区别：如果 a 为 true，则不计算 b（因为不论 b 为何值，结果都为 true）<br>我们在敲代码时基本很少用到逻辑与、或，常用的都是短路与、或，而且提倡多用短路，节省系统资源。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">boolean</span> a = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(!a);</span><br><span class="line">System.out.println(a&amp;b);</span><br><span class="line">System.out.println(a&amp;a);</span><br><span class="line">System.out.println(a&amp;&amp;b);</span><br><span class="line">System.out.println(a&amp;&amp;a);</span><br><span class="line">System.out.println(a|b);</span><br><span class="line">System.out.println(a|a);</span><br><span class="line">System.out.println(a||b);</span><br><span class="line">System.out.println(a||a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/02/07/javabase4-ysf/ljys.png" alt="逻辑运算"><br>看看和自己想象中的结果是否相同。</li></ul><h2 id="关系运算符（比较运算符）"><a href="#关系运算符（比较运算符）" class="headerlink" title="关系运算符（比较运算符）"></a>关系运算符（比较运算符）</h2><p>关系运算符也叫比较运算符，一个字”比“。大于、小于、等于、不等于、小于等于、大于等于，相比结果为布尔型：<br><img src="/2020/02/07/javabase4-ysf/gxysf.png" alt="关系运算符"><br>关系运算符的优先级为：&gt;、&lt;、&gt;=、&lt;= 具有相同的优先级，并且高于具有相同优先级的 !=、==。关系运算符的优先级高于赋值运算符而低于算术运算符，结合方向是自左向右。<br>关系表达式通常用于 Java 程序的逻辑判断语句的条件表达式中。使用关系表达式要注意以下几点：</p><ul><li>运算符 &gt;=、==、！=、&lt;= 是两个字符构成的一个运算符，用空格从中分开写就会产生语法错误。例如 x&gt; =y; 是错误的，但是可以写成x &gt;= y; 在运算符的两侧增加空格会提高可读性。同样将运算符写反，例如 =&gt;、=&lt;、=! 等形式会产生语法错误。</li><li>由于计算机内存放的实数与实际的实数存在着一定的误差，如果对浮点数进行 ==（相等）或 !=（不相等）的比较，容易产生错误结果，应该尽量避免。</li><li>不要将“==”写成“=”。（在进行if条件判断时常会写错）</li></ul><p>这里我们补充个以后写测试类经常会用到的类，控制台输入类$\color{red}{ Scanner }$，我们打开jdk文档看一下，ctrl+f 搜索 scanner （百度也许更快，不过我觉得自己看文档更有逼格，人生不是为了装逼就毫无意义）：<br><img src="/2020/02/07/javabase4-ysf/scanner.png" alt="Scanner类"><br><img src="/2020/02/07/javabase4-ysf/scanner2.png" alt="Scanner类"><br>文档中给出了用法示例，以及各种方法接下来做个练习在控制台输入两个数比较大小（输完第一个数按回车输第二个）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> number1, number2; <span class="comment">// 定义变量，保存输入的两个数</span></span><br><span class="line">    System.out.print(<span class="string">"请输入第一个整数(number1)："</span>);</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    number1 = input.nextInt(); <span class="comment">// 输入第一个数</span></span><br><span class="line">    System.out.print(<span class="string">"请输入第二个整数(number2)："</span>);</span><br><span class="line">    input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    number2 = input.nextInt(); <span class="comment">// 输入第二个数</span></span><br><span class="line">    System.out.printf(<span class="string">"number1=%d,number2=%d\n"</span>, number1, number2); <span class="comment">// 输出这两个数</span></span><br><span class="line">    <span class="comment">// 判断用户输入的两个数是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (number1 == number2) &#123;</span><br><span class="line">        System.out.println(<span class="string">"number1 和 number2 相等。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断用户输入的两个数据是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (number1 != number2) &#123;</span><br><span class="line">        System.out.println(<span class="string">"number1 和 number2 不相等。"</span>);</span><br><span class="line">        <span class="comment">// 判断用户输入的数1是否大于数2</span></span><br><span class="line">        <span class="keyword">if</span> (number1 &gt; number2) &#123;</span><br><span class="line">            System.out.println(<span class="string">"number1 大于 number2。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断用户输入的数1是否小于数2</span></span><br><span class="line">        <span class="keyword">if</span> (number1 &lt; number2) &#123;</span><br><span class="line">            System.out.println(<span class="string">"number1 小于 number2。"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/07/javabase4-ysf/bj.png" alt="比较结果"><br>这里面我们用到了if条件结构，到后面单独说一下吧。</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h3 id="位逻辑运算符"><a href="#位逻辑运算符" class="headerlink" title="位逻辑运算符"></a>位逻辑运算符</h3><p>位逻辑运算用于二进制数的计算，两个数对位上与、或、非、抑或、即位取反。上图：<br><img src="/2020/02/07/javabase4-ysf/wljysf.png" alt="位逻辑运算符"><br>举个例子，计算5&amp;12，我们将计算过程画出来：<br><img src="/2020/02/07/javabase4-ysf/yys.png" alt="5&amp;12"><br>我们看到对位上都为1该位对应的结果为1否则为零，最终计算结果转为十进制为4，那么或（|）运算是对应位置有1就得1，抑或运算（^）是对位相同为1，不同为0，取反（~）是对应位置直接取反，1变0，0变1，我们不再一一举例。</p><h3 id="移位运算符（-gt-gt-、-lt-lt-）"><a href="#移位运算符（-gt-gt-、-lt-lt-）" class="headerlink" title="移位运算符（&gt;&gt;、&lt;&lt;）"></a>移位运算符（&gt;&gt;、&lt;&lt;）</h3><p>移位运算同样对于二进制来说的：</p><ul><li>&gt;&gt; 右移位 例8 &gt;&gt; 1结果为4</li><li>&lt;&lt; 左移位 例9 &lt;&lt; 2结果为36<br>我们联系下左移位运算：例如11 &lt;&lt; 1 结果为22<br><img src="/2020/02/07/javabase4-ysf/zyw.png" alt="11 &lt;&lt; 1"><br>我们发现左移一位结果时原来的二倍，根据二进制转十进制的计算方法，其实就是左移一位就乘二。同理右移一位是除二，我们不再一一举例。</li></ul><h3 id="复合位赋值运算符"><a href="#复合位赋值运算符" class="headerlink" title="复合位赋值运算符"></a>复合位赋值运算符</h3><p>所有的二进制位运算符都有一种将赋值与位运算组合在一起的简写形式。复合位赋值运算符由赋值运算符与位逻辑运算符和位移运算符组合而成：<br><img src="/2020/02/07/javabase4-ysf/fh.png" alt="复合位赋值运算符"><br>其实和+=、-=、一样的理解方法，平时很少用到，不再举例了。</p><h2 id="三目运算符（值-条件-表达式1-表达式2）"><a href="#三目运算符（值-条件-表达式1-表达式2）" class="headerlink" title="三目运算符（值=条件?表达式1:表达式2）"></a>三目运算符（值=条件?表达式1:表达式2）</h2><p>判断是否符合条件，符合运行表达式1，不符合运行表达式2，得出结果。因为右三个因数，所以叫三目运算符，它相当于一个 if……else 条件结构，相比普通if条件结构代码简洁，执行效率高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> i = input.nextInt();</span><br><span class="line">System.out.println(i &gt; <span class="number">10</span> ? <span class="string">"i大于十"</span> :<span class="string">"i小于十"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入几个数试一下<br><img src="/2020/02/07/javabase4-ysf/smys.png" alt="结果"><br>而且三目运算符支持嵌套，比如你可以把“i大于十”换成（ i&gt;15 ? “i大于十五” : “i大于十”），不再举例了。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>说了这么多运算符，web业务代码中位运算是很少用到的，可能嵌入式那边会更常用一些，不用背，多写代码就行。加油！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;觉得上篇概念性的东西讲的太多了，参考了别的地方的资料，过了一天看了看感觉没必要将那么多概念，直接上代码加注释效果更佳，这篇我们讲运算符，分为算术运算符，赋值运算符，关系运算符，逻辑运算符，位逻辑运算符和三目运算符。&lt;/em&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（三）——标识符与关键字、常量与变量、作用域、数据类型和类型转换</title>
    <link href="http://www.mggblog.ink/2020/02/06/javabase3-bsfgjzclbltj/"/>
    <id>http://www.mggblog.ink/2020/02/06/javabase3-bsfgjzclbltj/</id>
    <published>2020-02-06T10:55:50.000Z</published>
    <updated>2020-02-13T16:47:53.507Z</updated>
    
    <content type="html"><![CDATA[<p><em>本篇内容包括Java语言中标识符、关键字、常量、变量和数据类型的讲解，学任何一门语言，这些内容都是最基础也是最重要的，就像盖房子，不同的材料有不同的用处，让材料物尽其用才能盖好房子。实践是检验真理的唯一标准，学知识就要多实践，学计算机语言就要多敲代码，只有这样知识才能学得会，记得牢，技巧也用的熟。</em>  </p><a id="more"></a><hr><h2 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符分为两类，分别为关键字和用户自定义标识符。  </p><ol><li>关键字是有特殊含义的标识符，如 true、false 表示逻辑的真假。  </li><li>用户自定义标识符是由用户按标识符构成规则生成的非保留字的标识符，如 abc 就是一个标识符。<br>提个醒：使用标识符时一定要注意，或者使用关键字，或者使用自定义的非关键字标识符。此外，标识符可以包含关键字，但不能与关键字重名。<br>Java中标识符用来定义方法、变量或者其他用户自定义的名称，它可以是一个字符，也可以是一个字符串。构成规则如下：</li></ol><ul><li>标识符由数字（0-9）和字母（A-Z 和 a-z）、美元符号（$）、下划线（_）以及 Unicode 字符集中符号大于 0xC0 的所有符号组合构成（各符号之间没有空格）。  </li><li>标识符的第一个符号为字母、下划线和美元符号，后面可以是任何字母、数字、美元符号或下划线，不可以用数字开头。</li><li>Java语言中区分大小写，例如boy与Boy是两个不同的字符串<br>提个醒：标识符是变量、类名、方法名的命名，命名提倡给予标识符正确含义，如定义两个男孩可以用boy_1与boy_2，不提倡用a、b定义（要养成好习惯，初学C语言深受老谭毒害）<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/bsf1.png" alt="标识符定义举例"><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3>关键字是说这个标识符有特定的用处，不能随便拿来用，如上图不能用“true”做变量名。每个jdk版本里关键字的数量是一定的，不同的jdk中关键字的数量可能不同。下面列举常见关键字：</li><li>数据类型：boolean、int、long、short、byte、float、double、char、class、interface。</li><li>流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。</li><li>修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。</li><li>动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。</li><li>保留字：true、false、null、goto、const。<br>提个醒：虽然有区分大小写，但是也尽量不要用“Public”、“True”等类似标识符，容易产生歧义。  </li></ul><h2 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h2><h3 id="常量和常量值"><a href="#常量和常量值" class="headerlink" title="常量和常量值"></a>常量和常量值</h3><p>常量就是不变的量，常量值是常量的值（解释的很蠢，但是就是这个意思）。代码中可以使用定义过的常量，也可以直接使用常量值。<strong>定义常量的方法就是在类型前面加关键字“final”。</strong>下面练习定义常量和认识常量值。</p><ol><li>整型常量值，按进制分八进制、十进制、十六进制定义方法直接上图：<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/dyzx.png" alt="定义整型与整型常量值"><br><img src="/2020/02/06/javabase3-bsfgjzclbltj/cl.png" alt="常量无法更改"><br>整型（int）常量默认在内存中占 32 位，是具有整数类型的值，当运算过程中所需值超过 32 位长度时，可以把它表示为长整型（long）数值。长整型类型则要在数字后面加L或1，如697L表示一个长整型数，它在内存中占 64 位。</li><li>实型常量值，两种形式，十进制型小数点形式如9.9，科学计数法如1.1e5或10&amp;E3,其中 e 之前必须有数字，且 e 之后的数字必须为整数。<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/sx.png" alt="实型常量值"><br>注意：小数定义有单精度和双精度只分，单精度在末尾要加上 f 。</li><li>布尔类型常量值，true or false ，只有这两个值。<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/boolean.png" alt="布尔类型常量值"></li><li>字符型和字符串型常量值，字符型如“A，a”,字符串型如“boy,girl”,还有一种转义字符，比如换行符“\n”：<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/zfx.png" alt="字符型常量值"><br>下面列举出常用转移符：<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/zyzf.png" alt="常用的转义字符"><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3>Java中变量的使用有特定规则，必须先声明后使用，指定类型的变量只能接收该类型的值。<strong>声明变量的方法为 [数据类型 变量名 = 值]（例如 String boy = “kangkang”，也可以是 [数据类型 变量名],如 String boy; ）。</strong>在上面说各类型常量值的时候已经用到了变量声明；<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/bl.png" alt="声明变量"><br><img src="/2020/02/06/javabase3-bsfgjzclbltj/smbl.png" alt="一次声明多个变量"><br>声明变量要依据声明类型的类方法，比如String类型就有多种声明方法，这就需要查Java API文档点开对应类，去研究研究这个类究竟有多少使用方法，Java提供了官方文档，有在线也有离线版，使用方法很简单，即使不懂，百度很容易就解决了。举个栗子：<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/api.png" alt="刚才的字符串类型变量声明用到了该构造方法"><br>以后碰到不懂得类，可以翻翻api文档，知识学的很快的，<strong>变大佬必备</strong>。<br>变量标识符的命名规范如下：</li></ol><ul><li>首字符必须是字母、下划线（―）、美元符号（$）或者人民币符号（¥）。</li><li>标识符由数字（0-9）、大写字母（A-Z）、小写字母（a-z）、下划线（―）、美元符号（$）、人民币符号（¥）以及所有在十六进制 0xc0 前的 ASCII 码组成。</li><li>不能把关键字、保留字作为标识符。</li><li>标识符的长度没有限制。</li><li>标识符区分大小写。<br>Java 中初始化变量时需要注意以下事项：</li><li>变量是类或者结构中的字段，如果没有显式地初始化，默认状态下创建变量并默认初始值为 0。</li><li>方法中的变量必须显式地初始化，否则在使用该变量时就会出错。</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域界定了声明变量的使用范围，在Java中认准花括弧”{}”就行。在括弧内声明的变量只能在括弧内使用。根据作用域的不同，把变量分为成员变量和局部变量（当然这都是概念知识，敲多了自然懂）。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>成员变量包含全局变量和静态变量：<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/cybl.png" alt="成员变量"><br>撸个代码看一下如何调用两种变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line"><span class="comment">/*以下都是Boy类里的成员变量*/</span></span><br><span class="line"><span class="keyword">public</span> String name;<span class="comment">//boy 姓名 （实例变量）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;<span class="comment">//年龄 （实例变量）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> String home = <span class="string">"Hebei"</span>;<span class="comment">//家庭住址 静态常量（类变量）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String tel = <span class="string">"8888-6666666"</span>;<span class="comment">//电话 静态变量（类变量）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编个测试类看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">Boy boy1 = <span class="keyword">new</span> Boy();<span class="comment">//将Boy类实例化为boy1</span></span><br><span class="line"><span class="comment">//实例变量必须用实例调用(全局变量)</span></span><br><span class="line">System.out.println(boy1.name);</span><br><span class="line">System.out.println(boy1.age);</span><br><span class="line"><span class="comment">//实例.变量名 调用类变量(类变量)</span></span><br><span class="line">System.out.println(boy1.home);</span><br><span class="line">System.out.println(boy1.tel);</span><br><span class="line"><span class="comment">//类变量不用实例化对象也可以直接 类.变量(类变量)</span></span><br><span class="line">System.out.println(Boy.home);</span><br><span class="line">System.out.println(Boy.tel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/qjbl.png" alt="全局变量与类变量"><br>全局变量有默认初始值，static final修饰的变量必须赋予初始值，类变量的方便之处就是不用实例化对象，直接用[类.变量名]调用。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种：</p><ol><li>方法参数变量（形参）：在整个方法内有效。</li><li>方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。</li><li>代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。</li></ol><p><strong>局部变量在使用前必须被程序员主动初始化值。</strong><br><img src="/2020/02/06/javabase3-bsfgjzclbltj/jberr.png" alt="局部变量没初始值无法通过编译"></p><h4 id="方法局部变量"><a href="#方法局部变量" class="headerlink" title="方法局部变量"></a>方法局部变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>,j = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"i="</span>+i);</span><br><span class="line">System.out.println(<span class="string">"j="</span>+j);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"i="</span>+i);</span><br><span class="line">System.out.println(<span class="string">"j="</span>+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/06/javabase3-bsfgjzclbltj/jbbl.png" alt="方法局部变量"></p><h4 id="方法参数变量"><a href="#方法参数变量" class="headerlink" title="方法参数变量"></a>方法参数变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">Test.add(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//方法参数变量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;<span class="comment">//方法局部变量</span></span><br><span class="line">System.out.println(<span class="string">"i+j="</span>+i+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/06/javabase3-bsfgjzclbltj/csbl.png" alt="方法参数变量"></p><h4 id="代码块局部变量"><a href="#代码块局部变量" class="headerlink" title="代码块局部变量"></a>代码块局部变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">Test.test(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">// 方法参数变量</span></span><br><span class="line"><span class="keyword">try</span> &#123;<span class="comment">// 使用try catch 代码块 异常处理代码块，后面异常篇再详细说</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;代码块 局部变量</span><br><span class="line">System.out.println(<span class="string">"i+j="</span> + i + j);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">// 异常处理块，参数为 Exception 类型</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/02/06/javabase3-bsfgjzclbltj/dmkjb.png" alt="代码块局部变量"><br>作用域讲完了，是不是很简单，看准”{}”，多练比看概念要好得多。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java中数据类型分为<strong>基本型</strong>和<strong>引用型</strong>我们用几张图就能搞定了，多用就能记住，不要死记硬背：<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/lxgx.png" alt="数据类型关系"></p><h3 id="基本型与引用型数据内存存储原理"><a href="#基本型与引用型数据内存存储原理" class="headerlink" title="基本型与引用型数据内存存储原理"></a>基本型与引用型数据内存存储原理</h3><ol><li><p>基本数据类型的存储原理：所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的内存栈上的，数据本身的值就是存储在栈空间里面，Java语言里面八种数据类型是这种存储模型；</p></li><li><p>引用类型的存储原理：引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”(存储对象在内存堆上的地址)是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的；</p><blockquote><p><strong>无论基本数据类型还是引用类型，他们都会先在栈中分配一块内存，对于基本类型来说，这块区域包含的是基本类型的内容；而对于引用类型来说，这块区域包含的是指向真正内容的指针，真正的内容被手动的分配在堆上。（最直观的例子是基本型和引用型值的比较不同，基本型用“ == ”，引用型用需要用类方法，我们将在后面<a href="http://www.mggblog.ink/2020/02/12/javabase10-zfccl3">筑基与修仙（十）</a>详细说明）</strong></p></blockquote><h3 id="基本型"><a href="#基本型" class="headerlink" title="基本型"></a>基本型</h3><p>基本数据类型可分为 4 大类，即整数类型（包括 byte、short，int 和 long）、浮点类型（包括 float 和 double）、布尔类型和字符类型（char）：<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/jblx.png" alt="基本数据类型"><br>Java 定义了 4 种整数类型变量：字节型（byte）、短整型（short）、整型（int）和长整型（long）。这些都是有符号的值，正数或负数。具体说明看图：<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/zxbl.png" alt="整数类型"><br>根据要求使用合适的类型，严格按照变量声明方式，Java中没有无类型变量，不再举例，上面的变量声明练习足够了，可以试着自己把所有类型敲一下。</p><h3 id="引用型"><a href="#引用型" class="headerlink" title="引用型"></a>引用型</h3><p>引用数据类型建立在基本数据类型的基础上，包括数组、类和接口。引用数据类型是由用户自定义，用来限制其他数据的类型。另外，Java 语言中不支持 C++ 中的指针类型、结构类型、联合类型和枚举类型。引用类型还有一种特殊的 null 类型。所谓引用数据类型就是对一个对象的引用，对象包括实例和数组两种。实际上，引用类型变量就是一个指针，只是 Java 语言里不再使用指针这个说法。空类型（null type）就是 null 值的类型，这种类型没有名称。因为 null 类型没有名称，所以不可能声明一个 null 类型的变量或者转换到 null 类型。空引用（null）是 null 类型变量唯一的值。空引用（null）可以转换为任何引用类型。在实际开发中，程序员可以忽略 null 类型，假定 null 只是引用类型的一个特殊直接量（不听不听和尚念经……）。<br>注意：空引用（null）只能被转换成引用类型，不能转换成基本类型，因此不要把一个 null 值赋给基本数据类型的变量。</p></li></ol><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>分隐式转换与显示转换两种。</p><h3 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h3><p>如果以下 2 个条件都满足，那么将一种类型的数据赋给另外一种类型变量的时，将执行自动类型转换：</p><ol><li>两种数据类型彼此兼容</li><li>目标类型的取值范围大于源数据类型（低级类型数据转换成高级类型数据）<br>例如 byte 类型向 short 类型转换时，由于 short 类型的取值范围较大，会自动将 byte 转换为 short 类型。<br>在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。自动转换的规则是从低级类型数据转换成高级类型数据。转换规则如下：</li></ol><ul><li>数值型数据的转换：byte→short→int→long→float→double。</li><li>字符型转换为整型：char→int。<br>以上数据类型的转换遵循从左到右的转换顺序，最终转换成表达式中表示范围最大的变量的数据类型，举个栗子。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">float</span> price1 = <span class="number">10.5f</span>; <span class="comment">// 定义牙膏的价格</span></span><br><span class="line">    <span class="keyword">double</span> price2 = <span class="number">3.5</span>; <span class="comment">// 定义面巾纸的价格</span></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">4</span>; <span class="comment">// 定义牙膏的数量</span></span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">5</span>; <span class="comment">// 定义面巾纸的数量</span></span><br><span class="line">    <span class="keyword">double</span> res = price1 * num1 + price2 * num2; <span class="comment">// 计算总价</span></span><br><span class="line">    System.out.println(<span class="string">"一共付了"</span> + res + <span class="string">"元"</span>); <span class="comment">// 输出总价</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/02/06/javabase3-bsfgjzclbltj/lxzh.png" alt="类型自动转换了"><br>看起来很高级，但并不是所有类型都这么好用：<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/zherr.png" alt="int无法转换为byte"><br>那么现在就用到显示转换了。<h3 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h3>当两种数据类型不兼容，或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行强制类型转换。我们把上面没转好的转一下：<br><img src="/2020/02/06/javabase3-bsfgjzclbltj/xszh.png" alt="现在可以了"><br>再举个例子，我们上面去买牙膏用的浮点型算的钱，现在我们只关心花了多少块，不关心几毛钱了。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">float</span> price1 = <span class="number">10.5f</span>; <span class="comment">// 定义牙膏的价格</span></span><br><span class="line">    <span class="keyword">double</span> price2 = <span class="number">3.5</span>; <span class="comment">// 定义面巾纸的价格</span></span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">4</span>; <span class="comment">// 定义牙膏的数量</span></span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">5</span>; <span class="comment">// 定义面巾纸的数量</span></span><br><span class="line">    <span class="keyword">int</span> res = (<span class="keyword">int</span>)(price1 * num1 + price2 * num2); <span class="comment">// 计算总价</span></span><br><span class="line">    System.out.println(<span class="string">"一共付了"</span> + res + <span class="string">"元"</span>); <span class="comment">// 输出总价</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2020/02/06/javabase3-bsfgjzclbltj/zxjs.png" alt="几毛钱不要了"></li></ul><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>腰好疼，一坐就是三个小时，还是要多锻炼肾体啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本篇内容包括Java语言中标识符、关键字、常量、变量和数据类型的讲解，学任何一门语言，这些内容都是最基础也是最重要的，就像盖房子，不同的材料有不同的用处，让材料物尽其用才能盖好房子。实践是检验真理的唯一标准，学知识就要多实践，学计算机语言就要多敲代码，只有这样知识才能学得会，记得牢，技巧也用的熟。&lt;/em&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（二）——Hello world!</title>
    <link href="http://www.mggblog.ink/2020/02/05/javabase2-helloworld/"/>
    <id>http://www.mggblog.ink/2020/02/05/javabase2-helloworld/</id>
    <published>2020-02-05T06:25:29.000Z</published>
    <updated>2020-02-13T16:47:52.488Z</updated>
    
    <content type="html"><![CDATA[<p><em>上一篇博客介绍了Java基本知识，接下来我们以在Windows上开发为例（不同的系统环境只是配置环境变量的方法不一样），正式开始Java的学习。本篇内容包含：Java开发环境配置，年轻人的第一个Java程序和Java集成开发环境（IDE）的使用。</em></p><a id="more"></a><hr><h2 id="安装Java开发和运行环境"><a href="#安装Java开发和运行环境" class="headerlink" title="安装Java开发和运行环境"></a>安装Java开发和运行环境</h2><p>想要运行Java程序，系统需要具备Java运行环境，也就是Java Runtime Environment,简称JRE。但是如果要开发Java程序，需要的是Java Development Kit,Java程序开发工具包，也就是我们常说的JDK。一半只有服务器才会安装单独的JRE环境，开发人员需要两个都有，我们只需要去甲骨文官网下载JDK就可以，安装文件中包含了JDK和JRE。<br>百度直接搜索“jdk”，找到甲骨文官网jdk下载页，我习惯使用jdk8,我们以jdk8的安装为例（jdk并不是越新越好，现在还有相当多的企业项目用的是jdk6,新的jdk含有新的Java规范，不同的jdk环境编译出的class文件不一样，如果开发人员jdk需要升级，服务器上的jre也要跟着升级，否则旧的环境无法运行新的规范，造成宕机，如果是重要应用，就是生产事故了。所以很多企业级应用开发人员出于稳定考虑，在当前环境满处生产需要时，不会去冒然去升级jdk版本）：<br><img src="/2020/02/05/javabase2-helloworld/bdjdk.png" alt="百度搜索jdk"><br>然后找到版本信息，我是Win10 64位系统选择x64版本，32位系统选择i586版本（虽然64位系统可以安装32位版本，但是为了防止出现各种莫名其妙的错误，最好版本对应）<br><img src="/2020/02/05/javabase2-helloworld/jdkdown.png" alt="JDK支持各种系统环境"><br>下载时可能会让你登录，否者下载不开始，用邮箱注册个账号就行了（现在网络快多了，前几年下载那叫一个慢）。下载好了，开始安装（我安装的是8u181版本，小版本不一样安装没有差别）：<br><img src="/2020/02/05/javabase2-helloworld/jdkinstall.png" alt="打开安装"><br>一直点下一步就可以了（当然推荐你改一下安装位置，只要知道装在哪里就行了，后面配置环境要用）<br><img src="/2020/02/05/javabase2-helloworld/jdkinstall1.png" alt="安装完毕关掉"><br>如果安装完找不到了咋办，卸载重新装，很快的这次记好了。<br><img src="/2020/02/05/javabase2-helloworld/uninstalljdk.png" alt="注意这两个要都卸载掉"><br>安装完成打开Windows控制台，win+r调出运行输入cmd回车（也可以使用Win10快速检索win+q,输入cmd，需要管理员权限的控制台时这个方式更好用）输入java -version<br><img src="/2020/02/05/javabase2-helloworld/hj3.png" alt="java -version"><br>说明安装成功了，接下来我们配置环境变量，右击此电脑选择属性，选择高级系统设置，点击环境变量，在下面系统变量里新建”JAVA_HOME”和”CLASSPATH”两个变量，JAVA_HOME中的值为刚才安装Java选定的位置，<br><img src="/2020/02/05/javabase2-helloworld/jdkwz.png" alt="jdk安装位置"><br>我的位置是”C:\Program Files\Java\jdk1.8.0_181”,复制进去保存。在CLASSPATH中输入”.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;”（复制时别复制冒号，注意开头分号前面有”.”）<br><img src="/2020/02/05/javabase2-helloworld/hj1.png" alt="两项添加完"><br>然后找到”Path”，点击编辑添加依次输入”%JAVA_HOME%\bin”和”%JAVA_HOME%\jre\bin”保存（不同系统可能页面显示的不一样不是这种的话需要用分号隔开，这样”%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;”）<br><img src="/2020/02/05/javabase2-helloworld/hj2.png" alt="修改Path"><br>修改成功后保存完成关闭面板，打开新的控制台输入”javac”回车，如果成功出现下图内容，则说明环境配置成功，接下来就可以进行开发学习了，如果不成功，请仔细检查环境变量配置步骤中的内容是否正确。<br><img src="/2020/02/05/javabase2-helloworld/hj5.png" alt="javac是编译程序"></p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world!"></a>Hello world!</h2><p>终于可以开始敲代码了，接下来有请年轻人的第一个Java程序”Hello world!”闪亮登场（传统艺能，传统艺能……）！在本地磁盘D新建”Demo”文件夹,打开文件夹新建Hello.txt记事本文件（”.txt”是文件扩展名，如果新建记事本不显示扩展名，请百度”如何显示文件扩展名”，比较简单，这里没有截图），在记事本中输入如下代码：</p><figure class="highlight java"><figcaption><span>Hello.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存记事本然后修改扩展名为”.java”，提示可能无法使用点确定（文件名字可以不叫”Hello”,但是一定要与代码中”public class”后面的名字一模一样，注意区分大小写,代码中符号都是英文符号）。<br><img src="/2020/02/05/javabase2-helloworld/hello1.png" alt="Hello.java"><br>然后打开控制台进入Demo,我的在D盘，打开cmd后直接输入”d:”回车，然后”cd demo”进入demo文件夹（Windows里文件名是不区分大小写的）。输入”javac Hello.java”回车，如果代码没有错误就什么都不显示，否则会报出异常。如下图：<br><img src="/2020/02/05/javabase2-helloworld/errjava.png" alt="代码有误缺少一个分号"><br><img src="/2020/02/05/javabase2-helloworld/javac.png" alt="代码无误，编译完成生成.class文件"><br>然后我们通过”java”命令运行文件（注意不用带文件扩展名）：<br><img src="/2020/02/05/javabase2-helloworld/java.png" alt="运行.class文件"><br>如图，我们成功打印出了设定内容”Hello world!”,我们第一个Java程序完成（呱唧呱唧<del>~</del>）。那么我们来稍微了解一下代码是怎么回事吧：<br><img src="/2020/02/05/javabase2-helloworld/code.png" alt="Hello.java"><br>有间隔的每个字段意义都不同，我来一一说明：</p><ul><li>关键字class用来定义一个类，Hello是类的名称；</li><li>在Java程序中，所有的语句都必须放在某个类中；</li><li>整个类及其所有成员都包含在一对花括号中（即{和}之间），它们标志着类定义块的开始和结束。</li><li>定义类的一般语法：<figure class="highlight java"><figcaption><span>Hello.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>程序必须从main函数开始执行；</li><li>关键字public是访问修饰符，用来控制类成员的可见范围及作用域；</li><li>关键字static允许在不创建类的实例的情况下，调用main函数；</li><li>关键字void用来说明main函数是没有返回值的；</li><li>args是字符串数组，用来从命令行接收参数；</li><li>main函数的一般形式如下：<figure class="highlight java"><figcaption><span>Hello.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>String[]是字符串类型的数组；</li><li>在Java中，类名称一般首字母大写；</li><li>使用System.out.println()将信息输出到控制台上，即打印出来。<br>解析完代码，你是否对Java代码规范有了一知半解了呢，试着修改代码按照刚才的步骤在控制台打出更多内容吧。这次我们使用上注释，注释不会被编译，有两种形式一种为“// ……”,可以注释掉同行的代码，一种是代码段注释“/<em>……</em>/”，注释掉一段代码（注意使用英文，当前开发环境简陋，使用中文可能导致编码异常）：<figure class="highlight java"><figcaption><span>Hello.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* This class mean to print "Hello world!"</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">// print Hello world!</span></span><br><span class="line">System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">System.out.println(<span class="string">"I am Zhangsan"</span>);</span><br><span class="line"><span class="comment">/*System</span></span><br><span class="line"><span class="comment">.out</span></span><br><span class="line"><span class="comment">.println("I am a girl");*/</span></span><br><span class="line"><span class="comment">//System.out.println("I am a boy");</span></span><br><span class="line">System.out.println(<span class="string">"I am a boy"</span>);</span><br><span class="line">System.out.println(<span class="string">"I am 10 years old "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>编译运行！<br><img src="/2020/02/05/javabase2-helloworld/java1.png" alt="注释掉的代码不会执行"><br>通过”javadoc”命令可以将注释内容提取，生成一个文件方便查阅，来试试看：<br><img src="/2020/02/05/javabase2-helloworld/javadoc.png" alt="javadoc"><br>生成了一堆文件<br><img src="/2020/02/05/javabase2-helloworld/javadoc2.png" alt="javadoc"><br>打开index.html<br><img src="/2020/02/05/javabase2-helloworld/javadoc3.png" alt="javadoc"><br>到此为止，对Java初体验结束，初学者是不是感觉收货满满，这是是Java的冰山一角，她的众多优秀特性我们到后面再慢慢了解。<h2 id="集成开发环境（IDE）"><a href="#集成开发环境（IDE）" class="headerlink" title="集成开发环境（IDE）"></a>集成开发环境（IDE）</h2>Java开发人员常用的开发软件有三个，分别是Eclipse、Myeclipse、Idea（剩下的都是些小众的，我也不了解）我说一说我对这三个软件的理解：<h3 id="Eclipse"><a href="#Eclipse" class="headerlink" title="Eclipse"></a>Eclipse</h3>Eclipse轻量，简洁，操作简便，对电脑配置要求较低，并且开源免费，更适合Java初学者。缺点是简洁到几乎没有插件，后面很多开发必须插件都需要自己安装，好在eclipse提供插件支持，可以再软件里一键安装。<br><img src="/2020/02/05/javabase2-helloworld/eclipse1.png" alt="eclipse"><br><img src="/2020/02/05/javabase2-helloworld/eclipse2.png" alt="eclipse工作界面"><h3 id="Myeclipse"><a href="#Myeclipse" class="headerlink" title="Myeclipse"></a>Myeclipse</h3>它是Eclipse的定制版本，对电脑配置要求较高，而且收费，集众多生产插件于一身，免除了自己装插件的烦恼，相比eclipse功能更完善（毕竟花了钱的）。<br><img src="/2020/02/05/javabase2-helloworld/myeclipse.png" alt="Myeclipse"><br><img src="/2020/02/05/javabase2-helloworld/myeclipse1.png" alt="Myeclipse工作界面基本和eclipse一样"><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3>相对于先前两个，IDEA是重量级的集成开发工具，对电脑配置要求高，支持多种语言开发，拥有丰富的开源插件生态，功能相当完善，是众多开发者的首选工具，大佬必备（意义简单粗暴），这么优秀的工具肯定是需要掏钱的，官方推出了完整版和社区版（阉割版），社区版是免费的。但是在我们国内网络现在的大环境下，搜索破解方法还是相当简单的（我们这么喜欢你你竟然要收我们钱？哈哈哈……），不过在国人版权意识逐渐苏醒的今天，我呼吁有能力的开发者尽量使用正版软件（哎吆我插会儿腰……嘿嘿嘿）。<br><img src="/2020/02/05/javabase2-helloworld/idea.png" alt="IDEA"><br><img src="/2020/02/05/javabase2-helloworld/idea1.png" alt="IDEA工作界面（我使用了主题插件）"><br>开发工具介绍完毕，作为Java初学者建议使用eclipse，虽然一步到位使用IDEA更好，但是IDEA相对来说对电脑配置要求高，如果配置跟不上会卡顿，严重影响开发体验，撇去性能不谈，IDEA自动保存，但是没有自动编译，需要手动编译（虽然可以自己设置自动编译，但我劝你别），eclipse点击保存的时候自动编译。所以等以后碰到语言多了，比如学习Spring boot或者开发项目需要同时操作好几门语言，这时候一个IDEA就可以完全搞定了。好了开发工具搞定，我们顺便在eclipse上撸个”Hello world!”吧。  <h2 id="在eclipse上运行Hello-world"><a href="#在eclipse上运行Hello-world" class="headerlink" title="在eclipse上运行Hello world"></a>在eclipse上运行Hello world</h2>安装eclipse需要验证环境变量，如果环境变量没安装好，eclipse无法正常安装，<a href="https://www.eclipse.org/downloads/">下载地址</a>。<br>安装过程（这种种边下载边安装的形式，耐心等待安装完成，也可以点击下载页下载按钮地下的 Download Packages 整包下载）：<br><img src="/2020/02/05/javabase2-helloworld/eclipseinstall.png" alt="安装eclipse"><br>安装完成首次打开会让你选择工作空间，也就是你的项目要放的目录,默认或自己设都行。<br><img src="/2020/02/05/javabase2-helloworld/eclipse3.png" alt="设置工作空间"><br>进入界面点击工具栏File&gt;new&gt;java project(如果没有选择project然后搜索java project)&gt;填写项目信息&gt;完成，如图：<br><img src="/2020/02/05/javabase2-helloworld/eclipse4.png" alt="新建Java工程"><br><img src="/2020/02/05/javabase2-helloworld/newjava.png" alt="选择Java工程"><br><img src="/2020/02/05/javabase2-helloworld/newjava1.png" alt="填写工程信息"><br><img src="/2020/02/05/javabase2-helloworld/newjava2.png" alt="完成"><br>若遇到弹窗提示点Ok就可以了。<br>点开工程&gt;右击src&gt;new&gt;class&gt;填写类信息&gt;finish<br><img src="/2020/02/05/javabase2-helloworld/newclass.png" alt="new class"><br>打开Demo类<br><img src="/2020/02/05/javabase2-helloworld/demojava.png" alt="入口代码都已经生成好了"><br>在光标处敲入System.out.println(“Hello world!”); 保存，代码正确会自动编译，代码错误会有提示，没有错误点运行。<br><img src="/2020/02/05/javabase2-helloworld/rundemo.png" alt="运行"><br>运行成功<br><img src="/2020/02/05/javabase2-helloworld/rundemo2.png" alt="运行成功"></li></ul><p>以上是这篇博客的全部内容，从环境变量配置到集成环境运行代码都很顺利，初学者如果哪里有不懂，欢迎邮件交流，感谢您的阅读。</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>写博客是真的累，坐了一下午，不过程序员就要坐的住，哈哈，前期工作都已完成，接下来开始学习Java正经内容，待续……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;上一篇博客介绍了Java基本知识，接下来我们以在Windows上开发为例（不同的系统环境只是配置环境变量的方法不一样），正式开始Java的学习。本篇内容包含：Java开发环境配置，年轻人的第一个Java程序和Java集成开发环境（IDE）的使用。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA零基础筑基到修仙（一）——JAVA简介</title>
    <link href="http://www.mggblog.ink/2020/02/04/javabase1-jj/"/>
    <id>http://www.mggblog.ink/2020/02/04/javabase1-jj/</id>
    <published>2020-02-04T09:22:05.000Z</published>
    <updated>2020-02-13T16:47:51.709Z</updated>
    
    <content type="html"><![CDATA[<p><em>虽然是复习Java知识，可能过于基础的前几个博客都没有必要写，但是本着善始善终原则，以及本身是强迫症患者，所以力求做到尽善尽美，还是写出来吧。书回正传，本篇博客将简单介绍关于JAVA的基础知识，用处不大，我尽量缩短篇幅，减少不必要的时间浪费。</em></p><a id="more"></a><hr><h2 id="了解JAVA语言"><a href="#了解JAVA语言" class="headerlink" title="了解JAVA语言"></a>了解JAVA语言</h2><p>一句话介绍：Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。<br>Java为什么叫”Java“,上图解释更为直观，我们只说些有趣的，百度百科几万字大概很少有人全看完：<br><img src="/2020/02/04/javabase1-jj/zwd.png" alt="Java名字来源于爪洼岛"><br>远古图片看起来辣眼睛？<br><img src="/2020/02/04/javabase1-jj/zwdmap.png" alt="谷歌地图上的爪洼岛"><br>你们说这爪洼岛它大吗？它不是大不大，它是那种很……打住，先上一张图<br><img src="/2020/02/04/javabase1-jj/javalogo.png" alt="Java的logo"><br>这是Java的logo，他看上去是一杯热气腾腾的咖啡，所以这和爪洼岛有什么关系？爪洼岛属于印尼，印尼是世界几大咖啡产地之一，爪哇岛上生产的少量Arabica原种咖啡豆，曾是世界级的优良品种。那为什么就要用”Java“来命名这门语言呢？大概Java缔造者们钟情与这种咖啡吧。听起来像那么回事哈，其实就是这么回事，只是他们原本要注册为“Ock”橡树，但是这个商标被注册了，这才有了Java。  </p><p>Java诞生之初也是Internet兴起之时，在Java出现以前，几乎没有工具可以在Internet上执行动态交互程序，因此Java对Internet的发展产生了巨大的影响，Internet使Java成为网络上最流行的编程语言（确信）。（我们通常也说Java长于web）下面我们说说Java的相关知识（想到什么写什么）：  </p><ul><li>Java是一种面向对象的语言（相对于C语言，C语言是面向过程的语言）；  </li><li>Java程序的类型是Application，即可以运行在控制台，也可以运行在图形界面；  </li><li>Java运行在虚拟机（JVM）中，让它成为跨平台语言，即：编写一次，随处运行；（虚拟机很吊，一定要单独学学，技术大佬必备）<br><img src="/2020/02/04/javabase1-jj/javarun.png" alt="Java运行机制"><br><img src="/2020/02/04/javabase1-jj/jvmjh.png" alt="虚机交互关系大概是这个样子"></li><li>Java语言编写的Applet程序可以对用户的输入和操作作出响应；  </li><li>Applet是用Java编写，在Internet上运行的程序，可以在任何客户端系统上下载，在浏览器中运行；  </li><li>Java不仅适用于单机应用程序和基于网络的程序，也可用于创建消费类设备的附件程序，如移动电话、掌上设备等；  </li><li>开发和运行Java程序，必须依赖和使用由Sun公司提供的Java开发工具包（Java Development Kit，我们常说的JDK）；  </li><li>为适应不同的用途，又将其细分为三个版本：JavaSE（标准版，适用于普通应用程序的开发）、JavaEE（企业版，适用于大型企业级应用程序的开发）、JavaME（微型版，适用于移动设备或嵌入式设备的程序开发）。  </li></ul><p>能想到的基础点就这些，上面罗列这些每一条都有很多文章，我还是个弟弟程序猿，不能把这些牛逼的东西一一详细描述，还是要多学习啊（叹气）。  </p><p>Java从1995年正式发布到现在已经过了25年了，它凭借自身的通用性、高效性、平台移植性以及安全性站在了编程语言排行榜的顶峰（2018、2019年排行数据，其实已经蝉联好几年了），Java是世界上最好的编程语言（确信233），所以为什么不学Java？</p><hr><h2 id="小尾巴"><a href="#小尾巴" class="headerlink" title="小尾巴"></a>小尾巴</h2><p>这是我第一篇博客，理科生也没有那么多华丽的辞藻，内容肯定也不能谈得上好，写博客这些开源框架还都是现学现卖，事实上看我博客也就图一乐，真要学习还是要找<a href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程</a>，可是谁没有第一次呢，是吧（试着给自己打气）。接下来会带来环境安装与第一个Java程序”Hello world“（学习语言传统艺能）以及后续开发IDE工具介绍，待续……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;虽然是复习Java知识，可能过于基础的前几个博客都没有必要写，但是本着善始善终原则，以及本身是强迫症患者，所以力求做到尽善尽美，还是写出来吧。书回正传，本篇博客将简单介绍关于JAVA的基础知识，用处不大，我尽量缩短篇幅，减少不必要的时间浪费。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础学习" scheme="http://www.mggblog.ink/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="http://www.mggblog.ink/tags/Java/"/>
    
  </entry>
  
</feed>
