{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于Mgg","text":"大家好，我是Mgg，一个工作一年多的本科JAVA程序猿，资质平平没什么可吹嘘的。做这个博客的目的是整理与复习自己的知识，相对于看书写云笔记，自己搭个博客效果肯定更好(在不懂的朋友面前装逼哈哈哈)，如果无意中帮助到您，那可真是幸会幸会。这个博客现在用的是github的代理，后续我会把它搭到自己的服务器，然后争取也搞个微信公众号。博客内容基本自己写，不过难免有引用，如有侵权请及时邮箱联系（邮箱地址首页小信封）。 我的微信公众号我的其他站点","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"JAVA零基础筑基到修仙（一）——JAVA简介","text":"虽然是复习Java知识，可能过于基础的前几个博客都没有必要写，但是本着善始善终原则，以及本身是强迫症患者，所以力求做到尽善尽美，还是写出来吧。书回正传，本篇博客将简单介绍关于JAVA的基础知识，用处不大，我尽量缩短篇幅，减少不必要的时间浪费。 了解JAVA语言一句话介绍：Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。Java为什么叫”Java“,上图解释更为直观，只说些有趣的，百度百科几万字大概很少有人全看完： 远古图片看起来辣眼睛？ 你们说这爪洼岛它大吗？它不是大不大，它是那种很……打住，先上一张图 这是Java的logo，他看上去是一杯热气腾腾的咖啡，所以这和爪洼岛有什么关系？爪洼岛属于印尼，印尼是世界几大咖啡产地之一，爪哇岛上生产的少量Arabica原种咖啡豆，曾是世界级的优良品种。那为什么就要用”Java“来命名这门语言呢？大概Java缔造者们钟情与这种咖啡吧。听起来像那么回事哈，其实就是这么回事，只是他们原本要注册为“Ock”橡树，但是这个商标被注册了，这才有了Java。 Java诞生之初也是Internet兴起之时，在Java出现以前，几乎没有工具可以在Internet上执行动态交互程序，因此Java对Internet的发展产生了巨大的影响，Internet使Java成为网络上最流行的编程语言（确信）。（通常也说Java长于web）下面说说Java的相关知识（想到什么写什么）： Java是一种面向对象的语言（相对于C语言，C语言是面向过程的语言）； Java程序的类型是Application，即可以运行在控制台，也可以运行在图形界面； Java运行在虚拟机（JVM）中，让它成为跨平台语言，即：编写一次，随处运行；（虚拟机很吊，一定要单独学学，技术大佬必备） Java语言编写的Applet程序可以对用户的输入和操作作出响应； Applet是用Java编写，在Internet上运行的程序，可以在任何客户端系统上下载，在浏览器中运行； Java不仅适用于单机应用程序和基于网络的程序，也可用于创建消费类设备的附件程序，如移动电话、掌上设备等； 开发和运行Java程序，必须依赖和使用由Sun公司提供的Java开发工具包（Java Development Kit，常说的JDK）； 为适应不同的用途，又将其细分为三个版本：JavaSE（标准版，适用于普通应用程序的开发）、JavaEE（企业版，适用于大型企业级应用程序的开发）、JavaME（微型版，适用于移动设备或嵌入式设备的程序开发）。 能想到的基础点就这些，上面罗列这些每一条都有很多文章，我还是个弟弟程序猿，不能把这些牛逼的东西一一详细描述，还是要多学习啊（叹气）。 Java从1995年正式发布到现在已经过了25年了，它凭借自身的通用性、高效性、平台移植性以及安全性站在了编程语言排行榜的顶峰（2018、2019年排行数据，其实已经蝉联好几年了），Java是世界上最好的编程语言（确信233），所以为什么不学Java？ 小尾巴这是我第一篇博客，理科生也没有那么多华丽的辞藻，内容肯定也不能谈得上好，写博客这些开源框架还都是现学现卖，事实上看我博客也就图一乐，真要学习还是要找菜鸟教程，可是谁没有第一次呢，是吧（试着给自己打气）。接下来会带来环境安装与第一个Java程序”Hello world“（学习语言传统艺能）以及后续开发IDE工具介绍，待续……","link":"/2020/02/04/javabase1-jj/"},{"title":"JAVA零基础筑基到修仙（十）——字符串处理（3）","text":"本篇内容：字符串的比较和查找。字符串比较在代码中非常常见，多用于判断和验证，如根据字符串内容执行不同的代码，验证是否符合逻辑规则否则抛出异常等等，下面根据实际方法来说一下。 一、字符串比较字符串比较是否相等，比较大小，比较前缀后缀，非常常见，Java为我们提供了三个字符串比较方法，分别是equals() 方法、equalsIgnoreCase() 方法、 compareTo() 方法，方法的返回值都是布尔类型（boolean），下面分开介绍。 equals()只比较两个字符串的值是否相等，用法： 1str1.equals(str2); 比如小羊们需要验证是谁在敲门： 12345678910public static void main(String[] args) { // TODO Auto-generated method stub Scanner input = new Scanner(System.in); String str = input.nextLine(); if(\"mother\".equals(str)) { System.out.println(\"open the door\"); }else { System.out.println(\"call 110\"); }} 运行结果 这里我们说一下 equals() 与 “ == “的区别，equals() 比较的是字符串的内容，而” == “比较的是对象实例，使用” == “比较两个对象即使字符串相同，返回结果也会是 false，简言之基础类型用==，String 类型用 equals()。举个例子： 1234567891011public static void main(String[] args) {// TODO Auto-generated method stubString str1 = \"abc\";String str2 = new String(\"abc\");//基础类型数据使用 == 比较int i = 10;int j = 10;System.out.println(str1.equals(str2)); //trueSystem.out.println(str1 == str2); //falseSystem.out.println(i == j); //true} equalsIgnoreCase()本方法与 equals() 用法形式相同，用法区别于笨方法不区分大小写，我想不需要举例解释了吧。 compareTo()比较两个字符串谁大谁小，形式： 1str.compareTo(String otherstr); str 值在参数 otherstr 值前 结果为负，否则为正，两个字符串相等结果为零，举例： 123456public static void main(String[] args) { // TODO Auto-generated method stub String str1 = \"abc\"; System.out.println(str1.compareTo(\"bcd\")); System.out.println(str1.compareTo(\"abc\"));} 运行结果 二、字符串查找String 类的 indexOf() 方法和 lastlndexOf() 方法用于在字符串中获取匹配字符（串）的索引值。 indexOf()indexOf() 方法用于返回字符（串）在指定字符串中首次出现的索引位置，如果能找到，则返回索引值，否则返回 -1。该方法主要有两种重载形式： 12str.indexOf(value);str.indexOf(value,int fromIndex); 其中，str 表示指定字符串；value 表示待查找的字符（串）；fromIndex 表示查找时的起始索引，如果不指定 fromIndex，则默认从指定字符串中的开始位置（即 fromIndex 默认为 0）开始查找。举个例子： 12345678public static void main(String[] args) { // TODO Auto-generated method stub String str = \"hello world\"; int i = str.indexOf(\"o\"); int j = str.indexOf(\"o\",5); System.out.println(i); System.out.println(j);} lastlndexOf()lastIndexOf() 方法用于返回字符（串）在指定字符串中最后一次出现的索引位置，如果能找到则返回索引值，否则返回 -1。该方法也有两种重载形式： 12str.lastIndexOf(value)str.lastlndexOf(value, int fromIndex) lastIndexOf() 方法的查找策略是从右往左查找，如果不指定起始索引，则默认从字符串的末尾开始查找。举例： 12345678public static void main(String[] args) { // TODO Auto-generated method stub String str = \"hello world\"; int i = str.lastIndexOf(\"o\"); int j = str.lastIndexOf(\"o\",5); System.out.println(i); System.out.println(j);} 补充：根据索引查找String 类的 charAt() 方法可以在字符串内根据指定的索引查找字符，形式： 1str.charAt(int index); 例如： 123456public static void main(String[] args) { // TODO Auto-generated method stub String str = \"hello world\"; char c = str.charAt(6); System.out.println(c);} 小尾巴字符串处理写完了，方法众多不可能说全部记下来，多练的意义在于加深印象，遇到相关需求的时候知道有这么个方法可以解决问题，不要到时候发出“这可咋办的呼喊”，又到深夜了，加油！奥利给！！！","link":"/2020/02/12/javabase10-zfccl3/"},{"title":"JAVA零基础筑基到修仙（十二）——数字处理类（Math，Random，BigInteger，BigDecimal）","text":"只用四则运算符无法完成三角、对数、指数等复杂运算，以及非常大的数字运算，Java提供Math等类解决问题，本篇内容有：Math类常用方法，随机数生成，数字格式化，大数字运算。 一、Math类常用方法挑一些经常用到的，有静态常量（自然数e，圆周率π）、求最大最小值和绝对值、求整、三角函数、指数运算，其实最常用的就是最大最小值和求整了。 静态常量自然数e和圆周率π： 1234//eMath.E;//πMath.PI; 控制台输出看看： 12System.out.println(\"e=\"+Math.E);System.out.println(\"π=\"+Math.PI); 二、求最大最小值和绝对值最常用功能，几个函数搞定，使用方法： 1Math.方法名; 函数与说明： 函数 说明 static int abs(int a) 返回 a 的绝对值 static long abs(long a) 返回 a 的绝对值 static float abs(float a) 返回 a 的绝对值 static double abs(double a) 返回 a 的绝对值 static int max(int x,int y) 返回 x 和 y 中的最大值 static double max(double x,double y) 返回 x 和 y 中的最大值 static long max(long x,long y) 返回 x 和 y 中的最大值 static float max(float x,float y) 返回 x 和 y 中的最大值 static int min(int x,int y) 返回 x 和 y 中的最小值 static long min(long x,long y) 返回 x 和 y 中的最小值 static double min(double x,double y) 返回 x 和 y 中的最小值 static float min(float x,float y) 返回 x 和 y 中的最小值 实践一下，分别求一下最大值最小值与绝对值： 123456789public static void main(String[] args) { // TODO Auto-generated method stub int i = 29; int j = 98; int k = -200; System.out.println(Math.max(i, j)); System.out.println(Math.min(i, j)); System.out.println(Math.abs(k));} 求整运算多用在需要不要求高精度数据展示的时候，使用方法： 1Math.方法名; 函数与说明： 函数 说明 static double ceil(double a) 返回大于或等于 a 的最小整数 static double floor(double a) 返回小于或等于 a 的最大整数 static double rint(double a) 返回最接近 a 的整数值，如果有两个同样接近的整数，则结果取偶数 static int round(float a) 将参数加上 1/2 后返回与参数最近的整数 static long round(double a) 将参数加上 1/2 后返回与参数最近的整数，然后强制转换为长整型 实践一下： 123456789public static void main(String[] args) { // TODO Auto-generated method stub Scanner input = new Scanner(System.in); double num = input.nextDouble(); System.out.println(\"大于或等于 \"+ num +\" 的最小整数：\" + Math.ceil(num)); System.out.println(\"小于或等于 \"+ num +\" 的最大整数：\" + Math.floor(num)); System.out.println(\"将 \"+ num +\" 加上 0.5 之后最接近的整数：\" + Math.round(num)); System.out.println(\"最接近 \"+num+\" 的整数：\" + Math.rint(num));} 三角函数运算大概要做加密，或者数学运算软件才会用到： 1Math.方法名; 函数与说明： 函数 说明 static double sin(double a) 返回角的三角正弦值，参数以孤度为单位 static double cos(double a) 返回角的三角余弦值，参数以孤度为单位 static double asin(double a) 返回一个值的反正弦值，参数域在 [-1,1]，值域在 [-PI/2,PI/2] static double acos(double a) 返回一个值的反余弦值，参数域在 [-1,1]，值域在 [0.0,PI] static double tan(double a) 返回角的三角正切值，参数以弧度为单位 static double atan(double a) 返回一个值的反正切值，值域在 [-PI/2,PI/2] static double toDegrees(double angrad) 将用孤度表示的角转换为近似相等的用角度表示的角 staticdouble toRadians(double angdeg) 将用角度表示的角转换为近似相等的用弧度表示的角 来实践一下： 1234567public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(\"90 度的正弦值：\" + Math.sin(Math.PI/2)); System.out.println(\"0 度的余弦值：\" + Math.cos(0)); System.out.println(\"0.5 的反正切值：\" + Math.atan(0.5)); System.out.println(\"120 度的弧度值：\" + Math.toRadians(120.0));} 指数与对数运算也是很少用到。 1Math.方法名; 方法 说明 static double exp(double a) 返回 e 的 a 次幂 static double pow(double a,double b) 返回以 a 为底数，以 b 为指数的幂值 static double sqrt(double a) 返回 a 的平方根 static double cbrt(double a) 返回 a 的立方根 static double log(double a) 返回 a 的自然对数，即 lna 的值 static double log10(double a) 返回以 10 为底 a 的对数 实践一下： 123456public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(\"2 的立方值：\" + Math.pow(2, 3)); System.out.println(\"10 的平方根：\" + Math.sqrt(10)); System.out.println(\"10 为底 2 的对数：\" + Math.log10(2));} 观察发现Java并没有提供log a（b）的方法，因为Java提供的两个对数方法已经足够计算机算对数用了，如果需要计算普通对数，可以变通一下，利用高中数学里用到的换底公式，log a (b) = log n (b) / log n (a) ,把 n 代为自然数 e 就可以了,当然log10()也是可以的。 1234 public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(&quot;8 为底 2 的对数：&quot; + (Math.log(8) / Math.log(2))); // 3.0} 三、随机数生成随机数也是非常常用的功能，比如需要从数据库随机抓取数据，Java中的 Random 类提供众多生成随机数的方法，另外 Math 类也提供了一个生成随机数的方法 Math.random()，还有一种野路子，使用 currentTimeMillis（时间处理会用到，可以先了解一下） 获取毫秒值 取模生成随机数。一般情况下生成整数随机数的需求比较多一点。 Math.random()如果只是随便生成一个 float 随机数，那用这个是非常合适的选择，因为 Math 是静态类，不用new 来新建对象。这个方法返回带正号的 double 值，该值大于等于 0.0 且小于 1.0，但是可以通过乘法来扩大数值，然后通过加减运算再取整函数来获得一个符合预期的随机数。 12345678public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(Math.random()); //0.24037287785722083 //比如我想要一个100 以内的随机数 System.out.println((int)(Math.random()*100)); //39 //想得到一个50-100的随机数 System.out.println((int)(50+(Math.random()*(100-50)))); //68} 无论是这个方法取随机还是用 Random类 生成特定范围内的随机数，算法都是一样的 ( int )(min + ( 方法 *( max - main ))) 。用 currentTimeMillis() 略有不同 把中间乘号改为取模( % )。 Random 类方法Random 类为我们提供了整套的随机数生成方案，足够日常业务需求使用。打开JDK帮助文档看看吧（变懒了不想手写表格了），首先是用法： 123456//首先需要新建 Random 对象Random rd = newRandom();//重载构造 带种子的对象Random rd = newRandom(long seed);//然后调用方法类型 变量名 = rd.方法; 看图： 方法不做详细说明等会直接写个demo，说一下这个种子是什么鬼。种子在这里可能是翻译问题，用标识说更贴切，如 new Random(1) 当运行的时候用 1 的标识生成的随机数，即使再运行也不会变；如果是 new Random() 同个方法每次运行生成的随机数都会不一样。 把这段代码运行两次： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub Random rd1 = new Random(1); Random rd2 = new Random(); for (int i = 5; i &gt; 0; i--) { System.out.print(rd1.nextInt(100)+\" \"); } System.out.println(\"\\n~~~~~~~~~~~~~~\"); for (int i = 5; i &gt; 0; i--) { System.out.print(rd2.nextInt(100)+\" \"); }} 运行第一次运行第二次 看到使用种子创建对象的类方法产生的随机数是一样的，在实际使用的时候还是不带种子的多一些。 把其他方法都跑一下， 1234567891011121314151617181920212223public static void main(String[] args) { // TODO Auto-generated method stub Random r = new Random(); double d1 = r.nextDouble(); // 生成[0,1.0]区间的小数 double d2 = r.nextDouble() * 7; // 生成[0,7.0]区间的小数 int i1 = r.nextInt(10); // 生成[0,10]区间的整数 int i2 = r.nextInt(18) - 3; // 生成[-3,15]区间的整数 long l1 = r.nextLong(); // 生成一个随机长整型值 boolean b1 = r.nextBoolean(); // 生成一个随机布尔型值 float f1 = r.nextFloat(); // 生成一个随机浮点型值 System.out.println(\"生成的[0,1.0]区间的小数是：\" + d1); System.out.println(\"生成的[0,7.0]区间的小数是：\" + d2); System.out.println(\"生成的[0,10]区间的整数是：\" + i1); System.out.println(\"生成的[-3,15]区间的整数是：\" + i2); System.out.println(\"生成一个随机长整型值：\" + l1); System.out.println(\"生成一个随机布尔型值：\" + b1); System.out.println(\"生成一个随机浮点型值：\" + f1); System.out.print(\"下期七星彩开奖号码预测：\"); for (int i = 1; i &lt; 8; i++) { int num = r.nextInt(9); // 生成[0,9]区间的整数 System.out.print(num); }} currentTimeMillis()这是个牛逼的野路子，大佬的思路我不懂，一般也不会用这个，不详细说了，举个例子带过吧。 方法返回从1970年1月1日0时0分0秒（这与UNIX系统有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数。 123456public static void main(String[] args) { int max = 100, min = 1; long randomNum = System.currentTimeMillis(); int ran3 = (int) (randomNum % (max - min) + min); System.out.println(ran3);// 60} 四、数字格式化数字的格式在解决实际问题时使用非常普遍，这时可以使用 DecimalFormat 类对结果进行格式化处理。例如，将小数位统一成 2 位，不足 2 位的以 0 补齐。DecimalFormat 是 NumberFormat 的一个子类，用于格式化十进制数字。DecimalFormat 类包含一个模式和一组符号，常用符号看图举个例子： 123456789101112131415public static void main(String[] args) { // 实例化DecimalFormat类的对象，并指定格式 DecimalFormat df1 = new DecimalFormat(\"0.0\"); DecimalFormat df2 = new DecimalFormat(\"#.#\"); DecimalFormat df3 = new DecimalFormat(\"000.000\"); DecimalFormat df4 = new DecimalFormat(\"###.###\"); Scanner scan = new Scanner(System.in); System.out.print(\"请输入一个float类型的数字：\"); float f = scan.nextFloat(); // 对输入的数字应用格式，并输出结果 System.out.println(\"0.0 格式：\" + df1.format(f)); System.out.println(\"#.# 格式：\" + df2.format(f)); System.out.println(\"000.000 格式：\" + df3.format(f)); System.out.println(\"###.### 格式：\" + df4.format(f));} 五、大数字运算Java提供两个类进行大数字处理，BigInteger 类和 BigDecimal 类，解决 int 范围问题（任何数字数据类型都有范围 Java中 int 是-2147483648 ~ 2147483647 这和计算机二进制补码计算有关，感兴趣可以了解一下，用2147483647+1看看会得到什么结果）。 BigInteger使用方法： 12//创建对象 val 是十进制数字 但是注意参数格式是字符串BigInteger bi = BigInteger(String val) 文档里方法太多了我挑些常用的方法（和 int不同的地方在于不能使用运算符计算，要用方法计算）： 12345public static void main(String[] args) { BigInteger bi = new BigInteger(\"999999999999999\"); // 加一 System.out.println(\"加1结果：\" + bi.add(new BigInteger(\"1\")));} BigDecimalBigDecimal 多用于算钱，在数量较大时又能保证高精度（支持任何精度），比 BigInteger 更为实用，用法和 BigInteger 基本一样，先建对象，再使用方法计算。 12//创建对象 val 是十进制数字 但是注意参数格式是字符串BigDecimal bd = new BigDecimal(String val) 计算方法(文档里太难看了我放到excel)：其中，divide() 方法的 3 个参数分别表示除数、商的小数点后的位数和近似值处理模式。 BigDecimal 还提供了计算模式，各种模式满足你算钱的需求（看了文档才知道这么厉害，我以前也就用它加加减减）： 举个例子描述结束今天的学习： 12345public static void main(String[] args) { BigDecimal bi = new BigDecimal(\"999999999999999.345678\"); // 加法 System.out.println(\"加法结果：\" + bi.add(new BigDecimal(\"1.3465\")));} 小尾巴这些内容可以分俩博客讲的，但是我觉得东西不多，就直接塞一块儿了，夜深了，睡觉了。","link":"/2020/02/13/javabase12-math/"},{"title":"JAVA零基础筑基到修仙（十一）——Java正则表达式","text":"Java正则表达式也是字符串处理的内容，但是并不几个方法就能说清楚的，所以单独拿出来说一说。正则表达式多用于数据筛选，数据验证等，重要且用途广泛。但是Java正则表达式内容很多，以我的三脚猫功夫怕是讲不出个所以然，在我看博客学正则时看到一个几万字的博客，虽然他也是转载的吧，正则表达式详解,作为初学者只需要记住几个常见的正则写法：电话，邮箱，用户名，密码，等真的需要考虑特别复杂情况的正则时再翻书学习，因为并不是天天写正则，现在学个大概，到用时差不多也忘光了。本篇大量引用了c语言中文网-Java正则表达式,同时推荐去看一下菜鸟教程。 正则表达式（regex）由普通字符与特殊字符组成，用来匹配一个或多个字符，如：”^\\d+(.\\d+)?”,可以匹配带小数点的数。 String 类提供了几个特殊的字符串匹配方法，这些方法依赖于Java对正则表达式的支持： boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。 String replaceAll(String regex, String replacement)：将该字符串中所有匹配 regex 的子串替换成 replacement。 String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配 regex 的子串替换成 replacement。 String[] split(String regex)：以 regex 作为分隔符，把该字符串分割成多个子串。 上面举的匹配小数的正则表达式例子看上去很复杂，其实并不复杂，随便一个字符串就是一个正则表达式，如”abc”，只是它只能匹配”abc”而已，功能强大的正则表达式，只是一个特殊的字符串，那应该如何创建正则表达式呢？ 正则表达式的构成 组成正则表达式的合法字符 字符 描述 X 字符x（x 可代表任何合法的字符) \\0mnn 八进制数 0mnn 所表示的字符 \\xhh 十六进制值 0xhh 所表示的字符 \\uhhhh 十六进制值 0xhhhh 所表示的 Unicode 字符 \\t 制表符（“\\u0009”） \\n 新行（换行）符（‘\\u000A’） \\r 回车符（‘\\u000D’) \\f 换页符（‘\\u000C’） \\a 报警（bell）符（‘\\u0007’） \\e Escape 符（‘\\u001B’） \\cx x 对应的的控制符。例如，\\cM匹配 Ctrl-M。x 值必须为 A~Z 或 a~z 之一。 特殊字符，使用特殊字符时要加转义字符“\\” 字符 描述 $ 匹配一行的结尾。要匹配 $ 字符本身，请使用\\$ ^ 匹配一行的开头。要匹配 ^ 字符本身，请使用\\^ () 标记子表达式的开始和结束位置。要匹配这些字符，请使用\\(和\\) [] 用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用\\[和\\] {} 用于标记前面子表达式的出现频度。要匹配这些字符，请使用\\{和\\} * 指定前面子表达式可以出现零次或多次。要匹配 * 字符本身，请使用\\* + 指定前面子表达式可以出现一次或多次。要匹配 + 字符本身，请使用\\+ ? 指定前面子表达式可以出现零次或一次。要匹配 ？字符本身，请使用\\? . 匹配除换行符\\n之外的任何单字符。要匹配.字符本身，请使用. \\ 用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配\\字符，请用\\\\ | 指定两项之间任选一项。如果要匹配丨字符本身，请使用\\| 上面所说的只能匹配单个字符，通配符让正则表达式真正的强大起来。 字符 描述 \\. 可以匹配任何字符 \\d 匹配 0~9 的所有数字 \\D 匹配非数字 \\s 匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等 \\S 匹配所有的非空白字符 \\w 匹配所有的单词字符，包括 0~9 所有数字、26 个英文字母和下画线_ \\W 匹配所有的非单词字符 上面的 7 个预定义字符其实很容易记忆，其中： d 是 digit 的意思，代表数字。 s 是 space 的意思，代表空白。 w 是 word 的意思，代表单词。 d、s、w 的大写形式恰好匹配与之相反的字符。举个例子：12c\\\\wt // 可以匹配cat、cbt、cct、cOt、c9t等一批字符串\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d // 匹配如 000-000-0000 形式的电话号码 在一些特殊情况下，例如，若只想匹配 a~f 的字母，或者匹配除 ab 之外的所有小写字母，或者匹配中文字符，上面这些预定义字符就无能为力了，此时就需要使用方括号表达式，方括号表达式有几种形式。 方括号表达式 说明 表示枚举 例如[abc]表示 a、b、c 其中任意一个字符；[gz]表示 g、z 其中任意一个字符 表示范围：- 例如[a-f]表示 a~f 范围内的任意字符；[\\u0041-\\u0056]表示十六进制字符 \\u0041 到 \\u0056 范围的字符。范围可以和枚举结合使用，如[a-cx-z]，表示 a~c、x~z 范围内的任意字符 表示求否：^ 例如[^abc]表示非 a、b、c 的任意字符；[^a-f]表示不是 a~f 范围内的任意字符 表示“与”运算：&amp;&amp; 例如 [a-z&amp;&amp;[def]]是 a~z 和 [def] 的交集，表示 d、e f[a-z&amp;&amp;^bc]]是 a~z 范围内的所有字符，除 b 和 c 之外 [ad-z] [a-z&amp;&amp;[m-p]]是 a~z 范围内的所有字符，除 m~p 范围之外的字符 表示“并”运算 并运算与前面的枚举类似。例如[a-d[m-p]]表示 [a-dm-p] 方括号表达式比前面的预定义字符灵活多了，几乎可以匹配任何字符。例如，若需要匹配所有的中文字符，就可以利用 [\\u0041-\\u0056] 形式——因为所有中文字符的 Unicode 值是连续的，只要找出所有中文字符中最小、最大的 Unicode 值，就可以利用上面形式来匹配所有的中文字符。 正则表达式还支持圆括号，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符|。例如，正则表达式“((public)|(protected)|(private))”用于匹配 Java 的三个访问控制符其中之一。 除此之外，Java 正则表达式还支持几个边界匹配符: 边界匹配符 说明 ^ 行的开头 $ 行的结尾 \\b 单词的边界 \\B 非单词的边界 \\A 输入的开头 \\G 前一个匹配的结尾 \\Z 输入的结尾，仅用于最后的结束符 \\z 输入的结尾 前面例子中需要建立一个匹配 000-000-0000 形式的电话号码时，使用了 \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d 正则表达式，这看起来比较烦琐。实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。 Greedy（贪婪模式）：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。 Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。 Possessive（占有模式）：用加号后缀（+）表示，目前只有 Java 支持占有模式，通常比较少用。 如图： 12345String str = \"hello,java!\";// 贪婪模式的正则表达式System.out.println(str.replaceFirst(\"\\\\w*\" , \"■\")); //输出■,java!// 勉强模式的正则表达式System.out.println(str.replaceFirst(\"\\\\w*?\" , \"■\")); //输出■hello, java! 当从“hello java!”字符串中查找匹配\\w子串时，因为\\w使用了贪婪模式，数量表示符会一直匹配下去，所以该字符串前面的所有单词字符都被它匹配到，直到遇到空格，所以替换后的效果是“■，Java!”；如果使用勉强模式，数量表示符会尽量匹配最少字符，即匹配 0 个字符，所以替换后的结果是“■hello，java!”。 小尾巴这正则表达式文章让我自己写，我还很菜，写不出来，所以参考了其他博客的文章，毕竟我写代码一年多，还没用到过比较复杂的正则表达式，而且一般正则表达式可以在百度搜出来，但是又不能不写这内容，我自己这段时间学一学，学成回来补充或者重写本篇。","link":"/2020/02/13/javabase11-zzbds/"},{"title":"JAVA零基础筑基到修仙（十四）——包装类、装箱拆箱","text":"Java提倡一切皆对象，是面向对象的语言，但是从数据类型来看，引用型数据有对应的对象类，如String，而基本型数据无法被称为对象，为解决这个尴尬问题，Java为每个基本型数据类提供了对应的类，称为包装类，顾名思义就是给它们外面裹一层。本篇内容：装箱拆箱，包装类应用。 首先要对每个基本类型的包装类是什么有所了解，Java提供的包装类除了 int 和 char 的包装类分别为 Integer 和 Character 外，其他包装类都是首字母变大写，还是比较好记的，如下表。 类型 包装类 byte Byte short Short int Integer long Long char Character float Float double Double boolean Boolean 这些包装类为对应的数据类型提供了丰富的类方法，比如在 String 与 int 类型互转用到的 toString 方法，这么多类型不在一一举例，详情后面单独说。 一、装箱与拆箱顾名思义，装箱是将东西装进去，拆箱是将东西拿出来，对应到包装类操作就分别是：基本型→包装类和包装类→基本型，从jdk1.5版本以来提供了自动装箱拆箱支持，下面来看看如何操作。 123456789public static void main(String[] args) { int i = 100; Integer integer = i; //自动装箱 int j = integer; //自动拆箱 System.out.println(\"拆箱后j=\"+j); Integer integer2 = new Integer(j);//手动装箱 int k = integer2.intValue(); //手动拆箱 System.out.println(\"拆箱后k=\"+k);} 二、包装类应用手动自动拆装都试过了，装箱为的是使用箱子给提供的方法，最常用就是类型转换，在这里用 int String 互转举例，后面再详细说各个包装类： int 类型数据 转为 String ,以后都用自动装箱。要用到 Integer 类中 toString(); 123456public static void main(String[] args) { int i = 100; Integer integer = i; // 自动装箱 String str = integer.toString(); System.out.println(\"装换后字符串：\" + str);} String 转 int ，使用 Integer.parseInt 123456public static void main(String[] args) { String str = \"100\"; int i = Integer.parseInt(str);// 自动拆箱，不拆也没关系 System.out.println(\"str*2=\"+i*2); } 拆箱装箱的目的就是要使用类方法达到一定目的，到后面封装方法也是一样的目的。 小尾巴这篇内容比较少，主要做个介绍，虽然两个概念词听起来很高大上，其实前面已经用到过了，后面的各个包装类，我打算分两次弄完。","link":"/2020/02/14/javabase14-bz-zxcx/"},{"title":"JAVA零基础筑基到修仙（十三）——时间日期处理（Date、Calendar、时间格式化）","text":"在开发中做数据持久化时常常需要统一的时间格式，统一查询口径，方便查询，Java提供了日期处理类 Date 和 Calendar ，Date类封装了系统时间，Calendar 根据系统日历解释 Date 对象，两个类处理时间的思路不一样。本篇内容包括：Date 类与 Calendar 类使用介绍，日期格式化 一、Date 类类 Date 表示特定的瞬间，精确到毫秒(Java中还有一个 Date 类，全称为java.sql.Date,这个类是sql相关时间类，平时用到的是java.util.Date,导包的时候注意别导错了)。它表示时间的顺序是星期、月、日、小时、分、秒、年。打开jdk帮助文档，我们发现 Date 类未过时的构造方法有两个，分别是： Date() 分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 Date(long date) 分配 Date 对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即 1970 年 1 月 1 日 00:00:00 GMT）以来的指定毫秒数。举个例子：123456public static void main(String[] args) { Date d1 = new Date(); Date d2 = new Date(80000000); System.out.println(d1); System.out.println(d2);} 同样可以看到文档中大量方法已经过时，我在下面整理出来可以正常用的： 方法 说明 boolean after(Date when) 判断此日期是否在指定日期之后 boolean before(Date when) 判断此日期是否在指定日期之前 int compareTo(Date anotherDate) 比较两个日期的顺序 boolean equals(Object obj) 比较两个日期的相等性 long getTime() 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来，此 Date 对象表示的毫秒数 String toString() 把此 Date 对象转换为以下形式的 String: dow mon dd hh:mm:ss zzz yyyy。其中 dow 是一周中的某一天(Sun、Mon、Tue、Wed、Thu、Fri 及 Sat) 做个练习： 12345678910public static void main(String[] args) { Date d1 = new Date(); Date d2 = new Date(80000000); System.out.println(d1.after(d2)); System.out.println(d1.before(d2)); System.out.println(d1.compareTo(d2));// 相等返回 0 大于返回1 小于返回-1 System.out.println(d1.equals(d2)); System.out.println(d1.getTime()); System.out.println(d1.toString());} 运行结果 二、Calendar 类Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 因为 Calendar 是一个抽象类，无法像普通类一样 new 一个对象出来，它提供了 getInstance() 方法来完成对象创建： 1Calendar c = Calendar.getInstance(); Calendar 提供了众多时间处理方法，要有个大致了解： 方法 说明 void add(int field, int amount) 根据日历的规则，为给定的日历字段 field 添加或减去指定的时间量 amount boolean after(Object when) 判断此 Calendar 表示的时间是否在指定时间 when 之后，并返回判断结果 boolean before(Object when) 判断此 Calendar 表示的时间是否在指定时间 when 之前，并返回判断结果 void clear() 清空 Calendar 中的日期时间值 int compareTo(Calendar anotherCalendar) 比较两个 Calendar 对象表示的时间值（从格林威治时间 1970 年 01 月 01 日00 时 00 分 00 秒至现在的毫秒偏移量），大则返回 1，小则返回 -1，相等返回 0 int get(int field) 返回指定日历字段的值 int getActualMaximum(int field) 返回指定日历字段可能拥有的最大值 int getActualMinimum(int field) 返回指定日历字段可能拥有的最小值 int getFirstDayOfWeek() 获取一星期的第一天。根据不同的国家地区，返回不同的值 static Calendar getInstance() 使用默认时区和语言坏境获得一个日历 static Calendar getInstance(TimeZone zone) 使用指定时区和默认语言环境获得一个日历 static Calendar getInstance(TimeZone zone,Locale aLocale) 使用指定时区和语言环境获得一个日历 Date getTime() 返回一个表示此 Calendar 时间值（从格林威治时间 1970 年 01 月 01 日 00 时00 分 00 秒至现在的毫秒偏移量）的 Date 对象 long getTimeInMillis() 返回此 Calendar 的时间值，以毫秒为单位 void set(int field, int value) 为指定的日历字段设置给定值 void set(int year, int month, int date) 设置日历字段 YEAR、MONTH 和 DAY_OF_MONTH 的值 void set(int year, int month, int date, int hourOfDay,int minute, int second) 设置字段 YEAR、MONTH、DAY_OF_MONTH、HOUR、 MINUTE 和 SECOND 的值 void setFirstDayOfWeek(int value) 设置一星期的第一天是哪一天 void setTimeInMillis(long millis) 用给定的 long 值设置此 Calendar 的当前时间值 Calendar 对象可以调用 set() 方法将日历翻到任何一个时间，当参数 year 取负数时表示公元前。Calendar 对象调用 get() 方法可以获取有关年、月、日等时间信息，参数 field 的有效值由 Calendar 静态常量指定。 Calendar 类中定义了许多常量，分别表示不同的意义。 Calendar.YEAR：年份。 Calendar.MONTH：月份。 Calendar.DATE：日期。 Calendar.DAY_OF_MONTH：日期，和上面的字段意义完全相同。 Calendar.HOUR：12小时制的小时。 Calendar.HOUR_OF_DAY：24 小时制的小时。 Calendar.MINUTE：分钟。 Calendar.SECOND：秒。 Calendar.DAY_OF_WEEK：星期几。 例如要获取当前月份： 1int month = Calendar.getInstance().get(Calendar.MONTH); 方法都用用： 123456789101112131415161718192021222324252627282930public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); // 如果不设置时间，则默认为当前时间 calendar.setTime(new Date()); // 将系统当前时间赋值给 Calendar 对象 System.out.println(\"现在时刻：\" + calendar.getTime()); // 获取当前时间 int year = calendar.get(Calendar.YEAR); // 获取当前年份 System.out.println(\"现在是\" + year + \"年\"); int month = calendar.get(Calendar.MONTH) + 1; // 获取当前月份（月份从 0 开始，所以加 1） System.out.print(month + \"月\"); int day = calendar.get(Calendar.DATE); // 获取日 System.out.print(day + \"日\"); int week = calendar.get(Calendar.DAY_OF_WEEK) - 1; // 获取今天星期几（以星期日为第一天） System.out.print(\"星期\" + week); int hour = calendar.get(Calendar.HOUR_OF_DAY); // 获取当前小时数（24 小时制） System.out.print(hour + \"时\"); int minute = calendar.get(Calendar.MINUTE); // 获取当前分钟 System.out.print(minute + \"分\"); int second = calendar.get(Calendar.SECOND); // 获取当前秒数 System.out.print(second + \"秒\"); int millisecond = calendar.get(Calendar.MILLISECOND); // 获取毫秒数 System.out.print(millisecond + \"毫秒\"); int dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH); // 获取今天是本月第几天 System.out.println(\"今天是本月的第 \" + dayOfMonth + \" 天\"); int dayOfWeekInMonth = calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH); // 获取今天是本月第几周 System.out.println(\"今天是本月第 \" + dayOfWeekInMonth + \" 周\"); int many = calendar.get(Calendar.DAY_OF_YEAR); // 获取今天是今年第几天 System.out.println(\"今天是今年第 \" + many + \" 天\"); Calendar c = Calendar.getInstance(); c.set(2008, 8, 8); // 设置年月日，时分秒将默认采用当前值 System.out.println(\"设置日期为 2008-8-8 后的时间：\" + c.getTime()); // 输出时间} 运行结果： 到后面会专门写个日历的博客，以现在的进度放在这里写有点不合适（先挖个坑）。 三、日期格式化大多数时候不能直接使用 Date 类提供的时间格式，Date 原时间格式用的最多的时候应该是写系统日志，这是专门给人看的，只要可以分辨就可以了。但是大多数业务逻辑下，时间都是要存入数据库，要通过时间来查询，如果直接存时间戳进去，数据库sql写着比较麻烦，还要转格式，比如我把日期用String格式存起来（20200214000000），写查询sql的时候就可以直接用了。 Java为我们提供了 DateFormat 类和它的子类 SimpleDateFormat 类来完成日期格式化，下面一起来看一看。 DateFormat 类DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。将日期表示为 Date 对象，或者表示为从 GMT（格林尼治标准时间）1970 年 1 月 1 日 00:00:00 这一刻开始的毫秒数。 因为是抽象类，所以也不能使用 new 来创建实例对象，使用静态类方法 getDateInstance() : 1DateFormat df = DateFormat.getDatelnstance(); 创建完对象，来看一下它的类方法： 方法 说明 String format(Date date) 将 Date 格式化日期/时间字符串 Calendar getCalendar() 获取与此日期/时间格式相关联的日历 static DateFormat getDateInstance() 获取具有默认格式化风格和默认语言环境的日期格式 static DateFormat getDateInstance(int style) 获取具有指定格式化风格和默认语言环境的日期格式 static DateFormat getDateInstance(int style,Locale locale) 获取具有指定格式化风格和指定语言环境的日期格式 static DateFormat getDateTimeInstance() 获取具有默认格式化风格和默认语言环境的日期/时间格式 static DateFormat getDateTimeInstance(int dateStyle,int timeStyle) 获取具有指定日期/时间格式化风格和默认语言环境的日期/时间格式 static DateFormat getDateTimeInstance(int dateStyle,int timeStyle,Locale locale) 获取具有指定日期/时间格式化风格和指定语言环境的日期/时间格式 static DateFormat getTimeInstance() 获取具有默认格式化风格和默认语言环境的时间格式 static DateFormat getTimeInstance(int style) 获取具有指定格式化风格和默认语言环境的时间格式 static DateFormat getTimeInstance(int style,Locale locale) 获取具有指定格式化风格和指定语言环境的时间格式 void setCalendar(Calendar newCalendar) 为此格式设置日历 Date parse(String source) 将给定的字符串解析成日期/时间 格式化样式主要通过 DateFormat 常量设置。将不同的常量传入到表 1 所示的方法中，以控制结果的长度。DateFormat 类的常量如下。 SHORT：完全为数字，如 12.5.10 或 5:30pm。 MEDIUM：较长，如 May 10，2016。 LONG：更长，如 May 12，2016 或 11:15:32am。 FULL：是完全指定，如 Tuesday、May 10、2012 AD 或 11:l5:42am CST。 123456789101112131415161718192021222324252627public static void main(String[] args) { // 获取不同格式化风格和中国环境的日期 DateFormat df1 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA); DateFormat df2 = DateFormat.getDateInstance(DateFormat.FULL, Locale.CHINA); DateFormat df3 = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.CHINA); DateFormat df4 = DateFormat.getDateInstance(DateFormat.LONG, Locale.CHINA); // 获取不同格式化风格和中国环境的时间 DateFormat df5 = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA); DateFormat df6 = DateFormat.getTimeInstance(DateFormat.FULL, Locale.CHINA); DateFormat df7 = DateFormat.getTimeInstance(DateFormat.MEDIUM, Locale.CHINA); DateFormat df8 = DateFormat.getTimeInstance(DateFormat.LONG, Locale.CHINA); // 将不同格式化风格的日期格式化为日期字符串 String date1 = df1.format(new Date()); String date2 = df2.format(new Date()); String date3 = df3.format(new Date()); String date4 = df4.format(new Date()); // 将不同格式化风格的时间格式化为时间字符串 String time1 = df5.format(new Date()); String time2 = df6.format(new Date()); String time3 = df7.format(new Date()); String time4 = df8.format(new Date()); // 输出日期 System.out.println(\"SHORT：\" + date1 + \" \" + time1); System.out.println(\"FULL：\" + date2 + \" \" + time2); System.out.println(\"MEDIUM：\" + date3 + \" \" + time3); System.out.println(\"LONG：\" + date4 + \" \" + time4);} 运行结果： 虽然输出的时间更容易理解了，但是并不能达到要求，还需要更加定制化的时间格式，这时候就要有请 Calendar的儿子 SimpleDateFormat 类上场了。 SimpleDateFormat 类SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。 这个类是最常用的类了，至少我在格式化时间的时候都用它，功能强大，随心所欲。SimpleDateFormat 有四个构造方法，使用方法： 123456//以下三种构造依赖语言环境，可能无法适应特定的语言环境SimpleDateFormat sdf = SimpleDateFormat();SimpleDateFormat sdf = SimpleDateFormat(String pattern);SimpleDateFormat sdf = SimpleDateFormat(String pattern,Locale locale);//用给定的模式和日期符号构造 SimpleDateFormat。SimpleDateFormat sdf = SimpleDateFormat(String pattern,DateFormatSymbols formatSymbols); 要用文本解析时间或者时间解析文本就要有文本规范，不能随便写，SimpleDateFormat 解析文本通过字母符号组成的文本，字母文本都比较好记： 以及解析字符串的例子，以美国时间模式为例（这就是上面说的语言环境）： 我们举一个最常用到方法的例子， 按2020-02-14 12:00:00 形式输出当前时间： 123456public static void main(String[] args) { Date d = new Date(); DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String time = df.format(d); System.out.print(time);} 只要记住大小写字母代表的意义就可以了，记不住差文档也可以，反正这种时间格式化的代码不会天天写，而且现在有专门时间格式化的开源包，比如我用过的 JodaTime ,感兴趣可以了解一下，虽然自己不用处理时间，但是我还是感觉 时间统一用 “ yyyyMMddHHmmss “这种格式简单粗暴，省了好多事。 小尾巴时间处理知道这些足够了，忘了就翻文档，搜博客，还有一种需求是求特定的哪一天是周几啊，距离现在几天啊这种。这就是思想延伸的东西了，这里就不介绍了。","link":"/2020/02/14/javabase13-szcl/"},{"title":"JAVA零基础筑基到修仙（十六）——数据类型封装类","text":"本篇内容：Integer 类、Float 类、Double 类、Number 类、Character 类、Boolean 类、 Byte 类。 一、Integer 类Integer 类在对象中包装了一个基本类型 int 的值。Integer 类型的对象包含一个 int 类型的字段。 两个带参数构造：12Integer integer = new Integer(int val);//参数为整型Integer integer = new Integer(String val);//参数为字符串型 常用方法 方法名 说明 byte byteValue() 以 byte 类型返回该 Integer 的值 short shortValue() 以 short 类型返回该 Integer 的值 int intValue() 以 int 类型返回该 Integer 的值 String toString() 返回一个表示该 Integer 值的 String 对象 boolean equals(Object obj) 比较此对象与指定对象是否相等 int compareTo(Integer anotherlnteger) 在数字上比较两个 Integer 对象，如相等，则返回 0；小于返回负值大于返回正值 Integer valueOf(String s) 返回保存指定的 String 值的 Integer 对象 int parseInt(String s) 将数字字符串转换为 int 数值 其中有几个方法我们在前面 String 与 int 互转已经用过很多次了，看看其他方法是什么个效果： 1234567public static void main(String[] args) { Integer integer = new Integer(\"100\"); System.out.println(integer.compareTo(new Integer(\"200\"))); System.out.println(integer.doubleValue()); System.out.println(integer.byteValue()); System.out.println(integer.floatValue());} Integer常量 常用常量： MAX_VALUE：值为 231-1 的常量，它表示 int 类型能够表示的最大值。 MIN_VALUE：值为 -231 的常量，它表示 int 类型能够表示的最小值。 SIZE：用来以二进制补码形式表示 int 值的比特位数。 TYPE：表示基本类型 int 的 Class 实例。 二、Float 类Float 类在对象中包装一个基本类型 float 的值。Float 类型的对象包含一个 float 类型的字段。 此外，此类提供了几种方法，可将 float 类型与 String 类型互相转换，还提供了处理 float 类型时非常有用的其他一些常量和方法。 Float 类的三个构造方法：123Float float1 = new Float(double value); // 以 double 类型的变量作为参数创建 Float 对象Float float2 = new Float(float value); // 以 float 类型的变量作为参数创建 Float 对象Float float3 = new Float(String s); // 以 String 类型的变量作为参数创建 Float 对象 常用方法Float 同样提供了与字符串之间相互转换的方法，以及用于比较的 equlas方法，来学一下其他方法： 方法 返回值 说明 byteValue() byte 以 byte 类型返回该 Float 的值 doubleValue() double 以 double 类型返回该 Float 的值 floatValue() float 以 float 类型返回该 Float 的值 intValue() int 以 int 类型返回该 Float 的值（强制转换为 int 类型） longValue() long 以 long 类型返回该 Float 的值（强制转换为 long 类型） shortValue() short 以 short 类型返回该 Float 的值（强制转换为 short 类型） isNaN() boolean 如果此 Float 值是一个非数字值，则返回 true，否则返回 false isNaN(float v) boolean 如果指定的参数是一个非数字值，则返回 true，否则返回 false toString() String 返回一个表示该 Float 值的 String 对象 valueOf(String s) Float 返回保存指定的 String 值的 Float 对象 parseFloat(String s) float 将数字字符串转换为 float 数值 写个 float 与 String 转化demo加深印象： 12345678public static void main(String[] args) { String str = \"12.3\"; float num = Float.parseFloat(str); // 将字符串转换为 float 类型的数值 float f = 45.6f; String s = Float.toString(f); // 将 float 类型的数值转换为字符串 System.out.println(num); System.out.println(s);} Float 常量在 Float 类中包含了很多常量，其中较为常用的常量如下。 MAX_VALUE：值为 1.4E38 的常量，它表示 float 类型能够表示的最大值。 MIN_VALUE：值为 3.4E-45 的常量，它表示 float 类型能够表示的最小值。 MAX_EXPONENT:有限 float 变量可能具有的最大指数。 MIN_EXPONENT：标准化 float 变量可能具有的最小指数。 MIN_NORMAL：保存 float 类型数值的最小标准值的常量，即 2-126。 NaN：保存 float 类型的非数字值的常量。 SIZE：用来以二进制补码形式表示 float 值的比特位数。 TYPE：表示基本类型 float 的 Class 实例。 输出看看： 12345678910public static void main(String[] args) { float max_value = Float.MAX_VALUE; // 获取 float 类型可取的最大值 float min_value = Float.MIN_VALUE; // 获取 float 类型可取的最小值 float min_normal = Float.MIN_NORMAL; // 获取 float 类型可取的最小标准值 float size = Float.SIZE; // 获取 float 类型的二进制位 System.out.println(max_value); System.out.println(min_value); System.out.println(min_normal); System.out.println(size);} 三、Double 类Double 类在对象中包装一个基本类型 double 的值。每个 Double 类型的对象都包含一个 double 类型的字段。 此外，该类还提供多个方法，可以将 double 转换为 String，将 String 转换为 double，也提供了其他一些处理 double 时有用的常量和方法。 两个构造方法：12Double d = new Double(double value);//构造一个新分配的 Double 对象，它表示基本的 double 参数Double d = new Double(String s); //构造一个新分配的 Double 对象，表示用字符串表示的 double 类型的浮点值。该方法与 valueOf 方法一样，可将字符串转换为 double 值。 如果字符串有数字以外的字符就会抛出异常。 常用方法这些包装类的类方法基本都差不多：double 型 与 String 互转： 123456789public static void main(String[] args) { String str = \"123.4\"; double num = Double.parseDouble(str); // 将字符串转换为 double 类型的数值 double d = 56.78; String s = Double.toString(d); // 将double类型的数值转换为字符串 System.out.println(Double.isNaN(d)); //验证 System.out.println(num); System.out.println(s);} Double 类常量基本个Float一样： MAX_VALUE:值为 1.8E308 的常量，它表示 double 类型的最大正有限值的常量。 MIN_VALUE：值为 4.9E-324 的常量，它表示 double 类型数据能够保持的最小正非零值的常量。 NaN：保存 double 类型的非数字值的常量。 NEGATIVE_INFINITY：保持 double 类型的负无穷大的常量。 POSITIVE_INFINITY：保持 double 类型的正无穷大的常量。 SIZE：用秦以二进制补码形式表示 double 值的比特位数。 TYPE：表示基本类型 double 的 Class 实例。 四、Number 类抽象类 Number 是 BigDecimal、BigInteger、Byte、Double、Float、Integer、Long 和 Short 类的超类。 Number 的子类必须提供将表示的数值转换为 byte、double、float、int、long 和 short 的方法。 类方法 因为是抽象类，不能自己实例化，要依靠子类，方法： 1Number num = new Integer(); //Integer 可以换为任何子类； 五、Character 类Character 类在对象中包装一个基本类型 char 的值。Character 类型的对象包含类型为 char 的单个字段。 此外，该类提供了几种方法，以确定字符的类别（小写字母，数字，等等），并将字符从大写转换成小写，反之亦然。 编码参照 Unicode 标准，我前面说 char 是 ASCII 码，其实没什么问题，Unicode 是 ASCII 码优化来的，都是机器码。 一个构造方法1Character c = new Character(char value); //构造一个新分配的 Character 对象，用以表示指定的 char 值。 常用方法无论是字符处理还是判断这些方法都是很重要且常用的,方法都是静态方法，可以直接用。 写个demo，验证字符串大小写，并处理为大写。 1234567891011public static void main(String[] args) { char[] c = { 'K', 'a', 'n', 'g' }; for (int i = 0; i &lt; c.length; i++) { if (Character.isLowerCase(c[i])) { c[i] = Character.toUpperCase(c[i]); } } for (char ch : c) { System.out.print(ch + \" \"); }} 六、Boolean 类Boolean 类将基本类型为 boolean 的值包装在一个对象中。一个 Boolean 类型的对象只包含一个类型为 boolean 的字段。 此外，此类还为 boolean 和 String 的相互转换提供了许多方法，并提供了处理 boolean 时非常有用的其他一些常量和方法。 两个构造方法12Boolean b = new Boolean(boolean value); // 分配一个表示 value 参数的 Boolean 对象。 Boolean b = new Boolean(String s); //如果 String 参数不为 null 且在忽略大小写时等于 \"true\"，则分配一个表示 true 值的 Boolean 对象。否则分配一个表示 false 值的 Boolean 对象. 注：一般情况下都不宜使用 new Boolean(boolean value) 构造方法。若不需要新新的实例，则静态工厂 valueOf(boolean) 通常是一个更好的选择。这有可能显著提高空间和时间性能。 注： new Boolean(String s) 字符串参数只能为 true/false 不能时其他，比如 yes/no ，ok 什么的。 常用方法相对其他数据类型方法少的多：其中还有一些静态方法很少用到，不再举例。 常量三个常量，经常用： TRUE：对应基值 true 的 Boolean 对象。 FALSE：对应基值 false 的 Boolean 对象。 TYPE：表示基本类型 boolean 的 Class 对象。 七、Byte 类Byte 类将基本类型 byte 的值包装在一个对象中。一个 Byte 类型的对象只包含一个类型为 byte 的字段。 此外，该类还为 byte 和 String 的相互转换提供了几种方法，并提供了处理 byte 时非常有用的其他一些常量和方法。 两个个构造方法12Byte b = new Byte(byte value);//构造一个新分配的 Byte 对象，以表示指定的 byte 值。 Byte b = new Byte(String s); //构造一个新分配的 Byte 对象，以表示 String 参数所指示的 byte 值。该字符串以使用基数 10 的 parseByte 方法所使用的方式被转换成一个 byte 值。 new Byte(String s) 如果字符串不是 byte值会抛出异常。 常用方法都是一些转换方法：另外还有很多静态方法，感兴趣打开文档看看去。 常量在 Byte 类中包含了很多的常量，其中较为常用的常量如下。 MIN_VALUE：byte 类可取的最小值。 MAX_VALUE：byte 类可取的最大值。 SIZE：用于以二进制补码形式表示的 byte 值的位数。 TYPE：表示基本类 byte 的 Class 实例。 小尾巴内置包装类整完了，看着很多，其实并没多少东西，而且各个类方法都有互通之处，记住一个类就可以了，一般用的的方法都一样。","link":"/2020/02/15/javabase16-sjfzl/"},{"title":"JAVA零基础筑基到修仙（十五）——Object类和System类","text":"Object类是所有类的父类，System类是系统类，把这俩类放一块写。剩下的数据类型包装类放一块，下回写。 一、Object 类类 Object 是类层次结构的根类。每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法（他是所有类的爸爸）。比如随便新建一个类： 123public class person{ ...} 其实等价于 123public class person extends Object { ...} 看一下他的类方法有哪些： 方法 说明 Object clone() 创建与该对象的类相同的新对象 boolean equals(Object) 比较两对象是否相等 void finalize() 当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法 Class getClass() 返回一个对象运行时的实例类 int hashCode() 返回该对象的散列码值 void notify() 激活等待在该对象的监视器上的一个线程 void notifyAll() 激活等待在该对象的监视器上的全部线程 String toString() 返回该对象的字符串表示 void wait() 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待 因为 Object 类是所有类的父类，所以这些方法所有类都可以直接用，其中 getClass、equals、toString比较常用。线程相关方法不会出现在业务代码里，用的也比较少，到线程再学： toString() 方法123456789101112public class Test { public static void main(String[] args) { Person p = new Person(); System.out.println(p.toString()); System.out.println(p); } public static class Person{ int age; String name; }} 结果发现用不用 toString 方法输出结果都是一样的，，这时候可以在 Person 类里重写 toString 方法，让他输出一些有价值的东西（这里涉及后面继承的知识，先看看，不理解后面再学，当前重点在 toString ）。如： 1234567891011121314151617public class Test { public static void main(String[] args) { Person p = new Person(); System.out.println(p.toString()); System.out.println(p); } public static class Person { int age = 10; String name = \"kangkang\"; @Override public String toString() { return \"Person [age=\" + age + \", name=\" + name + \"]\"; } }} 再次运行 equals() 方法文档中解释： 指示其他某个对象是否与此对象“相等”。equals 方法在非空对象引用上实现相等关系： 自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。 对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。 传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。 一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。 对于任何非空引用值 x，x.equals(null) 都应返回 false。 Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。 巴拉巴拉一大堆，以我理解，就是相当于 == 的效果，没什么用，在各个包装类里的 equals 方法都被重写了，没什么好说的，拿出来说的目的是提醒这个方法和平时用的 equals 不一样。 getClass() 方法getClass 返回一个 Class 对象，所以这个方法要配合Class 类方法使用，举个小例子： 123456789public static void main(String[] args) { String str = \"\"; System.out.println(str.getClass());// 获取Class对象 Method[] ms = str.getClass().getMethods();//获取所有方法 System.out.println(str.getClass().getName()); //获取Class对象名称 for (Method m :ms ) { System.out.println(m.getName()); // 遍历方法名 }} 这个 getclass 到后面反射机制的时候会用到。 二、System 类System 类包含一些有用的类字段和方法。它不能被实例化。 在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。 经常用的 System.out.println() 以及 在控制台输入时 System.in ，那么再来了解了解其他常用的系统级方法： arraycopy() 方法该方法的作用是数组复制，即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。该方法的具体定义如下： 1public static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length) 其中，src 表示源数组，srcPos 表示从源数组中复制的起始位置，dest 表示目标数组，destPos 表示要复制到的目标数组的起始位置，length 表示复制的个数。来试一下： 1234567891011121314151617181920212223242526272829 public static void main(String[] args) { char[] srcArray = {'A','B','C','D'}; char[] destArray = {'E','F','G','H'}; System.arraycopy(srcArray,1,destArray,1,2); System.out.println(\"源数组：\"); for(int i = 0;i &lt; srcArray.length;i++) { System.out.print(srcArray[i]+\" \"); } System.out.println(\"\\n目标数组：\"); for(int j = 0;j &lt; destArray.length;j++) { System.out.print(destArray[j]+\" \"); } }``` ![运行结果](javabase15-obj-sys/cp.png) ### currentTimeMillis() 方法返回最准确的可用系统计时器的当前值，以毫微秒为单位。与时钟时间无关系，多用于测试代码执行时间。```java public static void main(String[] args) { long start = System.currentTimeMillis(); for(int i = 0;i &lt; 100000000;i++) { int temp = 0; } long end = System.currentTimeMillis(); long time = end - start; System.out.println(\"程序执行时间\" + time + \"秒\"); } exit() 方法终止当前正在运行的 Java 虚拟机。定义： 1public static void exit(int status) 根据惯例，非 0 的状态码表示异常终止。该方法调用 Runtime 类中的 exit 方法。该方法永远不会正常返回。调用 System.exit(n) 实际上等效于调用： Runtime.getRuntime().exit(n) gc() 方法定义： 1public static void gc() 运行垃圾回收器。 Java 比 C++ 好的地方之一是有这个 gc 自动回收内存，不用自己管，非要自己调用gc的话用吧， 调用 gc 方法暗示着 Java 虚拟机做了一些努力来回收未用对象，以便能够快速地重用这些对象当前占用的内存。当控制权从方法调用中返回时，虚拟机已经尽最大努力从所有丢弃的对象中回收了空间。调用 System.gc() 实际上等效于调用： Runtime.getRuntime().gc() getProperty() 方法这个方法常用，获取系统中已有的键值对的值。定义： 1public static String getProperty(String key) 常见系统属性： 属性 说明 java.version Java 运行时环境版本 java.home Java 安装目录 os.name 操作系统的名称 os.version 操作系统的版本 user.name 用户的账户名称 user.home 用户的主目录 user.dir 用户的当前工作目录 举个例子： 123public static void main(String[] args) { System.out.println(System.getProperty(\"java.home\"));} 就这样吧，不一一距举例了。 小尾巴下一篇一次性把几个数组类型的包装类弄了。","link":"/2020/02/14/javabase15-obj-sys/"},{"title":"JAVA零基础筑基到修仙（十九）——数组查询、复制","text":"本篇内容包括：数组查询指定元素，数组复制 一、数组查询指定元素（binarySearch() 方法）两种搜索，一个是查元素返回索引，一个是限定索引范围查元素返回索引。1. binarySearch(Object[] a,Object key)以 int 型数组为例： 使用二分搜索法来搜索指定的 int 型数组，以获得指定的值。必须在进行此调用之前对数组进行排序（通过 sort(int[]) 方法）。如果没有对数组进行排序，则结果是不确定的。如果数组包含多个带有指定值的元素，则无法保证找到的是哪一个。 使用方法： 1int index = Arrays.binarySearch(int[] arr,int i); Demo： 1234567public static void main(String[] args) { // TODO Auto-generated method stub int[] arr = {55,22,34,77,11}; Arrays.sort(arr); System.out.println(\"元素77的索引为：\"+Arrays.binarySearch(arr, 77)); System.out.println(\"元素77的索引为：\"+Arrays.binarySearch(arr, 33));} 运行结果： 2. binarySearch(Object[] a,int fromIndex,int toIndex,Object key);依然以 int 型数组为例： 使用二分搜索法来搜索指定的 int 型数组的范围，以获得指定的值。必须在进行此调用之前对范围进行排序（通过 sort(int[], int, int) 方法）（jdk文档里这么说，我倒觉得不如直接完全排序清楚）。如果没有对范围进行排序，则结果是不确定的。如果范围包含多个带有指定值的元素，则无法保证找到的是哪一个。 使用方法： 1int index = Arrays.binarySearch(int[] arr,int fromIndex，int endIndex,int i); Demo: 1234567public static void main(String[] args) { // TODO Auto-generated method stub int[] arr = { 55, 22, 34, 77, 11, 66, 35, 26 }; Arrays.sort(arr);// 完全排序 System.out.println(\"元素77的索引为：\" + Arrays.binarySearch(arr, 1, 5, 34)); System.out.println(\"元素11的索引为：\" + Arrays.binarySearch(arr, 1, 5, 11));} 运行结果： 二、数组复制数组复制是编程时常见需求，Java 中提供了四种方法： Arrays 类的 copyOf() 方法 Arrays 类的 copyOfRange() 方法 System 类的 arraycopy() 方法 Object 类的 clone() 方法 下面分别介绍用法： copyOf 与 copyOfRangecopyOf() 方法是复制数组至指定长度，copyOfRange() 方法则将指定数组的指定长度复制到一个新数组中。注意：目标数组如果已经存在，将会被重构。1. copyOf以 int 数组方法为例 使用方法： 1int[] newArr = Arrays.copyOf(int[] arr,int length); Demo: 12345678910public static void main(String[] args) { // TODO Auto-generated method stub int[] arr = { 55, 22, 34, 77, 11, 66, 35, 26 }; int[] newArr = Arrays.copyOf(arr, 7); int[] newArr2 = Arrays.copyOf(arr, 5); System.out.println(\"完全复制的新数组中的元素为\"); for(int i :newArr) System.out.print(i+\" \"); System.out.println(\"\\n未完全复制的新数组中的元素为\"); for(int i :newArr2) System.out.print(i+\" \");} 运行结果： 2. copyOfRange依然以 int 数组为例 使用方法： 1int[] newArr = Arrays.copyOf(int[] arr,int fromIndex,int endIndex); Demo: 1234567public static void main(String[] args) { // TODO Auto-generated method stub int[] arr = { 55, 22, 34, 77, 11, 66, 35, 26 }; int[] newArr = Arrays.copyOfRange(arr,2,10); System.out.println(\"从索引2-5复制的新数组中的元素为\"); for(int i :newArr) System.out.print(i+\" \");} 运行结果： 元素一共八个，但是结束索引的位置是10，新数组中补充了两个 int数组默认值 0 。 三、arraycopy 方法arraycopy() 方法位于 java.lang.System 类中，其语法形式如下： 1System.arraycopy(dataType[] srcArray,int srcIndex,int destArray,int destIndex,int length) 从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的源数组到 dest 引用的目标数组，数组组件的一个子序列被复制下来。被复制的组件的编号等于 length 参数。源数组中位置在 srcPos 到 srcPos+length-1 之间的组件被分别复制到目标数组中的 destPos 到 destPos+length-1 位置。 注意：目标数组不会被覆盖，相当于替换目标数组中元素的值 Demo： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub int[] arr = { 55, 22, 34, 77, 11, 66, 35, 26 }; int[] newArr = {23,34,56,78,90,56,78,23,56,26,33,66,77}; System.out.println(\"原数组中的元素为\"); for(int i :arr) System.out.print(i+\" \"); System.out.println(\"\\n目标数组中的元素为\"); for(int i :newArr) System.out.print(i+\" \"); //原函数索引从 0 开始，目标函数索引从2开始，替换长度为 5 System.arraycopy(arr, 0, newArr, 2, 5); System.out.println(\"\\n复制后目标数组中的元素为\"); for(int i :newArr) System.out.print(i+\" \");} 运行结果： 四、clone 方法Object类方法，原数组可以直接调用，目标数组如果已经存在，将会被重构，由于方法返回值为 Object 型对象，需要强制转换为数组对象（虽然这么说，但是我用过后不用转也可以）。语法： 1type[] newArr = arr.clone(); Demo: 12345678910public static void main(String[] args) { // TODO Auto-generated method stub int[] arr = { 55, 22, 34, 77, 11, 66, 35, 26 }; int[] newArr =(int[]) arr.clone(); System.out.println(\"原数组中的元素为\"); for(int i :arr) System.out.print(i+\" \"); System.out.println(\"\\n新数组中的元素为\"); for(int i :newArr) System.out.print(i+\" \"); System.out.println(\"\\n\"+arr.equals(newArr));} 运行结果： 注意：以上几种方法都是浅拷贝（浅复制）。浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化。深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变。 小尾巴数组常规操作都有了，下回我们一起学三种排序，冒泡、快速、选择排序，这是算法新手的第一个拦路虎，不同语言有不同的写法，但是思路相同。","link":"/2020/02/16/javabase19-array-s-c/"},{"title":"JAVA零基础筑基到修仙（十七）——数组简介和一维数组","text":"一个数据用变量存储，如果10个人名呢，建十个变量也谈不上麻烦，那100个呢？这时候就需要引入一个新的工具来存储数据了，Java为我们提供了数组工具，本篇内容：数组简介，一维数组。 一、数组简介数组（array）是一种最简单的复合数据类型，它是有序数据的集合，数组中的每个元素具有相同的数据类型，可以用一个统一的数组名和不同的下标来确定数组中唯一的元素。根据数组的维度，可以将其分为一维数组、二维数组和多维数组等。 数组特征数组主要有三个基本特征： 一个数组内部存放的数据类型一致，如一个元素是 int 型，其他元素也只能是 int 型。 数组内元素有序排列，这里说的有序是指索引有序，索引从 0 开始，最大值为元素个数 -1。 初始化数组后，数组的元素个数不能再变化。 数组大概是这个样子： 而且还有几个特点： 数组可分为一维数组、二维数组和多维数组。 数值元素默认值为 0 ，引用元素默认为 null，字符型默认为’\\u0000’。 数组内元素可以为数组，这也是多维数组的原理。 数组是 Array 的派生类。可以使用 Array 类方法处理数组 数组的内存存储数组为引用类型，变量名保存在栈中，元素值保存在堆中。以整型数组为例： 如果初始化了一个空数组，堆内数据都为默认值。 二、一维数组上面说了数组是引用类型，所以使用数组时一定要记住需要声明和初始化。 定义一维数组定义数组形式有三种： 直接定义和初始化1int [] a = {1,2,3} 指定数组长度1String [] strs = new String [3]; //当然可以先定义用的时候再初始化 如String [] strs =null ; strs = new String [3]; 不设定长度1String[] arr = new String[] { \"kk\", \"jj\" }; //实在鸡肋方法 “ [] “ 在定义中可以变位置，如 int a [] = new int[3]; 一旦声明了数组的大小，就不能再修改。这里的数组长度也是必需的，不能少。 数组元素赋值与遍历数组中每个元素都有索引且索引从 0 开始，使用中括号 [] 读取索引，如 arr[1] 代表着数组 arr 的第二个元素。赋值与遍历是与索引分不开的，写个例子练习一下，其实前面有写过。 写个Demo，通过控制台给数组赋值，然后再遍历出来。 1234567891011public static void main(String[] args) { // TODO Auto-generated method stub String strs[] = new String[3]; Scanner input = new Scanner(System.in); for(int i = 0 ; i &lt; strs.length ;i++) { System.out.println(\"请输入第\"+(i+1)+\"个元素：\"); strs[i] = input.nextLine(); } System.out.println(\"~~~~~~~~~~~~~~\\n遍历结果为：\"); for(String s : strs) System.out.println(s); //只遍历数据可以用foreach ,需要通过索引操作还是for循环方便。} 运行结果 数组排序Jdk文档中有 Arrays 类定义了大量的数组 sort 方法，可对数组进行排序，感兴趣要去看看 Arrays 类中排序方法的源代码，在这里只说怎么用。 123456public static void main(String[] args) { // TODO Auto-generated method stub int arr[] = {44,55,22,2,1,80}; Arrays.sort(arr); for (int i : arr) System.out.println((i+\" \"); } 运行结果： 后面会详细学三种排序算法（冒泡排序、快速排序、选择排序），先看看源码获得启发。 小尾巴数组这边要多练习，非常重要。","link":"/2020/02/15/javabase17-array/"},{"title":"JAVA零基础筑基到修仙（十八）——二维、多维数组及常用方法","text":"一维数组显然还无法满足日常数据的存储，最常用的 Excel 有行有列就可以满足普通数据的存储需要，二维数组就是表格形式，本期内容：二维数组、多维数组、数组常用方法（Arrays 类） 一、[二维数组]二维数组声明将二维数组理解成一个一维数组的每个元素都是一维数组就可以了，声明方法就是加 [] : 123456// [][] 像一维数组提到的 可以换位置 int[][] arr 或者是 int arr[][]int[][] arr = new int[5][5];//定义五行五列的int数组//或者int[][] arr = new int[5][];//第二维可以不预设长度，但是用到时要先设置好，否者空指针异常。//或者int arr[][]; //等用到了再初始化 直接给值 或者设定长度 Demo： 12345678910public static void main(String[] args) { // TODO Auto-generated method stub int arr1[][] = new int[2][2];//声明时初始化 int arr2[][] = new int[2][]; //声明时第二维没有初始化 int arr3[][]; //声明时未初始化 arr3 = new int[2][2]; System.out.println(arr1); System.out.println(arr2); System.out.println(arr3);} 运行结果： 二维数组赋值与遍历选择初始化时直接赋值或者通过索引赋值。 直接赋值：12//二维 int 型数组int arr[][] = {{1,2,3},{4,5,6}}; for 循环赋值一维数组赋值时使用一个 for 循环，二维时就需要再嵌套一个 for 循环：12345for(int i = 0; i &lt; arr.length; i++) { for(int j = 0; j &lt; arr[i].length;j++) { arr[i][j] = value; }} 赋值用了两层，那么遍历也需要两层，来练习一下。 创建一个二维数组，从控制台输入值并且遍历： 1234567891011121314151617public static void main(String[] args) { // TODO Auto-generated method stub int arr[][] = new int[2][2]; Scanner input = new Scanner(System.in); for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.println(\"请输入第\" + (i + 1) + \"行第\" + (j + 1) + \"列元素：\"); arr[i][j] = input.nextInt(); } } System.out.println(\"\\n~~~~~~~~~~~~\"); for (int i = 0; i &lt; arr.length; i++) { for (int j = 0; j &lt; arr[i].length; j++) { System.out.println(\"第\" + (i + 1) + \"行第\" + (j + 1) + \"列元素=\" + arr[i][j]); } }} 运行结果 遍历也可以使用 foreach ,同样要使用两层： 12345for(int[] row : arr ){ for(int val : row){ .... }} 每个数组元素都会获得了，那获取整行整列也就比较简单了。 以上面demo为例，获取第一行，只需要使用第一个索引就可以了 。 12int[] row = arr[0];for(int i : row) System.out.println(i); 如果要获取某一列的值就有点麻烦了，无法直接通过获取数组来遍历了，需要使用 for 循环，访问下标,比如获取第二列： 123for(int i = 0;i&lt;arr.length;i++) { System.out.println(\"第\"+2+\"列：\"+arr[i][1]);} 二、多维数组其实类似二维数组的理解，一维数组的每个元素都是一维以上的数组，如每个元素都是二维数组就是三维数组，就这么套娃套下去，只要内存顶得住，想多少维就多少维。举个三维的例子，直接赋值吧，控制台输入就是三层 for 嵌套了，遍历也是三层 for 嵌套，几维就需要几个嵌套。 1int arr[][][] = {{{1,2},{3,4}},{{5,6},{7,8}}}; //多维的声明就是加 [] 这是一个2X2X2的立体数据块，这么理解就可以了，到了四维数组，脑子是理解不动了，反正将索引 [] 使用数学的排列组合就可以定位到所有元素了。 说到底无论几维数组，都是一维数组，一直嵌套而已，因为内存存储并没有那么多维度，只分栈和堆。由一维的地址指向值，变成地址指向地址，最后在指向堆内的值。 掌握一维和二维数组用法足够对付大部分问题了。 三、数组常用方法Arrays 类为数组的处理提供了众多方法，例如排序 sort，比较 equals等，里面重载的方法众多，挑出代表，重点在于知道这些方法的使用方式，而不是掌握所有方法： 方法 说明 asList(T… a) 返回一个受指定数组支持的固定大小的列表。 binarySearch(byte[] a, byte key) 使用二分搜索法来搜索指定的 byte 型数组，以获得指定的值。 copyOf(boolean[] original, int newLength) 复制指定的数组，截取或用 false 填充（如有必要），以使副本具有指定的长度。 copyOfRange(boolean[] original, int from, int to) 将指定数组的指定范围复制到一个新数组。 deepEquals(Object[] a1, Object[] a2) 如果两个指定数组彼此是深层相等 的，则返回 true。 deepHashCode(Object[] a) 基于指定数组的“深层内容”返回哈希码。 deepToString(Object[] a) 返回指定数组“深层内容”的字符串表示形式。 equals(boolean[] a, boolean[] a2) 如果两个指定的 boolean 型数组彼此相等，则返回 true。 fill(boolean[] a, boolean val) 将指定的 boolean 值分配给指定 boolean 型数组的每个元素。 hashCode(boolean[] a) 基于指定数组的内容返回哈希码。 sort(byte[] a) 对指定的 byte 型数组按数字升序进行排序。 toString(boolean[] a) 返回指定数组内容的字符串表示形式。 这是从jdk1.6文档中获得的数据，在网上看博客时得到 jdk8 中 Arrays 得到加强，添加了许多新方法，这就需要下载jdk8 文档，我从其他博客里转载过来一段。 由于计算机硬件的飞速发展，目前几乎所有家用 PC 都是 4 核、8 核的 CPU，而服务器的 CPU 则具有更好的性能，因此 Java 8 与时俱进地增加了并发支持，并发支持可以充分利用硬件设备来提高程序的运行性能。 oid parallelPrefix(xxx[] array, XxxBinaryOperator op)该方法使用 op 参数指定的计算公式计算得到的结果作为新的元素。op 计算公式包括 left、right 两个形参，其中 left 代表数组中前一个索引处的元素，right 代表数组中当前索引处的元素，当计算第一个新数组元素时，left 的值默认为 1。 void parallelPrefix(xxx[] array, int fromIndex, int toIndex, XxxBinaryOperator op)该方法与上一个方法相似，区别是该方法仅重新计算 fromIndex 到 toIndex 索引的元素。 void setAll(xxx[] array, IntToXxxFunction generator)该方法使用指定的生成器（generator）为所有数组元素设置值，该生成器控制数组元素的值的生成算法。 void parallelSetAll(xxx[] array, IntToXxxFunction generator)该方法的功能与上一个方法相同，只是该方法增加了并行能力，可以利用多 CPU 并行来提高性能。 void parallelSort(xxx[] a)该方法的功能与 Arrays 类以前就有的 sort() 方法相似，只是该方法增加了并行能力，可以利用多 CPU 并行来提高性能。 void parallelSort(xxx[] a，int fromIndex, int toIndex)该方法与上一个方法相似，区別是该方法仅对 fromIndex 到 toIndex 索引的元素进行排序。 Spliterator.OfXxx spliterator(xxx[] array)将该数组的所有元素转换成对应的 Spliterator 对象。 Spliterator.OfXxx spliterator(xxx[] array, int startInclusive, int endExclusive)该方法与上一个方法相似，区别是该方法仅转换 startInclusive 到 endExclusive 索引的元素。 XxxStream stream(xxx[] array)该方法将数组转换为 Stream，Stream 是 Java 8 新增的流式编程的 API。 XxxStream stream(xxx[] array, int startInclusive, int endExclusive)该方法与上一个方法相似，区别是该方法仅将 fromIndex 到 toIndex 索引的元索转换为 Stream。 上面方法列表中，所有以 parallel 开头的方法都表示该方法可利用 CPU 并行的能力来提高性能。上面方法中的 xxx 代表不同的数据类型，比如处理 int[] 型数组时应将 xxx 换成 int，处理 long[] 型数组时应将 XXX 换成 long。 小尾巴虽然写了这么多方法，如果不用还是没用，脑袋记和容易网，能做到多翻文档就行了。","link":"/2020/02/16/javabase18-array2/"},{"title":"JAVA零基础筑基到修仙（二十）——冒泡排序","text":"本篇学习数组三种排序方法中的冒泡排序，名字很形象了，冒泡，像汽水里的泡泡一个一个冒到液面。冒泡排序的思想是从第一个元素开始，和相邻的元素比较，如果大于后面元素就交换位置，最终完成排序。 一、思路了解了思想如何体现到程序上呢，很抽象，那就需要举个排序例子来研究一下。我们直接考虑最麻烦的情况，元素是从大到小排列，每个元素都要冒泡冒上去。 如一个整数数组 arr[] 中元素为 ：4，3，2，1 。 对数组进行排序： 根据排序思想，首先 4 和 3 比较 4 &gt; 3 ,顺序变为 3，4，2，1，然后再比较 4 和 2，最终第一次比完结果为 3，2，1，4；一共比对了 3 次，分别是 arr[0]:arr[1],arr[1]:arr[2],arr[2]:arr[3]。 然后对 3，2，1，4再进行比较排序…. 第二次比对完结果为：2，1，3，4；此时发现，第一次比对完成后，最后一位元素 4 前面肯定没有了比 4 大的数，已经确定了 4 为最大值，所以剩下的元素比较不用和 4 比，只需要比 2 次即可,分别是 arr[0]:arr[1],arr[1]:arr[2]。本次结果确定了 3 是第二大。 最后对 2，1，3，4进行比较….第三次比对完结果为：1，2，3，4；同理当比对完第二次后，确定了 4 为最大值，3 为第二大值， 剩下的数据不需要再和 3，4 比较，只比较 1 次就可以了，arr[0]:arr[1]，最终完成了排序。 由此可以得出结论：4 个元素的数组在最麻烦的情况下，整个数组元素从第一个到最后一个需要比对 3 次，每次数组内部相邻元素分别需要比对 3、2、1次。 推广到 n 个元素的数组：n 个元素的数组在最麻烦的情况下，需要循环对比 n-1 次，每次数组内相邻的元素分别需要对比 n-1、n-2….2、1次。 考虑了排序最麻烦的情况，如果程序可以正确处理最麻烦的情况，那像原数组元素排序为 3，2，4，1 这种也不在话下，因为它被包含于最复杂的情况中。 接下来就可以思考程序内部怎么写了。 如何让两个元素值对换，如 i=1，j=2，变为 i=2，j=1？ 当直接 i=j 时 j 就无法通过 j=i 获得 真实i 的值，所以 需要一个中间变量先将 i 的值存起来。就是这样： sum = i; i=j; j=sum; 三步走完成数值交换。 二、构建程序从上面的思考中可以看出： 程序必须有两个循环，外部循环控制总比对次数，内部循环根据索引控制哪两个元素进行比对。 然后是两个相邻元素的交换需要交换的两个元素需要借助一个额外的变量来做中间量。 那么程序就出来了： Demo： 1234567891011121314151617181920212223public static void main(String[] args) { // TODO Auto-generated method stub int[] arr = { 22, 33, 44, 11, 32, 56, 13, 66 }; int sum; for (int i = 0; i &lt; arr.length - 1; i++) { //控制总循环次数 for (int j = 0; j &lt; arr.length - 1 - i; j++) { //控制索引进行比对,不理解的话仔细观察思路 1.2.3. if (arr[j] &gt; arr[j + 1]) { sum = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = sum; } } //输出每次排序的结果 System.out.println(\"第\"+(i+1)+\"次排序，排序结果：\"); for (int a : arr) System.out.print(a + \" \"); System.out.println(); } //输出最终排序结果 System.out.println(\"排序结果：\"); for (int i : arr) System.out.print(i + \" \");} 运行结果：; 程序可以还改一改，从控制台输入元素的值，然后排序，这里不再举例。 冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 小尾巴冒泡排序是三个排序中最容易理解的排序，仔细体会，下一篇写快速排序，快速排序很少写，没印象，我还要学一学。","link":"/2020/02/17/javabase20-px/"},{"title":"JAVA零基础筑基到修仙（二）——Hello world!","text":"上一篇博客介绍了Java基本知识，接下来以在Windows上开发为例（不同的系统环境只是配置环境变量的方法不一样），正式开始Java的学习。本篇内容包含：Java开发环境配置，年轻人的第一个Java程序和Java集成开发环境（IDE）的使用。 一、安装Java开发和运行环境想要运行Java程序，系统需要具备Java运行环境，也就是Java Runtime Environment,简称JRE。但是如果要开发Java程序，需要的是Java Development Kit,Java程序开发工具包，也就是常说的JDK。一般只有服务器才会安装单独的JRE环境，开发人员需要两个都有，只需要去甲骨文官网下载JDK就可以，安装文件中包含了JDK和JRE。 百度直接搜索“jdk”，找到甲骨文官网jdk下载页，我习惯使用jdk8,以jdk8的安装为例（jdk并不是越新越好，现在还有相当多的企业项目用的是jdk6,新的jdk含有新的Java规范，不同的jdk环境编译出的class文件不一样，如果开发人员jdk需要升级，服务器上的jre也要跟着升级，否则旧的环境无法运行新的规范，造成宕机，如果是重要应用，就是生产事故了。所以很多企业级应用开发人员出于稳定考虑，在当前环境满处生产需要时，不会去冒然去升级jdk版本）： 然后找到版本信息，我是Win10 64位系统选择x64版本，32位系统选择i586版本（虽然64位系统可以安装32位版本，但是为了防止出现各种莫名其妙的错误，最好版本对应） 下载时可能会让你登录，否则下载不开始，用邮箱注册个账号就行了（现在网络快多了，前几年下载那叫一个慢）。下载好了，开始安装（我安装的是8u181版本，小版本不一样安装没有差别）： 一直点下一步就可以了（当然推荐你改一下安装位置，只要知道装在哪里就行了，后面配置环境要用） 如果安装完找不到了咋办，卸载重新装，很快的这次记好了。 安装完成打开Windows控制台，win+r调出运行输入cmd回车（也可以使用Win10快速检索win+q,输入cmd，需要管理员权限的控制台时这个方式更好用）输入java -version 说明安装成功了，接下来配置环境变量，右击此电脑选择属性，选择高级系统设置，点击环境变量，在下面系统变量里新建”JAVA_HOME”和”CLASSPATH”两个变量，JAVA_HOME中的值为刚才安装Java选定的位置， 我的位置是”C:\\Program Files\\Java\\jdk1.8.0_181”,复制进去保存。在CLASSPATH中输入”.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;”（复制时别复制引号，注意开头分号前面有”.”） 然后找到”Path”，点击编辑添加依次输入”%JAVA_HOME%\\bin”和”%JAVA_HOME%\\jre\\bin”保存（不同系统可能页面显示的不一样不是这种的话需要用分号隔开，这样”%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;”） 修改成功后保存完成关闭面板，打开新的控制台输入”javac”回车，如果成功出现下图内容，则说明环境配置成功，接下来就可以进行开发学习了，如果不成功，请仔细检查环境变量配置步骤中的内容是否正确。 二、Hello world!终于可以开始敲代码了，接下来有请年轻人的第一个Java程序”Hello world!”闪亮登场（传统艺能，传统艺能……）！在本地磁盘D新建”Demo”文件夹,打开文件夹新建Hello.txt记事本文件（”.txt”是文件扩展名，如果新建记事本不显示扩展名，请百度”如何显示文件扩展名”，比较简单，这里没有截图），在记事本中输入如下代码： Hello.java12345public class Hello{ public static void main(String[] args){ System.out.println(\"Hello world!\"); }} 保存记事本然后修改扩展名为”.java”，提示可能无法使用点确定（文件名字可以不叫”Hello”,但是一定要与代码中”public class”后面的名字一模一样，注意区分大小写,代码中符号都是英文符号）。 然后打开控制台进入Demo,我的在D盘，打开cmd后直接输入”d:”回车，然后”cd demo”进入demo文件夹（Windows里文件名是不区分大小写的）。输入”javac Hello.java”回车，如果代码没有错误就什么都不显示，否则会报出异常。如下图： 然后我们通过”java”命令运行文件（注意不用带文件扩展名）： 如图，我们成功打印出了设定内容”Hello world!”,第一个Java程序完成（呱唧呱唧~）。那么我们来稍微了解一下代码是怎么回事吧： 有间隔的每个字段意义都不同，我来一一说明： 关键字class用来定义一个类，Hello是类的名称； 在Java程序中，所有的语句都必须放在某个类中； 整个类及其所有成员都包含在一对花括号中（即{和}之间），它们标志着类定义块的开始和结束。 定义类的一般语法：Hello.java123class 类名{ ……} 程序必须从main函数开始执行； 关键字public是访问修饰符，用来控制类成员的可见范围及作用域； 关键字static允许在不创建类的实例的情况下，调用main函数； 关键字void用来说明main函数是没有返回值的； args是字符串数组，用来从命令行接收参数； main函数的一般形式如下：Hello.java123public static void main(String[] args){ …… } String[]是字符串类型的数组； 在Java中，类名称一般首字母大写； 使用System.out.println()将信息输出到控制台上，即打印出来。解析完代码，你是否对Java代码规范有了一知半解了呢，试着修改代码按照刚才的步骤在控制台打出更多内容吧。这次使用上注释，注释不会被编译，有两种形式一种为“// ……”,可以注释掉同行的代码，一种是代码段注释“/……/”，注释掉一段代码（注意使用英文，当前开发环境简陋，使用中文可能导致编码异常）：Hello.java12345678910111213141516/*** This class mean to print \"Hello world!\"*/public class Hello{ public static void main(String[] args){ // print Hello world! System.out.println(\"Hello world!\"); System.out.println(\"I am Zhangsan\"); /*System .out .println(\"I am a girl\");*/ //System.out.println(\"I am a boy\"); System.out.println(\"I am a boy\"); System.out.println(\"I am 10 years old \"); }} 编译运行！通过”javadoc”命令可以将注释内容提取，生成一个文件方便查阅，来试试看：生成了一堆文件打开index.html到此为止，对Java初体验结束，初学者是不是感觉收货满满，这是是Java的冰山一角，她的众多优秀特性到后面再慢慢了解。 三、集成开发环境（IDE）Java开发人员常用的开发软件有三个，分别是Eclipse、Myeclipse、Idea（剩下的都是些小众的，我也不了解）我说一说我对这三个软件的理解： EclipseEclipse轻量，简洁，操作简便，对电脑配置要求较低，并且开源免费，更适合Java初学者。缺点是简洁到几乎没有插件，后面很多开发必须插件都需要自己安装，好在eclipse提供插件支持，可以在软件里一键安装。 Myeclipse它是Eclipse的定制版本，对电脑配置要求较高，而且收费，集众多生产插件于一身，免除了自己装插件的烦恼，相比eclipse功能更完善（毕竟花了钱的）。 IDEA相对于先前两个，IDEA是重量级的集成开发工具，对电脑配置要求高，支持多种语言开发，拥有丰富的开源插件生态，功能相当完善，是众多开发者的首选工具，大佬必备（意义简单粗暴），这么优秀的工具肯定是需要掏钱的，官方推出了完整版和社区版（阉割版），社区版是免费的。但是在国内网络现在的大环境下，搜索破解方法还是相当简单的（这么喜欢你你竟然要收我们钱？哈哈哈……），不过在国人版权意识逐渐苏醒的今天，我呼吁有能力的开发者尽量使用正版软件（哎吆我插会儿腰……嘿嘿嘿）。开发工具介绍完毕，做为Java初学者建议使用eclipse，虽然一步到位使用IDEA更好，但是IDEA相对来说对电脑配置要求高，如果配置跟不上会卡顿，严重影响开发体验，撇去性能不谈，IDEA自动保存，但是没有自动编译，需要手动编译（虽然可以自己设置自动编译，但我劝你别），eclipse点击保存的时候自动编译。所以等以后碰到语言多了，比如学习Spring boot或者开发项目需要同时操作好几门语言，这时候一个IDEA就可以完全搞定了。好了开发工具搞定，顺便在eclipse上撸个”Hello world!”吧。 四、在eclipse上运行Hello world安装eclipse需要验证环境变量，如果环境变量没安装好，eclipse无法正常安装，下载地址。安装过程（这种是边下载边安装的形式，耐心等待安装完成，也可以点击下载页下载按钮地下的 Download Packages 整包下载）：安装完成首次打开会让你选择工作空间，也就是你的项目要放的目录,默认或自己设都行。进入界面点击工具栏File&gt;new&gt;java project(如果没有选择project然后搜索java project)&gt;填写项目信息&gt;完成，如图：若遇到弹窗提示点Ok就可以了。点开工程&gt;右击src&gt;new&gt;class&gt;填写类信息&gt;finish打开Demo类在光标处敲入System.out.println(“Hello world!”); 保存，代码正确会自动编译，代码错误会有提示，没有错误点运行。运行成功 以上是这篇博客的全部内容，从环境变量配置到集成环境运行代码都很顺利，初学者如果哪里有不懂，欢迎邮件交流，感谢您的阅读。 小尾巴写博客是真的累，坐了一下午，不过程序员就要坐的住，哈哈，前期工作都已完成，接下来开始学习Java正经内容，待续……","link":"/2020/02/05/javabase2-helloworld/"},{"title":"JAVA零基础筑基到修仙（二十一）——快速排序","text":"快速排序由C. A. R. Hoare在1960年提出。快速它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 一、快速排序思路快速排序相对于冒泡排序的逻辑复杂了很多，带来的好处就是快速排序在几种算法中排序效率较高，无论是面试还是软考很容易碰到，它采用分治法，思想简单概括为： 于数组中选出一个基数（就是排序时以他为准）。 分区，比基数大的放右边，小的放左边。 对两边分别再进行 1.2. 步，最终排序完成。 从 3. 可以看出算法中肯定需要用到递归，不然无法完成左右再重新分的需求，新手还不懂递归是什么的点击递归。 从其他博客中看来看去，最终找到了一种很好的理解方式（虽然我也懂得这个算法了，以我三脚猫的功夫怕是说不清啊，我会对博客内容进行整理）： （以下内容转载自：脚丫先生：https://blog.csdn.net/shujuelin/article/details/82423852 ） 假设现在对“6 1 2 7 9 3 4 5 10 8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列： 3 1 2 5 4 6 9 7 10 8 在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。想一想，你有办法可以做到这点吗？ 方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。(直接看图理解就好，文字配图，效果更佳) 首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。 现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下： 6 1 2 5 9 3 4 7 10 8 到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下： 6 1 2 5 4 3 9 7 10 8 第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。将基准数6和3进行交换。交换之后的序列如下： 3 1 2 5 4 6 9 7 10 8 两个哨兵碰头，对应数组内两端取到同一个索引：对应索引与基准数交换：交换： 交换完成后结束了相当重要的工作，剩下工作就是对左右两边数组再次进行相同操作，这部分操作对应代码中递归调用的阶段。 到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。 OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。 左边的序列是“3 1 2 5 4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧 如果你模拟的没有错，调整完毕之后的序列的顺序应该是： 2 1 3 5 4 OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下： 1 2 3 4 5 6 9 7 10 8 对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下 1 2 3 4 5 6 7 8 9 10 到此，排序完全结束。 细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。 快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。 二、构建程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Test_qsort { /** * 主程序入口 * @param args */ public static void main(String[] args) { int[] arr = { 6, 1, 2, 7, 9, 3, 4, 5, 10, 8 }; // 输入起始参数，数组arr， 基准数索引为0，最右侧索引为 length-1 quickSort(arr, 0, arr.length - 1); // 输出最终结果 for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i]+\" \"); } } /** * 快速排序算法 * @param arr * @param low * @param high */ public static void quickSort(int[] arr, int low, int high) { // 如果不知道要会用到多少变量，可以先往下写，用到了再补到上面，i j 分别代表左右索引 int i, j, temp, t; // 如果不满足下面条件说明排序已经完成了 if (low &gt; high) { return; } // 声明基准数 temp = arr[low]; // 因为后面要和基准数做交换，所以需要声明新变量 i = low; j = high; // 根据基准数，左右开始找合适的值 while (i &lt; j) { // 先从右边开始找小于基准数的元素 自己想想为什么？ while (temp &lt;= arr[j] &amp;&amp; i &lt; j) { j--; } // 然后左边开始找大于基准数的元素 while (temp &gt;= arr[i] &amp;&amp; i &lt; j) { i++; } // 右边找到小于基准数的元素，左边找到大于基准数的元素，在两边索引还不一致的情况下，交换位置 if (i &lt; j) { t = arr[i]; arr[i] = arr[j]; arr[j] = t; } } // 完成了两边交换，此时左右定位到同一个索引上，新型基准数与当前索引元素的交换。 arr[low] = arr[i]; arr[i] = temp; // 左右分别开始以上步骤 // 右边数组 虽然此时 i = j 但是在递归调用时 i 会变为 0，所以只能用 j-1 来代表定位同一索引的值 quickSort(arr, low, j - 1); // 左边数组 quickSort(arr, j + 1, high); }} 快速排序结果: 快速排序不知有一种写法，但是中心思想不变，等熟练了可以试试换种写法。 三、为什么要先从右边开始找？以习惯的基准数在左边第一个，排序为升序为例： 无论是手写示例还是代码调试都可以很容易找到答案 以 b 代表基准数，s 代表与基准数互换的数， sL 代表s左边的数, sR 代表s右边的数 图解： 在基准数与 i = j 所在索引的数对换前： 在对调前还不会出现问题，问题出在对调的数变了，因为在完成 b 与 s 调换后，要达到 b 的左边都小于 b ，右边都大于 b ，那么在调换前这几个数的关系是 sR&gt;b&gt;sL?s,那么开始调换，如果从左边先，索引 i+1 后到达 s，s &lt; b,明显 i 不能停留在 s 的位置，继续 +1 找到大于 b 的数 sR ，然后 j 从右边开始 正好此时 j=i ，本来应该 s 与 b 交换，现在变成了 sR 与 b 交换，sR 是这几个数里最大的，跑到左边肯定就不对了，从这一步开始，后面排序都乱了，从右边先开始就没有这个问题了。 至于如何从先左边开始才能正确，我觉得要把 左小右大 的规则反过来，这样代码里的逻辑就要完全改变了。 小尾巴更新博客睡觉。","link":"/2020/02/17/javabase21-kspx/"},{"title":"JAVA零基础筑基到修仙（二十二）——选择排序","text":"本篇内容包括：选择排序，三种排序方法总结 一、选择排序选择排序思路选择排序思路比较简单，从第一次开始，每次都找到数组中最小的值，互换掉索引最小的那个，举例说明：如数组 int arr[] = {6,5,4,3,2,1} ,从第一个元素开始不断寻找最小值来互换： 第一步，找到最小值为 1 ，互换 6 结果为 1 5 4 3 2 6； 第二步，从剩下的 5 4 3 2 6 中找到最小值 2 ，互换 5 结果为 1 2 4 3 5 6； 第三步，从剩下的 4 3 5 6 中找到最小值 3 ，互换 4 结果为 1 2 3 4 5 6 ，排序完成了？ 其实排序并没有完成，第三步完成后未排序元素为 4，5，6 ，只不过每次寻找最小都是自身了，但是程序依旧要执行后面的两步： 第四步，从 4 5 6 找出 4， 第五步，从 5 6 中 找出 5， 当只剩下 6 一个元素时 就没必要在运行下去了，因为没有下一个元素个可以比较了。最终排序结果 1 2 3 4 5 6。 分析例子： 6 个元素的数组需要找 5 次最小，每一次找到最小要和未被互换过的第一个元素互换，那么程序就理顺了： 确定循环互换次数， 找最小值 互换直到当前元素下标与数组长度-1相等。 构建程序通过上面的分析可以确定，程序需要两层循环，外层循环控制互换次数，并执行互换操作，内层循环寻找最小值。 Demo： 12345678910111213141516171819public static void main(String[] args) { // TODO Auto-generated method stub int arr[] = { 5, 2, 3, 6, 1 }; for (int i = 0; i &lt; arr.length - 1; i++) {//外层确定次数 int min = arr[i];//最小值 int index = i;//最小值索引 for (int j = i + 1; j &lt; arr.length; j++) {//找到最小值 if (min &gt; arr[j]) { min = arr[j]; index = j; } } arr[index] = arr[i];//最小值与当前元素交换 arr[i] = min; } //输出排序完成结果 for (int i : arr) System.out.print(i + \" \");} 运行结果：别的没什么好说的，接下来谈谈冒泡、快速、选择排序的特点做个总结。 二、总结三种排序方法三种方法的时间空间复杂度稳定性比较： 总结就是： 冒泡稳定，速度一般； 快速快，不稳定； 选择速度一般且不稳定，元素越多效率越低。 排序算法有七八种呢，这三种较为常见，别的有时间再去了解。 小尾巴接下来学 java 类和对象，java 语言的立足之本。","link":"/2020/02/18/javabase22-xzpx/"},{"title":"JAVA零基础筑基到修仙（二十三）——对象概念、面向对象的三个特征","text":"对 Java 语言来说，一切皆是对象。把现实世界中的对象抽象地体现在编程世界中，一个对象代表了某个具体的操作。一个个对象最终组成了完整的程序设计，这些对象可以是独立存在的，也可以是从别的对象继承过来的。对象之间通过相互作用传递信息，实现程序开发。 一、对象的概念“java是面向对象的语言”这种描述是老生常谈，概念知识没必要长篇大论，个人感觉一个合适的比喻比得过一大段详细的描述。那如何理解“对象”呢？ 对象就是现实世界中的一个实体，比如说人类，每个人都是一个对象，用java程序语言来描述一个人的各种信息与动作，此时称java是面向对象的程序语言。 每个对象都有自身的特点，以人为例： 每个人都有性别，名字等（对象的属性），每个正常人都可以吃饭、睡觉（对象的行为）； 人可以变胖或者变瘦（对象状态变化）； 每个人都是唯一的，没有完全相同的两个人（对象唯一性）； 物以类聚，人是生物的一个种类，我只是人类中的一员（对象是类别的实例）； 自然界除了人，还有花鸟虫鱼野兽等其他类生物，每一个具体的生物都是一个对象（一切皆为对象）。 二、面向对象的三个特征面向对象有散个基本特征：封装、继承、多态。首先搞清楚，为什么要面向对象。以人为例： 有一个人善于弹钢琴，在自己家可以弹，也可以被委派到音乐会去弹，他老婆是老师，每天都要去学校上课（面向对象代码可重复使用，不同种功能分开开发，提高开发效率） 这个人音乐天赋了得，有个乐团缺个打鼓手，他自学打鼓加入了乐团（面向对象可扩展性） 乐团按照乐器种类发工资，乐团里每个人都拿到了不同种乐器相应的钱（面向对象易于管理数据与功能的关系） 以 java 来说，她多次蝉联世界编程语言使用人数第一的宝座，此殊荣说明了 java 的强大，但是成就了 java 如此强大的是她的三个核心特征：封装、继承、多态。 封装封装是将对象属性与方法结合起来，外部无法干扰到对象内部的属性信息与方法，保护了该对象不被破坏。有以下优点： 保护对象，外部在没有权限的情况下无法随意访问对象内部 隐藏细节信息，如外人只知道我善于弹钢琴，但是他不知道我是如何弹的那么好的。 有利于建立对象间的耦合关系，还是乐团的例子，我会弹钢琴，别人会其他乐器，一起组了个乐团，合作一起做音乐。 提高软件复用率，有个乐团出高新招聘钢琴师，我不满意现在的工资跳槽了过去，我并不是只能在这个乐团弹。 java 中封装的对象称为为类，有权限修饰符 private protect public 来限定外部访问的权限大小，后面再说。 继承继承很容易理解，就以人来说，正常情况下，一个人可以走路，他的儿子应该也会走路，不但会走路，还会开车。放在程序中，就是子类继承了父类的所有属性和方法，并且可以具有父类没有的属性与方法。在java中每个类只可以继承一个父类（单继承机制） 举个具体程序的例子： 有一个 Person 类:类中属性有：姓名，性别，年龄。类中的方法有：吃饭，睡觉。 我可以使用这个 Person 类完成一个具体的操作“康康是个男生，今年10岁，他正在吃饭，一会要去睡觉。” 现在我需要一个 Student 类来完成学生的具体操作“小红是个女生，今年9岁，她吃完饭，要去睡觉，睡醒要学习，然后再吃饭睡觉。” 显然 Person 中没有学习的功能，而且 student 类依然需要 person 类中的属性和方法。 此时只需要创建一个 student 类继承 person 类，然后在 student 类中新增 学习的方法就可以了。 多态多态通过类继承重写方法，和接口的多实现重写抽象方法来实现，具体如何实现到后面会详细说明，简单的举两个例子： 类的多态： Animal类中有 run() 方法，Dog 类和 Cat 类都继承了 Animal 类，然后重写了 run() 方法，分别有了不同的动作方式，这就是类的多态。 接口的多态： 有一个 teacher 类 ，类中有一个 teach 的抽象方法（接口中的方法都是抽象的，抽象的意思是只有方法名没有方法体，方法如何执行写在实现接口的类中） 然后有 englishteacher 类 和 mathteacher 类分别实现了 teacher 接口 englishteacher 类中的 teach 方法具体表现为 teach english mathteacher 类中 teach 方法具体表现为 tech math。 那么多态有什么什么好处呢，就上面的例子，写接口的人只需考虑老师要做哪些工作，不用考虑具体做什么，英语老师只需要关心教英语，数学老师只需要关心教数学。 今天的内容只是简单介绍，这些内容，会在后面的学习中有更多的体会。__ 小尾巴最近掉头发掉的厉害，睡了睡了。","link":"/2020/02/18/javabase23-oop1/"},{"title":"JAVA零基础筑基到修仙（二十四）——类的概念、定义、类属性、类方法（含可变参数）","text":"在面向对象中，类和对象是最基本、最重要的组成单元。类实际上是表示一个客观世界某类群体的一些基本特征抽象。对象就是表示一个个具体的东西。所以说类是对象的抽象，对象是类的具体。 一、类的概念类（Class） 就是类别，在上一篇说封装时我们提到类是对象的封装，对象是自然界客观存在的个体，而类是一个概念，并不是可以看得见摸得着的。无论是进口法拉利、兰博基尼、还是国产长城、吉利都属于汽车，汽车是对这些对象的描述，都有外壳、车轮、底盘、方向盘、发动机等，都可以向前跑，向后倒车，鸣喇叭、刹车。类与对象的关系就是 汽车 与这些具体实物的关系，由此可见。 类是概念模型，定义对象的所有特性和所需的操作，对象是真实的模型，是一个具体的实体。 类是描述了一组有相同特性（属性）和相同行为（方法）的一组对象的集合。 我们买车的时候会去了解，动发动机怎么样，座椅舒不舒服，悬挂系统稳不稳，轮胎大小等具体信息，这些事对象的属性。还要去试驾开起来如何，体现了对象中的方法。不同的车属性和驾驶体验各有不同。 对象或实体所拥有的特征在类中表示时称为类的属性。 对象执行的操作称为类的方法。 类是构造面向对象程序的基本单位，是抽取了同类对象的共同属性和方法所形成的对象或实体的“模板”。而对象是现实世界中实体的描述，对象要创建才存在，有了对象才能对对象进行操作。类是对象的模板，对象是类的实例。 举一些类的例子： 二、类的定义Java中所有程序都基于类，类是引用类型。定义类的语法： 123456789101112[public][abstract|final]class&lt;class_name&gt;[extends&lt;class_name&gt;][implements&lt;interface_name&gt;] { // 定义属性部分 &lt;property_type&gt;&lt;property1&gt;; &lt;property_type&gt;&lt;property2&gt;; &lt;property_type&gt;&lt;property3&gt;; … // 定义方法部分 function1(); function2(); function3(); …} 上述语法中各关键字的描述如下。 public：表示“共有”的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，作为公共工具供其他类和程序使用的类应定义为 public 类。 abstract：如果类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用 abstract 修饰的方法）和具体方法（没有使用 abstract 修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）。 final：如果类被 final 修饰，则不允许被继承。 class：声明类的关键字。 class_name：类的名称。 extends：表示继承其他类。 implements：表示实现某些接口。 property_type：表示成员变量的类型。 property：表示成员变量名称。 function()：表示成员方法名称。 Java 类名的命名规则： 类名应该以下划线（_）或字母开头，最好以字母开头。 第一个字母最好大写，如果类名由多个单词组成，则每个单词的首字母最好都大写。 类名不能为 Java 中的关键字，例如 boolean、this、int 等。 类名不能包含任何嵌入的空格或点号以及除了下划线（_）和美元符号（$）字符之外的特殊字符。 例如定义一个汽车类： 12345678910public class Car { String brand; // 品牌 double length;// 长度 double width; // 宽度 double weight;// 重量 void run() { System.out.println(\"Runing\"); }} 定义的汽车类的属性为：品牌、长度、宽度、重量；方法为 run()。 class 前的 public 代表公用的，外部可以随意访问该类，属性中的 private 代表私有，只有本类内部可以访问，方法前的 public 表示该方法可以在任意类中使用。 三、类的属性和方法1. 属性语法： 1[public|protected|private][static][final]&lt;type&gt;&lt;variable_name&gt; 各参数的含义如下。 public、protected、private：用于表示成员变量的访问权限。 static：表示该成员变量为类变量，也称为静态变量。 final：表示将该成员变量声明为常量，其值无法更改。 type：表示变量的类型。 variable_name：表示变量名称。 为 Car 类中的属性加上修饰符： 12345678910public class Car{ public static final String brand = \"Des Auto\"; //品牌 private double length;//长度 private double width; //宽度 private double weight;//重量 void run(){ System.out.println(\"Runing\"); }} 加完修饰符后，品牌 brand 属性变成了一个公有静态的常量，值为“ Des Auto ”，让这个汽车类变成类大众汽车的类，final 声明后品牌信息无法修改。 其他属性变成类私有属性，只能在类内部访问。 属性不赋值的话有默认值： 整数型（byte、short、int 和 long）的基本类型变量的默认值为 0。 单精度浮点型（float）的基本类型变量的默认值为 0.0f。 双精度浮点型（double）的基本类型变量的默认值为 0.0d。 字符型（char）的基本类型变量的默认值为 “\\u0000”。 布尔型的基本类型变量的默认值为 false。 数组引用类型的变量的默认值为 null。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。 一般属性名的命名方式与变量一样，采用驼峰式，比如 身份证号 用 personId ，电话号码 用 telNumber， 组合词的话头字母小写，后面单词头字母大写，单个字母的属性名小写就可以了。另外还有中间加下划线的命名方式，如 person_id ，驼峰式命名用的比较广泛，但是具体还是要看项目开发规范的要求，有可能写规范的喜欢用下划线呢。 2. 方法方法表示这个类可以完成哪些动作，比如上面 Car 类里有 run() 方法，语法为： 123[public|private|protected][static]&lt;void|return_type&gt;&lt;method_name&gt;([paramList]) { // 方法体} public | private | protected 只能选择一个，代表了不同的访问权限。 上述代码中一个方法包含 4 部分：方法的返回值、方法名称、方法的参数和方法体。其中 retum_type 是方法返回值的数据类型，数据类型可以是原始的数据类型，即常用的 8 种数据类型，也可以是一个引用数据类型，如一个类、接口和数组等。 除了这些，一个方法还可以没有返回值，即返回类型为 void，像 main() 方法。method_name 表示自定义的方法名称，方法的名称首先要遵循标识符的命名约定，除此之外，方法的名称第一个单词的第一个字母是小写，第二单词的第一个字母是大写，依此类推。 paramList 表示参数列表，这些变量都要有自己的数据类型，可以是原始数据类型，也可以是复杂数据类型，一个方法主要依靠参数来传递消息。方法主体是方法中执行功能操作的语句。其他各修饰符的含义如下。 public、private、protected：表示成员方法的访问权限。 static：表示限定该成员方法为静态方法。 final：表示限定该成员方法不能被重写或重载。 abstract：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类 这里涉及到的重载，重写，抽象方法后面再做了解。 我们约定采用驼峰式命名，比如 carRun() 汽车跑的方法： 为上面的 Car 类重新写个方法 carRun： 12345678910111213141516171819202122232425public class Car { public static final String brand = \"Des Auto\"; // 品牌 private double length;// 长度 private double width; // 宽度 private double weight;// 重量 /** * 私有方法 只能在类内部调用 */ private static void run() { System.out.println(\"Runing\"); } /** * 公有且静态方法，可以在其他类不创建对象的情况下调用 */ public static final String carRun(double speed) throws InterruptedException {// 共有的 静态的 无法被重写的 带有参数的 并且带有异常处理的方法 System.out.println(\"The car is start up!\");//启动引擎 Thread.sleep(1000);//等待一秒，线程先不用了解 InterruptedException 异常处理就是因为它 模拟汽车运行 run();//调用了类中的run方法 System.out.println(\"The car is running with speed: \" + speed + \"km/s\");//使用了参数 speed Thread.sleep(1000); return \"car turn off\"; //返回了 car 的运行状态 执行完毕后 car 熄火了 }} 观察上方 run 方法 与 carRun 在修饰上的不同，编写个测试类来演示一下： 当想调用 Car的属性或者方法时发现只有 public 修饰的属性和方法可以访问 那如何设置和获得 Car 类 中的私有属性呢？ 需要在 Car内部设置公有的 设置和读取属性的方法（setter 和 getter）。 现在大多数 IDE 都提供快速生成 setter 和 getter 方法的按钮，以及构造方法。 进入 Car 类 在其他方法下方右击→Source→Generate getter and setter 保存 然后再返回测试类。 发现可以为 Car 的属性设置值了 看一下 通常凡是类中有属性的都会是这种形式，属性私有，然后创建公有的setter和getter方法。 经过一段小插曲，继续方法 carRun 的测试 1234567public static void main(String[] args) throws InterruptedException { // TODO Auto-generated method stub //由于是静态方法，不需要new Car对象 String status = Car.carRun(120.0); //速度参数为double型 120.0，然后使用String 新建String变量 status 接收 carRun 方法返回值。 System.out.println(status); //System.out.println(Car.carRun(120.0)); //不新建变量直接这样也行} 运行结果： 仔细对比 run 方法与 carRun 方法 体会不同修饰符的意义，体会有返回值方法 return 的用法。 方法中参数的用法方法中的参数可以有很多个且类型可以不同，用“ ,” 隔开。例： 123public void printf(int i, String str, Car car, double d){// 方法内部的参数叫 形式参数 形参……} 在调用方法时参数的顺序，数量，类型要严格一致，一一对应。 123456int sum = 10;String s = \"kk\";Car car1 = new Car;double speed = 120.0;printf(sum,s,car1,d);// 调用方法时 给的参数叫 实际参数 实参 还要提醒一点：在方法内部注意变量的作用域 看好花括号 “ {} “ 类方法的可变参数可变参数的意思就是方法的参数数量可以变化，在开发过程中会经常遇到参数个数无法确定的情况，这时候就需要可变参数了。 可变参数的语法： 1methodName({paramList},paramType…paramName); 其中，methodName 表示方法名称；paramList 表示方法的固定参数列表；paramType 表示可变参数的类型；… 是声明可变参数的标识；paramName 表示可变参数名称。 注意：可变参数必须定义在参数列表的最后。 举个例子： 123456789101112131415161718192021222324252627282930313233343536373839public class Kbcs { public static void main(String[] args) { System.out.println(\"有其他参数方法\"); kbParam(\"kk\", 10, new double[] { 8.8, 9.9, 123.4 }); System.out.println(\"无其他参数方法\"); kbParam2(8.8, 9.9, 123.4); } /** * * @Title: kbParam * @Description: 有其他参数 * @author: MGG * @param name * @param i * @param ds */ public static void kbParam(String name, int i, double... ds) { System.out.println(\"可变参数个数：\" + ds.length); for (double d : ds) { System.out.println(d); } } /** * * @Title: kbParam2 * @Description: 无其他参数 * @author: MGG * @param ds */ public static void kbParam2(double... ds) { System.out.println(\"可变参数个数：\" + ds.length); for (double d : ds) { System.out.println(d); } }} 运行结果： 当有其他参数时，可变参数要放在后面，并且需要 new 创建对应类型的数组对象，填写参数。 当没有其他参数时，可以直接写对应类型的参数。 小尾巴这部分知识内容多，需要多练，多体会，基础要打牢。","link":"/2020/02/19/javabase24-oop-class/"},{"title":"JAVA零基础筑基到修仙（二十五）—— this 关键字","text":"this 关键字是 Java 常用的关键字，可用于任何实例方法内指向当前对象，也可指向对其调用当前方法的对象，或者在需要当前类型对象引用时使用。本篇包括：this.属性，this.方法，this.构造方法 一、this.属性名大部分时候，普通方法访问其他方法、成员变量时无须使用 this 前缀，但如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用 this 前缀。 其实在上一篇说 getter setter的时候已经有遇到这个关键字了，举一个 Person 类的例子： 12345678public class Person { private String name; private int age; private String gender; //性别 private double tall; //身高 } 除了加上 getter 和 setter 这次加点新的，添一个构造方法和一个 toString。 直接快速生成： 因为是第一次碰到构造方法，请自己仔细体会方法内部信息 此时 Person 类变成了 完全体： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Person { private String name; private int age; private String gender; //性别 private double tall; //身高 /** * 带参数构造方法 * @param name * @param age * @param gender * @param tall */ public Person(String name, int age, String gender, double tall) { super(); this.name = name; this.age = age; this.gender = gender; this.tall = tall; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public double getTall() { return tall; } public void setTall(double tall) { this.tall = tall; } @Override public String toString() { return \"Person [name=\" + name + \", age=\" + age + \", gender=\" + gender + \", tall=\" + tall + \"]\"; } } 可以看到，构造方法和 setter 方法内部都有 this 关键字，通过 this.属性 让参数变为类属性的值，编写一个测试类来看一下构造方法的作用。 补充一个问题,当类中只有一个有参构造： 1234567891011public static void main(String[] args) { // TODO Auto-generated method stub // 利用有参数的构造方法直接给Person类对象属性赋值 Person person = new Person(\"kangkang\", 10, \"男\", 110); System.out.println(person.getName()); System.out.println(person.getAge()); System.out.println(person.getGender()); System.out.println(person.getTall()); // 直接使用toString System.out.println(person.toString());} 运行结果： 很明显，通过类中的有参构造，为 Person 类属性赋值，而在构造方法中正是使用了 this 关键字（仔细体会开头的那句话：如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用 this 前缀） 提示：当一个类的属性（成员变量）名与访问该属性的方法参数名相同时，则需要使用 this 关键字来访问类中的属性，以区分类的属性和方法中的参数。 二、this.方法名this 关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。 新建一个 Student 类，让其中一个方法调用另一个方法，具体流程为吃晚饭，写作业，睡觉： 123456789101112131415161718192021222324252627public class Student { private static final String name = \"Tom\"; /** * 学习 */ public void study() { System.out.println(\"do homework\"); } /** * 吃饭 */ public void eat() { System.out.println(\"have a dinner\"); } /** * 睡觉 */ public void sleep() { this.eat(); this.study(); System.out.println(\"do sleep\"); }} 写个测试类： 123456public static void main(String[] args) { // TODO Auto-generated method stub Student stu = new Student(); System.out.println(Student.name); stu.sleep();} 查看结果： 在 Student 类中的sleep 方法使用this 关键字调用了其他两个方法，在测试类中只需要调用一个 sleep 就可以完成 三个方法的操作。 我们发现当 sleep 方法改为这样 12345public void sleep() { eat(); study(); System.out.println(\"do sleep\");} 重新运行测试类，发现输出结果一样，省略 this 前缀只是一种假象，虽然程序员省略了调用 eat()、study() 方法之前的 this，但实际上这个 this 依然是存在的。 注意：对于 static 修饰的方法而言，可以使用类来直接调用该方法，如果在 static 修饰的方法中使用 this 关键字，则这个关键字就无法指向合适的对象。所以，static 修饰的方法中不能使用 this 引用。并且 Java 语法规定，静态成员不能直接访问非静态成员。 三、this 访问构造方法将 Student 改为这样 123456789101112131415161718192021222324252627public class Student { private String name; /** * 学习 */ public void study() { System.out.println(this.name+ \" do homework\"); } /** * 无参构造 */ public Student() { this(\"Tom\"); } /** * 有参构造 * @param name */ public Student(String name) { super(); this.name = name; } } 测试类： 1234567public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Student stu = new Student(); stu.study(); }} 无参构造直接通过 this(“Tom”) 给私有属性赋予了值， this(“Tom”) 与 this.Student(“Tom”) 等价，且只能在构造方法中使用，也必是第一条代码。 super 关键字当在创建无参构造时，会发现方法中有 super(); 1234public Student() {super();} super 关键字是指向父类的引用，前面说过创建的每一个类都会继承 Object 类，刚才 this() 的用法为指向自己个构造，那么 super() 就会指向父类构造方法，我认为这解释了为什么创建基类对象后，父类方法可以直接使用。 与 this() 一样，只能在构造方法中使用，也必是第一条代码。 小尾巴在正常的开发中，用到实体类都会有专门的软件生成，不用自己手写，因为写实体类实在浪费时间。实体类一建生成可以让程序员吧时间放在逻辑代码部分，提高开发效率。但是作为新手的话，还是多写写，多多体会。","link":"/2020/02/19/javabase25-this/"},{"title":"JAVA零基础筑基到修仙（二十六）——创建对象（显式、隐式）","text":"把对象创建的过程称为类的实例化，如果类没有实例化，无论是类属性还是方法都无法使用（除了 static 修饰的），本篇内容学习如何创建对象，主要内容有：三种显式、一种隐式创建方法 一、显式创建对象显式创建对象有四种：new 、java.lang.Class 类方法创建、对象 clone 方法、 java.io.ObjectlnputStream 对象的 readObject() 方法。 1.new 关键字创建对象这个是最常用的方式，前面也多次使用，这里不再多叙述，new 的语法为： 12345类型 对象名 = new 类型();// 例如String str = new String();// 有时候用不着对象名 ——匿名对象System.out.print(new String(\"This is kangkang!!\")); 匿名对象没有明确给出对象名，普通对象需要同时在栈和堆中开辟空间，匿名对象只占用堆空间，而且匿名对象时一次性的，如果当前方法里值与需要用到一次对象，可以采用这种写法，通常作为参数使用。 2.使用 newlnstance() 方法借助了 java.lang.Class 类提供的 newInstance 方法，首先创建 Class 对象（注意区分 Class 与 class，Class是一个具体的类，class 是类的概念，一个关键字），Class 对象无法通过 new 新建，需要借助静态方法 .forName 完成对象创建。Class 类功能很强大，支持了 java 中很重要的 “反射机制” ，反射机制后面单独讲。 用法： 123// java.lang.ClassClass 类对象名称 = Class.forName(要实例化的类全称);类名 对象名 = (类名)Class类对象名称.newInstance(); Demo： 12345678910public static void main(String[] args) { try { // forname 中参数 一定是类的完整路径，要带包名 Class cls = Class.forName(\"demo_class.Student\"); Student stu = (Student) cls.newInstance(); stu.study(); }catch(Exception e){ throw new RuntimeException(e); }} 用到了昨天建的 Student 类，要提醒的是，使用 forName 时，参数是类的完整路径，一定要带包名。 提到包名就要说说包命名规范，通常为 com.公司.项目.[package]…. 这个 com 是 company 的缩写，说明是公司项目，那个人项目呢？ 包命名有如下规范： 个人的项目命名： indi ： 个体项目（individual），指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。 包名为“indi.发起者名.项目名.模块名……” onem ： 单人项目（one-man），推荐用indi，指个人发起，但非自己独自完成的项目，可公开或私有项目，copyright主要属于发起者。 包名为“onem.发起者名.项目名.模块名……” pers ： 个人项目（personal），指个人发起，独自完成，可分享的项目，copyright主要属于个人。 包名为“pers.个人名.项目名.模块名.……” priv ： 私有项目（private），指个人发起，独自完成，非公开的私人使用的项目，copyright属于个人。 包名为“priv.个人名.项目名.模块名.……” 团体的项目命名: team： 团队项目，指由团队发起，并由该团队开发的项目，copyright属于该团队所有。 包名为“team.团队名.项目名.模块名.……” com ： 公司项目，copyright由项目发起的公司所有。 包名为“com.公司名.项目名.模块名.……” 比如上面的测试类所处的包正确的包名为：pers.mgg.demo.test Student 类 1234567891011121314151617public class Student implements Cloneable { private String name; /** * 学习 */ public void study() { System.out.println(\"do homework\"); } //实现接口后 重写 clone方法 右击→ Source → Override/Implement Methods @Override protected Object clone() throws CloneNotSupportedException { // TODO Auto-generated method stub return super.clone(); }} 测试结果： 3.使用 clone() 方法该方法很少用，使用该方法创建对象时，要实例化的类必须继承 java.lang.Cloneable 接口。 调用对象的 clone() 方法创建对象的语法格式如下： 1类名对象名 = (类名)已创建好的类对象名.clone(); Demo: 123456789101112public static void main(String[] args) { Student stu1 = new Student(); Student stu2 = null; try { stu2 = (Student) stu1.clone(); } catch (CloneNotSupportedException e) { // TODO Auto-generated catch block e.printStackTrace(); } stu2.study();} 运行结果： 代码中的 try catch 是异常处理，详细内容到后面异常处理再说，这里稍微提一下： 在实际开发中用 try catch 比较多 二、隐式创建隐式创建其实前面经常用了，举个例子就是 String str = “oh! awesome!!” 。 以及当使用字符串拼接时 str = str+”come on” 也会隐式创建对象，str 已经不是原来的 str 了。 最后 java 虚拟机在加载 .class 文件时，都会创建一个上面说到的 java.lang.Class 对象，用来封装类在方法区内的数据结构。 垃圾回收（jvm gc）每个对象都是相互独立的，在内存中占有独立的内存地址，并且每个对象都具有自己的生命周期，当一个对象的生命周期结束时，对象就变成了垃圾，由 Java 虚拟机自带的垃圾回收机制处理。 小尾巴显式的三种方法，前两种要掌握，clone 方法要了解，隐式就没什么可说了。","link":"/2020/02/20/javabase26-newobj/"},{"title":"JAVA零基础筑基到修仙（二十七）——注释","text":"学过了类的各种东西，现在说一个很简单但是很重要的东西，就是注释——javadoc，简单是因为只需要按几下按键就出来了，重要是因为，有注释会给予看程序的其他人极大的方便，其他人不用去猜你写这个类做啥用，这个方法干嘛用。大大提高了程序的可读性，维护起来容易多了。 虽然从事开发工作时间不长，但是从我敲第一行代码开始就养成写注释的习惯了，几乎每个方法和类都会写注释，毕竟写个注释用不了几秒。也有遇到大佬不写注释的，类也不写，方法也不写，用到时都要去猜去试，浪费不少时间，大概这就是大佬把，哈哈哈。下面演示一下在 Eclipse 下如何快速生成注释。 生成注释前必须要先做配置，默认的注释过于简单，配置流程如下： 我把我的配置写出来，我就配置了三个，你也可以去百度搜“eclipse 注释模板”挑选自己喜欢的： 123456789101112131415161718192021222324252627282930// Files 文件/** * All rights Reserved, Designed By www.mggblog.ink * @Title: ${file_name} * @Package ${package_name} * @Description: Description * @author: mgg * @date: ${date} ${time} * @version V1.0 * @Copyright: */// Types 类/** * @ClassName: ${type_name} * @Description: ${todo} * @author ${user} * @date ${date} * ${tags} */// Methods 方法/** * @Title: ${enclosing_method} * @Description: ${todo} * @author: ${user} * ${tags} */ 下面说如何用，上图： 然后编辑 Description ,描述作用。方法上生成注释的操作也是一样的，不举例了。 最后效果 小尾巴一定要养成写注释的好习惯啊。","link":"/2020/02/20/javabase27-doc/"},{"title":"JAVA零基础筑基到修仙（二十八）——类中常见关键字（访问权限、static、final）","text":"本篇把类中常用的关键字单独拿出来说说，内容包含：访问权限控制关键字 private、friendly、protected、public，静态关键字 static，完结器 final 关键字 一、访问权限控制修饰符（private、friendly、protected、public）前面提到，类是对对象的封装，既然是封装，那出发点肯定是不想让箱子外部随机接触箱内，所以设置访问权限，想让你看的给你看，不想的外部怎么都访看不见。 类修饰符：public，default（不用写出来）这四个关键字并不是随处都能用，其中 public 只能用在类声明中，在类声明中，除了使用 public 还可以什么都不写，不写的话权限默认为 default ，两者的不同为：public 声明的类可以被其他包调用，default（不加修饰符） 权限的类只能在包内使用。 成员变量与成员方法修饰符（private、friendly、protected、public） 四种修饰符权限差异： 访问范围 private friendly(默认) protected public 同一个类 可访问 可访问 可访问 可访问 同一包中的其他类 不可访问 可访问 可访问 可访问 不同包中的子类 不可访问 不可访问 可访问 可访问 不同包中的非子类 不可访问 不可访问 不可访问 可访问 简短叙述一下（权限大小也按1.2.3.4.排，越往下越大）： private用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用。 friendly如果一个类没有访问控制符，说明它具有默认的访问控制特性。这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，即使其他包中有该类的子类。这种访问特性又称为包访问性（package private）。 protected用保护访问控制符 protected 修饰的类成员可以被三种类所访问：该类自身、与它在同一个包中的其他类以及在其他包中的该类的子类。使用 protected 修饰符的主要作用，是允许其他包中它的子类来访问父类的特定属性和方法，否则可以使用默认访问控制符。 public当一个类被声明为 public 时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用 import 语句引入 public 类，就可以访问和引用这个类。 每个程序的主类必须是 public 。 在讲类的时候里面有提到 private 与 public的用法，其他两个用法实在很少用到，做项目不可能吧权限细分的那么清楚，找很多麻烦。 二、static 关键字（加一个静态导入的知识）类中的属性和方法概括为类成员，带有 static 关键字修饰的称为：静态成员，静态成员为类所有，不依赖与任何对象，只要类被加载，就可以被访问。 前面有用到了 static 修饰的属性和方法，调用语法为： 1类名.方法/属性; 再举个例子加深印象 1234567891011121314151617181920212223public class Boy { public static String name = \"kangkang\"; /** * * @Title: run * @Description: 男孩跑步 * @author: MGG */ public static void run() { System.out.println(name + \" is running！\"); } /** * * @Title: jump * @Description: 男孩跳 * @author: MGG */ public void jump() { System.out.println(name + \" is jumpping！\"); }} 然后编写测试类： 12345678910111213141516171819public class Test { public static void main(String[] args) { // TODO Auto-generated method stub //创建两个 boy 对象 Boy boy1 = new Boy(); Boy boy2 = new Boy(); System.out.println(\"静态变量 name 值：\"+Boy.name); boy1.jump(); boy2.jump(); // 在这里改变静态变量值 Boy.name = \"jhon\"; System.out.println(\"------静态变量值改变--------\"); System.out.println(\"静态变量 name 值：\"+Boy.name); boy1.jump(); boy2.jump(); }} 运行结果： 我们发现，静态变量值改变时，使用它的每一个对象也会作出相应改变，如果是普通成员变量的话，不同对象的值是没有干扰的。 静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。 如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。 除了静态方法静态变量，类中还可以有静态代码块，如： 123456public class staticCode{ public static int i = 10; static{ i++; }} 在测试类中 1System.out.println(Boy.i); //结果为 11 在直接使用时，i 已经自加过了，提高了代码效率？我实在不知道有什么用。 静态导入在 JDK 1.5 之后增加了一种静态导入的语法，用于导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法。如果一个类中的方法全部是使用 static 声明的静态方法，则在导入时就可以直接使用 import static 的方式导入。 静态导入使用 import static 语句，静态导入也有两种语法，分别用于导入指定类的单个静态成员变量、方法和全部静态成员变量、方法，其中导入指定类的单个静态成员变量、方法的语法格式如下： 1import static package.ClassName.fieldName|methodName; 上面语法导入 package.ClassName 类中名为 fieldName 的静态成员变量或者名为 methodName 的静态方法。例如，可以使用import static java.lang.System.out;语句来导入 java.lang.System 类的 out 静态成员变量。 导入指定类的全部静态成员变量、方法的语法格式如下： 1import static package.ClassName.*; 上面语法中的星号只能代表静态成员变量或方法名。 说那么多，其实只需与普通 import 对比下就行了，一句话： import 和 import static 的作用，使用 import 可以省略写包名，而使用 import static 可以省略类名。而且在开发过程中，没什么机会让你手动导入。除了遇到大佬自己写的工具类。 三、final 关键字final 的意义就是无法再改变，声明为多少就是多少。 final 有如下限制作用： 如果 final 用在了变量前面，变量就变为常量，无法在改变， 如果 final 加在方法前面，表明方法无法被重写，重写的意思就是方法名和参数一样，方法体不一样。 如果 final 加在了类前，表明类无法被继承。 但是在使用时应该注意一下几点： 在变量中，如果使用 final ，成为常量，可以不赋值，但是在使用前必须先赋值，赋值之后就无法改变了。 对基本类型变量来说是其值不可变，而对对象引用类型变量来说其引用不可再变。 在开发中我们约定，如果使用 final 定义常量，常量的名字使用全大写字符，如：1public static final String IP = \"192.168.1.1\"; 如果 final 修饰了类，就不需要在类方法前加 final 操作没有意义。","link":"/2020/02/20/javabase28-lgjz/"},{"title":"JAVA零基础筑基到修仙（二十九）—— main() 方法","text":"Java中，mian 方法是所有程序的入口，与其他方法有很大的不同，从开始到现在 main 方法已经用过很多次了，但是从来没有详细说明过 main 方法的特点，本篇内容来补充这个知识点。 Java main() 方法main 方法有只有一种写法，格式为： 123public static void main(String[] args){} 通过 main 方法代码发现： main 方法是公有的； main 方法是静态方法；（在当前类的 main 里调用其他方法，那这个方法也必须是 static 修饰） main 方法没有返回值； main 方法的参数是字符串数组。（用来接收执行 Java 程序的命令行参数。命令行参数作为字符串，按照顺序依次对应字符串数组中的元素。） 一定要注意，main 方法的定义中只有参数名 args 是可以改变的，其他都是固定格式，不能添不能少。但是我们约定参数名和java规范中的名字一样，所以 args 也是不能改的。 注意因为 static 修饰，main 方法里调用的所有方法必是静态方法，否者无法调用，举个例子： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub dogJump(); catJump();//Cannot make a static reference to the non-static method catJump() from the type Test}public static void dogJump() { System.out.println(\"Dog jump!!\");}public void catJump() { System.out.println(\"Cat jump!!\");} 新建一个类，下面通过 Windows 命令行工具，查看 main 方法里参数的情况： 123456789101112public class TestMain { public static void main(String[] args) { int n = args.length; // 获取参数数量 System.out.println(\"一共有 \" + n + \" 个参数\"); if (n &gt; 0) { // 判断参数个数是否大于0 for (int i = 0; i &lt; n; i++) { System.out.println(args[i]); } } }} 运行过程： 可以发现 main 方法可以通过控制台传递字符串参数。 一个程序只能有一个 main 方法，通常做测试用，比如写了几个类，需要一个入口来测试类中方法是否正确。我们称为单元测试，单元测试在开发中非常重要。 后面会遇到 Junit ，一个专门用来做单元测试的工具，到时候再详细介绍用法。","link":"/2020/02/21/javabase29-main/"},{"title":"JAVA零基础筑基到修仙（三）——标识符与关键字、常量与变量、作用域、数据类型和类型转换","text":"本篇内容包括Java语言中标识符、关键字、常量、变量和数据类型的讲解，学任何一门语言，这些内容都是最基础也是最重要的，就像盖房子，不同的材料有不同的用处，让材料物尽其用才能盖好房子。实践是检验真理的唯一标准，学知识就要多实践，学计算机语言就要多敲代码，只有这样知识才能学得会，记得牢，技巧也用的熟。 一、标识符与关键字标识符标识符分为两类，分别为关键字和用户自定义标识符。 关键字是有特殊含义的标识符，如 true、false 表示逻辑的真假。 用户自定义标识符是由用户按标识符构成规则生成的非保留字的标识符，如 abc 就是一个标识符。此外，标识符可以包含关键字，但不能与关键字重名。 Java中标识符用来定义方法、变量或者其他用户自定义的名称，它可以是一个字符，也可以是一个字符串。构成规则如下： 标识符由数字（0-9）和字母（A-Z 和 a-z）、美元符号（$）、下划线（_）以及 Unicode 字符集中符号大于 0xC0 的所有符号组合构成（各符号之间没有空格）。 标识符的第一个符号为字母、下划线和美元符号，后面可以是任何字母、数字、美元符号或下划线，不可以用数字开头。 Java语言中区分大小写，例如boy与Boy是两个不同的字符串提个醒：标识符是变量、类名、方法名的命名，命名提倡给予标识符正确含义，如定义两个男孩可以用boy_1与boy_2，不提倡用a、b定义（要养成好习惯，初学C语言深受老谭毒害） 关键字关键字是说这个标识符有特定的用处，不能随便拿来用，如上图不能用“true”做变量名。每个jdk版本里关键字的数量是一定的，不同的jdk中关键字的数量可能不同。下面列举常见关键字： 数据类型：boolean、int、long、short、byte、float、double、char、class、interface。 流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。 修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。 动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。 保留字：true、false、null、goto、const。提个醒：虽然有区分大小写，但是也尽量不要用“Public”、“True”等类似标识符，容易产生歧义。 二、常量与变量常量和常量值常量就是不变的量，常量值是常量的值（解释的很蠢，但是就是这个意思）。代码中可以使用定义过的常量，也可以直接使用常量值。定义常量的方法就是在类型前面加关键字“final”。下面练习定义常量和认识常量值。 整型常量值，按进制分八进制、十进制、十六进制定义方法直接上图：整型（int）常量默认在内存中占 32 位，是具有整数类型的值，当运算过程中所需值超过 32 位长度时，可以把它表示为长整型（long）数值。长整型类型则要在数字后面加L或1，如697L表示一个长整型数，它在内存中占 64 位。 实型常量值，两种形式，十进制型小数点形式如9.9，科学计数法如1.1e5或10&amp;E3,其中 e 之前必须有数字，且 e 之后的数字必须为整数。注意：小数定义有单精度和双精度只分，单精度在末尾要加上 f 。 布尔类型常量值，true or false ，只有这两个值。 字符型和字符串型常量值，字符型如“A，a”,字符串型如“boy,girl”,还有一种转义字符，比如换行符“\\n”：下面列举出常用转义字符：变量Java中变量的使用有特定规则，必须先声明后使用，指定类型的变量只能接收该类型的值。声明变量的方法为 [数据类型 变量名 = 值]（例如 String boy = “kangkang”，也可以是 [数据类型 变量名],如 String boy; ）。在上面说各类型常量值的时候已经用到了变量声明；声明变量要依据声明类型的类方法，比如String类型就有多种声明方法，这就需要查Java API文档点开对应类，去研究研究这个类究竟有多少使用方法，Java提供了官方文档，有在线也有离线版，使用方法很简单，即使不懂，百度很容易就解决了。举个栗子：以后碰到不懂得类，可以翻翻api文档，知识学的很快的，变大佬必备。变量标识符的命名规范如下： 首字符必须是字母、下划线（―）、美元符号（$）或者人民币符号（¥）。 标识符由数字（0-9）、大写字母（A-Z）、小写字母（a-z）、下划线（―）、美元符号（$）、人民币符号（¥）以及所有在十六进制 0xc0 前的 ASCII 码组成。 不能把关键字、保留字作为标识符。 标识符的长度没有限制。 标识符区分大小写。Java 中初始化变量时需要注意以下事项： 变量是类或者结构中的字段，如果没有显式地初始化，默认状态下创建变量并默认初始值为 0。 方法中的变量必须显式地初始化，否则在使用该变量时就会出错。 三、作用域作用域界定了声明变量的使用范围，在Java中认准花括弧”{}”就行。在括弧内声明的变量只能在括弧内使用。根据作用域的不同，把变量分为成员变量和局部变量（当然这都是概念知识，敲多了自然懂）。 成员变量成员变量包含全局变量和静态变量：撸个代码看一下如何调用两种变量 1234567public class Boy { /*以下都是Boy类里的成员变量*/ public String name;//boy 姓名 （实例变量） public int age;//年龄 （实例变量） public final static String home = \"Hebei\";//家庭住址 静态常量（类变量） public static String tel = \"8888-6666666\";//电话 静态变量（类变量）} 编个测试类看一下 1234567891011121314151617public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Boy boy1 = new Boy();//将Boy类实例化为boy1 //实例变量必须用实例调用(全局变量) System.out.println(boy1.name); System.out.println(boy1.age); //实例.变量名 调用类变量(类变量) System.out.println(boy1.home); System.out.println(boy1.tel); //类变量不用实例化对象也可以直接 类.变量(类变量) System.out.println(Boy.home); System.out.println(Boy.tel); }} 运行结果全局变量有默认初始值，static final修饰的变量必须赋予初始值，类变量的方便之处就是不用实例化对象，直接用[类.变量名]调用。 局部变量局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种： 方法参数变量（形参）：在整个方法内有效。 方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。 代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。 局部变量在使用前必须先初始化值。 方法局部变量1234567891011121314public class Test { public static void main(String[] args) { // TODO Auto-generated method stub int i = 3,j = 4; if (i &gt; 2) { System.out.println(\"i=\"+i); System.out.println(\"j=\"+j); } System.out.println(\"i=\"+i); System.out.println(\"j=\"+j); }} 方法参数变量123456789101112131415public class Test { public static void main(String[] args) { // TODO Auto-generated method stub //调用方法 Test.add(1); } public static void add(int i)//方法参数变量 { int j = 10;//方法局部变量 System.out.println(\"i+j=\"+i+j); }} 代码块局部变量123456789101112131415161718public class Test { public static void main(String[] args) { // TODO Auto-generated method stub // 调用方法 Test.test(1); } public static void test(int i) {// 方法参数变量 try {// 使用try catch 代码块 异常处理代码块，后面异常篇再详细说 int j = 10;代码块 局部变量 System.out.println(\"i+j=\" + i + j); } catch (Exception e) {// 异常处理块，参数为 Exception 类型 e.printStackTrace(); } }} 作用域讲完了，是不是很简单，看准”{}”，多练比看概念要好得多。 四、数据类型Java中数据类型分为基本型和引用型我们用几张图就能搞定了，多用就能记住，不要死记硬背： 基本型与引用型数据内存存储原理 基本数据类型的存储原理：所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的内存栈上的，数据本身的值就是存储在栈空间里面，Java语言里面八种数据类型是这种存储模型； 引用类型的存储原理：引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”(存储对象在内存堆上的地址)是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的； 无论基本数据类型还是引用类型，他们都会先在栈中分配一块内存，对于基本类型来说，这块区域包含的是基本类型的内容；而对于引用类型来说，这块区域包含的是指向真正内容的指针，真正的内容被手动的分配在堆上。（最直观的例子是基本型和引用型值的比较不同，基本型用“ == ”，引用型用需要用类方法，我们将在后面筑基与修仙（十）详细说明） 基本型基本数据类型可分为 4 大类，即整数类型（包括 byte、short，int 和 long）、浮点类型（包括 float 和 double）、布尔类型和字符类型（char）：Java 定义了 4 种整数类型变量：字节型（byte）、短整型（short）、整型（int）和长整型（long）。这些都是有符号的值，正数或负数。具体说明看图：根据要求使用合适的类型，严格按照变量声明方式，Java中没有无类型变量，不再举例，上面的变量声明练习足够了，可以试着自己把所有类型敲一下。 引用型引用数据类型建立在基本数据类型的基础上，包括数组、类和接口。引用数据类型是由用户自定义，用来限制其他数据的类型。另外，Java 语言中不支持 C++ 中的指针类型、结构类型、联合类型和枚举类型。引用类型还有一种特殊的 null 类型。所谓引用数据类型就是对一个对象的引用，对象包括实例和数组两种。实际上，引用类型变量就是一个指针，只是 Java 语言里不再使用指针这个说法。空类型（null type）就是 null 值的类型，这种类型没有名称。因为 null 类型没有名称，所以不可能声明一个 null 类型的变量或者转换到 null 类型。空引用（null）是 null 类型变量唯一的值。空引用（null）可以转换为任何引用类型。在实际开发中，程序员可以忽略 null 类型，假定 null 只是引用类型的一个特殊直接量（不听不听和尚念经……）。注意：空引用（null）只能被转换成引用类型，不能转换成基本类型，因此不要把一个 null 值赋给基本数据类型的变量。 五、数据类型转换分隐式转换与显示转换两种。 隐式转换如果以下 2 个条件都满足，那么将一种类型的数据赋给另外一种类型变量的时，将执行自动类型转换： 两种数据类型彼此兼容 目标类型的取值范围大于源数据类型（低级类型数据转换成高级类型数据）例如 byte 类型向 short 类型转换时，由于 short 类型的取值范围较大，会自动将 byte 转换为 short 类型。在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。自动转换的规则是从低级类型数据转换成高级类型数据。转换规则如下： 数值型数据的转换：byte→short→int→long→float→double。 字符型转换为整型：char→int。以上数据类型的转换遵循从左到右的转换顺序，最终转换成表达式中表示范围最大的变量的数据类型，举个栗子。123456789public static void main(String[] args) { // TODO Auto-generated method stub float price1 = 10.5f; // 定义牙膏的价格 double price2 = 3.5; // 定义面巾纸的价格 int num1 = 4; // 定义牙膏的数量 int num2 = 5; // 定义面巾纸的数量 double res = price1 * num1 + price2 * num2; // 计算总价 System.out.println(\"一共付了\" + res + \"元\"); // 输出总价 } 看起来很高级，但并不是所有类型都这么好用：那么现在就用到显示转换了。显式转换当两种数据类型不兼容，或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行强制类型转换。把上面没转好的转一下：再举个例子，上面去买牙膏用的浮点型算的钱，现在只关心花了多少块，不关心几毛钱了。123456789public static void main(String[] args) { // TODO Auto-generated method stub float price1 = 10.5f; // 定义牙膏的价格 double price2 = 3.5; // 定义面巾纸的价格 int num1 = 4; // 定义牙膏的数量 int num2 = 5; // 定义面巾纸的数量 int res = (int)(price1 * num1 + price2 * num2); // 计算总价 System.out.println(\"一共付了\" + res + \"元\"); // 输出总价 } 小尾巴腰好疼，一坐就是三个小时，还是要多锻炼肾体啊。","link":"/2020/02/06/javabase3-bsfgjzclbltj/"},{"title":"JAVA零基础筑基到修仙（三十）——构造方法","text":"构造方法是类的特殊方法，创建类时会默认创建一个没有参数，没有具体方法体的构造方法，称为无参构造，还可以自己写有参数的构造完成类初始化，下面详细说说构造方法的用法。 方法名与类名一模一样的方法称为构造方法。 构造方法有以下特点： 方法名必须与类名相同 可以有 0 个、1 个或多个参数 没有任何返回值，包括 void 默认返回类型就是对象类型本身 只能与 new 运算符结合使用 值得注意的是，如果为构造方法定义了返回值类型或使用 void 声明构造方法没有返回值，编译时不会出错，但 Java 会把这个所谓的构造方法当成普通方法来处理。 构造方法是在创建对象时使用的，其他任何修饰符对他来说没有意义。 构造方法的例子： 1234567891011121314151617181920212223242526public class Person { public String name; public String gender; public String addr; /** * 无参构造 */ public Person() { this.name = \"mgg\"; } /** * 有参构造 * @param name * @param gender * @param addr */ public Person(String name, String gender, String addr) { this.name = name; this.gender = gender; this.addr = addr; }} 写个测试类： 123456789101112public static void main(String[] args) { // TODO Auto-generated method stub //无参构造 Person person = new Person(); System.out.println(person.name); System.out.println(\"下面为有参构造：\"); //有参构造 Person person2 = new Person(\"kangkang\",\"男\",\"幻想乡木吉镇比利街001号\"); System.out.println(person2.name); System.out.println(person2.gender); System.out.println(person2.addr);} 运行结果： 提示：无参数的构造方法也被称为 Nullary 构造方法。只有编译程序自动加入的构造方法，才称为默认构造函数。如果自行编写无参数、没有内容的构造函数，就不称为默认构造函数了（只是 Nullary 构造函数）。虽然只是名词定义，不过认证考试时要区别一下两者的不同。 如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。 如果类中写了有参数的构造方法，但是还想使用 Person p = new Person() 创建对象，必须手动在 Person 中添加无参构造。 有参数的构造方法是对无参构造的重载，前面已经多次提到过了，而且根据需要，可以创建任意参数的构造方法。 重载（overload）的含义：方法名相同参数不同，无论是参数的类别，还是参数的个数。区别于重写（overwrite）：在类继承时可以重写父类方法，方法名和参数完全一致，方法体不同。另一个是在实现了类接口必须重写接口中的抽象方法。 举一个重写父类方法的例子： 父类 Person 类，新添加了 work 方法： 12345678910111213141516171819202122232425262728293031323334353637public class Person { public String name; public String gender; public String addr; /** * 无参构造 */ public Person() { this.name = \"mgg\"; } /** * 有参构造 * @param name * @param gender * @param addr */ public Person(String name, String gender, String addr) { this.name = name; this.gender = gender; this.addr = addr; } /** * * @Title: work * @Description: 普通人工作 * @author: MGG */ public void work() { System.out.println(\"Person work\"); }} 子类 Doctor 类 重写了父类 work 方法： 123456789public class Doctor extends Person { /** * 重写了父类 work 医生的工作是救人 */ public void work() { System.out.println(\"healing petients\"); }} 测试类： 123456789public static void main(String[] args) { // TODO Auto-generated method stub // 创建父类对象 Person p = new Person(\"kangkang\", \"男\", \"幻想乡木吉镇比利街001号\"); p.work(); Doctor doc = new Doctor(); doc.work();} 运行结果： 重写与重载的区别要记牢，虽然没人去抓概念，但是如果在什么场合说混了那就太难堪了。","link":"/2020/02/21/javabase30-gzff/"},{"title":"JAVA零基础筑基到修仙（三十一）——析构方法","text":"析构函数的作用和构造函数相反，析构函数被用来在对象不再被使用时销毁对象，释放内存空间（例如用 new 创造出来的空间），而且系统自动执行。 析构函数Object 类中提供了一个 finalize() 方法，因为 Object 是所有类的父类，所有类都可以重写这个方法。 finalize 方法： 123protected void finalize(){ //具体操作} Jdk 文档中给出的解释： 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类重写 finalize 方法，以配置系统资源或执行其他清除。 finalize 的常规协定是：当 JavaTM 虚拟机已确定尚未终止的任何线程无法再通过任何方法访问此对象时，将调用此方法，除非由于准备终止的其他某个对象 或类的终结操作执行了某个操作。finalize 方法可以采取任何操作，其中包括再次使此对象对其他线程可用；不过，finalize 的主要目的是在不可撤消地丢弃对象之前执行清除操作。例如，表示输入/输出连接的对象的 finalize 方法可执行显式 I/O 事务，以便在永久丢弃对象之前中断连接。 Object 类的 finalize 方法执行非特殊性操作；它仅执行一些常规返回。Object 的子类可以重写此定义。 Java 编程语言不保证哪个线程将调用某个给定对象的 finalize 方法。但可以保证在调用 finalize 时，调用 finalize 的线程将不会持有任何用户可见的同步锁定。如果 finalize 方法抛出未捕获的异常，那么该异常将被忽略，并且该对象的终结操作将终止。 在启用某个对象的 finalize 方法后，将不会执行进一步操作，直到 Java 虚拟机再次确定尚未终止的任何线程无法再通过任何方法访问此对象，其中包括由准备终止的其他对象或类执行的可能操作，在执行该操作时，对象可能被丢弃。 对于任何给定对象，Java 虚拟机最多只调用一次 finalize 方法。 finalize 方法抛出的任何异常都会导致此对象的终结操作停止，但可以通过其他方法忽略它。 对象的 finalize 方法具有以下特点： 垃圾回收器是否会执行该方法以及何时执行该方法，都是不确定的。 finalize() 方法有可能使用对象复活，使对象恢复到可触及状态。 垃圾回收器在执行 finalize() 方法时，如果出现异常，垃圾回收器不会报告异常，程序继续正常运行。 举个例子： 计数类 Count ： 12345678910111213141516171819202122232425262728293031public class Count { private static int count = 0; /** * 创建对象时计数加一 */ public Count() { count++; } /** * 模拟销毁对象 */ protected void finalize() { // 销毁对象是变量计数减一 count--; System.out.println(\"对象销毁\"); } /** * 计数查询方法 * * @Title: getCount * @Description: TODO * @author: MGG * @return */ public int getCount() { return count; }} 测试类 Test ： 123456789101112131415public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Count c = new Count(); System.out.println(\"创建对象c当前count：\" + c.getCount()); Count c2 = new Count(); System.out.println(\"创建对象c2当前count：\" + c2.getCount()); c.finalize(); System.out.println(\"销毁对象c当前count：\" + c2.getCount()); }} 运行结果： finalize 方法具有不确定性，如果需要手动对象回收，使用 System.gc() 或者 Runtime.gc() 更好点。","link":"/2020/02/22/javabase31-xgff/"},{"title":"JAVA零基础筑基到修仙（三十二）——递归算法","text":"递归算法简单说就是方法调用自己，对递归我也就懂这么一点，学习递归是一个很长的过程，从“学会”、“学好”到“用好”得有很长时间的积累，本篇内容简单说说什么是递归，和什么时候用递归，再深了我也不懂了，以后再补充吧。 什么是递归？我们可以把递归比喻成查词典，查到一个词解释里又有个词不懂，接着去查这个词，然后解释里又有个词不懂，就这样往复往后查，直到弄懂了所涉及到的所有词的意思，问题得以解决。 在讲快速排序时就已经用到递归算法了。 阶乘是演示递归算法的一个经典例子，顺带把普通循环的方法也弄上： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class DgTest { public static void main(String[] args) { // 递归结果和用时 long startTime = System.nanoTime(); int i = jc(10); long endTime = System.nanoTime(); System.out.println(\"10!=\" + i + \" 用时:\" + (endTime - startTime) + \"ns\"); // 循环结果和用时 startTime = System.nanoTime(); int j = jc_loop(10); endTime = System.nanoTime(); System.out.println(\"loop_10!=\" + j + \" 用时:\" + (endTime - startTime) + \"ns\"); } /** * * @Title: jc * @Description: 阶乘递归示例 * @author: MGG * @param i * @return */ public static int jc(int i) { int result; if (i == 1) return 1; result = i * jc(i - 1); return result; } /** * * @Title: jc_loop * @Description: 阶乘循环示例 * @author: MGG * @param i * @return */ public static int jc_loop(int i) { int result = 1; while (i &gt; 1) { result *= i; i--; } return result; }} 运行结果： 从结果中可以看出，递归算法不仅可以用普通循环算法代替，而且普通循环算法在相同结果的情况下所用时间更少。 递归就是不停地入栈出栈当一个方法调用它自身的时候，堆栈就会给新的局部变量和自变量分配内存，方法代码就带着这些新的变量从头执行。递归调用并不产生方法新的拷贝。只有参数是新的。每当递归调用返回时，旧的局部变量和自变量就从堆栈中清除（就这么不停地入栈出栈），运行从方法中的调用点重新开始。递归方法可以说是像“望远镜”一样，可以自由伸缩。 许多子程序的递归版本执行时会比它们的迭代版本要慢一点，因为它们增加了额外的方法调用的消耗。对一个方法太多的递归调用会引起堆栈崩溃。因为自变量和局部变量的存储都在堆栈中，每次调用都创建这些变量新的拷贝，堆栈有可能被耗尽。如果发生这种情况，Java 的运行时系统就会产生异常。但是，除非递归子程序疯狂运行，否则你大概不会担心这种情况。 使用递归的好处递归的主要优点在于：某些类型的算法采用递归比采用迭代算法要更加清晰和简单。例如快速排序算法按照迭代方法是很难实现的。还有其他一些问题，特别是人工智能问题，就依赖于递归提供解决方案。最后，有些人认为递归要比迭代简单。 当编写递归方法时，你必须使用 if 条件语句在递归调用不执行时来强制方法返回。如果你不这么做，一旦你调用方法，它将永远不会返回。这类错误在使用递归时是很常见的。尽量多地使用 println() 语句，使你可以了解程序的进程。如果发现错误，立即中止程序运行。 递归的学习是循序渐进的，真正完全掌握怕是要很长时间，总的来说，递归与普通循环的不同就是递归把本属于程序员思考的部分内容推给了机器。 当遇到使用普通循环不好实现的算法时，可以试着使用递归算法。 小尾巴我这个程度的写递归知识是真的不太行，在工作中很少用到，唯一用递归的场景就是遍历系统菜单，这个需求凡是数据管理系统大概都得用到，还是很重要的。对递归感兴趣的话多去看看csdn上的博客，这篇博客我以后会再补充。","link":"/2020/02/22/javabase32-dg/"},{"title":"JAVA零基础筑基到修仙（三十三）——类的封装","text":"封装在讲对象和类的时候已经多多少少有说过，接下来的内容会把封装，继承，多态单独说说，有前面的预习，现在看起来就简单多了。 封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，只能通过该类提供的方法来实现对隐藏信息的操作和访问。如计算机，内部部件非常复杂，cpu、主板、显卡、电源、内存等等，在外部套一个机箱，使用外部接口供电流流通和人机交互，机箱保护了内部部件的安全。 封装的特点： 只能通过规定的方法访问数据。 隐藏类的实例细节，方便修改和实现。 类封装一般包含这几步： 使用 private 修饰类的内部属性； 设置公有（public）的 setter 和 getter 方法，可以修改 setter 方法对赋值进行定制化修改； 根据需要确定类方法为私有（private）还是公有（public）； 根据需要创建有参与无参构造以及 toString 方法。 举个例子，创建一个 Dog 封装类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * * @ClassName: Dog * @Description: 狗实体类 * @author MGG * @date Feb 23, 2020 */public class Dog { private String name; private int age; private String type; /** * * @Title: jump * @Description: 跳高 * @author: MGG */ public void jump() { System.out.println(\"dog jump !\"); } /** * 获取 狗的姓名 */ public String getName() { return name; } /** * 设置 狗的姓名 */ public void setName(String name) { this.name = name; } /** * 获取 狗的年龄 */ public int getAge() { return age; } /** * 设置 狗的年龄 */ public void setAge(int age) { this.age = age; } /** * 获取 狗的种类 */ public String getType() { return type; } /** * 设置 狗的种类 */ public void setType(String type) { this.type = type; } /** * toString 方法 */ @Override public String toString() { return \"Dog [name=\" + name + \", age=\" + age + \", type=\" + type + \"]\"; } /** * 有参构造 * * @param name * @param age * @param type */ public Dog(String name, int age, String type) { super(); this.name = name; this.age = age; this.type = type; } /** * 无参构造 */ public Dog() { super(); }} 使用 private 修饰 Dog 类属性意味着外部只能通过公有的 setter 和 getter 方法访问和修改属性，jump 方法可以在任何外部类中访问。当然还可以加入 public 修饰的静态常量和静态方法。 写一个测试类，新建一个 dog 对象，并赋予属性值： 12345678910111213141516public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Dog dog1 = new Dog(); dog1.setName(\"臭蛋\"); dog1.setAge(2); dog1.setType(\"金毛犬\"); Dog dog2 = new Dog(\"拖孩儿\", 3, \"哈士奇\"); System.out.println(\"dog1的名字：\" + dog1.getName() + \" 年龄：\" + dog1.getAge()); System.out.println(\"dog2的名字：\" + dog2.getName() + \" 年龄：\" + dog2.getAge()); dog1.jump(); dog2.jump(); }} 运行结果： 可以在 setter 方法中设置限制，比如 age &gt; 3 否则提示超出年龄，不再举例了。","link":"/2020/02/23/javabase33-fz/"},{"title":"JAVA零基础筑基到修仙（三十四）——继承","text":"继承是面向对象的三大特征之一。继承和现实生活中的“继承”的相似之处是保留一些父辈的特性，从而减少代码冗余，提高程序运行效率。 继承需要使用 extends 关键字，用法：基类 extends 父类，extends 直译为“扩展”，其实用扩展来描述基类与父类的关系更加准确。 基类继承父类后，父类的属性和方法的权限修饰不会变，而且不能继承父类的构造方法。 举个继承的例子，创建医生 Doctor 类和病人 Patient 类继承 Person 类： Person 类 1234567891011121314151617181920212223242526public class Person { private String name;//姓名 private String gender;//性别 private int age;//年龄 public String getName() { return name; } public void setName(String name) { this.name = name; } public String getGender() { return gender; } public void setGender(String gender) { this.gender = gender; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }} Doctor 类： 123456789101112131415161718192021public class Doctor extends Person { private String ks;//科室 /** * 重写了父类 work 医生的工作是救人 */ public void work() { System.out.println(\"healing petients\"); } public String getKs() { return ks; } public void setKs(String ks) { this.ks = ks; } } Patient 类： 1234567891011121314151617181920212223public class Patient extends Person{ private String illness;//病情 /** * 看医生 * @Title: seeDoctor * @Description: TODO * @author: MGG */ public void seeDoctor() { System.out.println(\"see a doctor\"); } public String getIllness() { return illness; } public void setIllness(String illness) { this.illness = illness; } } 测试类： 123456789101112131415161718192021public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Patient p = new Patient(); p.setAge(20); p.setGender(\"男\"); p.setName(\"Tom\"); p.setIllness(\"头痛\"); Doctor d = new Doctor(); d.setAge(30); d.setGender(\"女\"); d.setName(\"Jane\"); d.setKs(\"神经内科\"); System.out.print(\"病人\"+p.getName()+p.getAge()+\"岁 \"+\"因\"+p.getIllness()+\" \"); p.seeDoctor(); System.out.print(d.getKs()+\"医生\"+d.getName()+\" \"); d.work(); }} 运行结果： 单继承Java 不支持多继承，只允许一个类直接继承另一个类，即子类只能有一个直接父类，extends 关键字后面只能有一个类名，但是一个类可以被多个类继承。还有要注意： Object 是所有新定义类的父类，虽然没有 extends 字段。 父类中的 private 成员在子类中是不可见的，因此在子类中不能直接使用它们。如上面例子中的是通过继承了父类的 getter 和 setter 方法来给父类中的属性赋值的。 强调单继承的原因是因为 C++ 支持多继承，如果是 C++ 程序员学java很容易不注意。 最后总结继承的优缺点：优点： 实现代码共享，减少创建类的工作量，使子类可以拥有父类的方法和属性。 提高代码维护性和可重用性。 提高代码的可扩展性，更好的实现父类的方法。 缺点： 继承是侵入性的。只要继承，就必须拥有父类的属性和方法。 降低代码灵活性。子类拥有父类的属性和方法后多了些约束。 增强代码耦合性（开发项目的原则为高内聚低耦合）。当父类的常量、变量和方法被修改时，需要考虑子类的修改，有可能会导致大段的代码需要重构。","link":"/2020/02/23/javabase34-jc/"},{"title":"JAVA零基础筑基到修仙（三十五）—— super 关键字","text":"由于子类不能继承父类的构造方法，因此，如果要调用父类的构造方法，可以使用 super 关键字。super 可以用来访问父类的构造方法、普通方法和属性。 super 关键字在讲 this 关键字的时候顺带说了一下，this 代表的是当前基类， super 代表父类，它的功能是： 在子类的构造方法中显式的调用父类构造方法 访问父类的成员方法和变量。 super 调用父类构造方法新建 Animal 动物类： 12345678910111213141516171819202122public class Animal { public String name; /** * 无参构造 */ public Animal() { super(); System.out.println(\"Animal 无参构造\"); } /** * 有参构造 * @param name */ public Animal(String name) { super(); this.name = name; System.out.println(\"Animal 有参构造 Animal name = \"+name); } } 用 eclipse 快速生成的两个构造方法时，可以看到方法内部自带 super() ，当前的 super() 是指向父类 Object 的无参构造方法。 创建 Cat 类继承 Animal 类： 123456789101112131415161718192021222324public class Cat extends Animal { public String type; /** * 无参构造 */ public Cat() { super(); } /** * 有参构造 * * @param type * @param name */ public Cat(String type, String name) { super(name); this.type = type; this.name = name; }} Test 测试类： 123456789public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Cat cat1 = new Cat(); Cat cat2 = new Cat(\"狸花猫\", \"花花\"); }} 运行结果： 通过 Cat 两个构造方法，我们看到通过 Super 可以分别调用父类 Animal 的有参和无参构造方法，而且和 this() 一样，要放在方法代码第一行。 super 访问父类成员访问父类成员与 this 访问基类成员的方法一样，就是 super.成员 我们把上面的 Animal 和 Cat 类改改： Animal 类： 12345678910111213141516public class Animal { public String name; /** * * @Title: jump * @Description: 动物跳 * @author: MGG * @param name * @return */ public void jump() { System.out.println(this.name+\" jump\"); } } Cat 类: 12345678910111213141516171819202122232425262728293031323334353637public class Cat extends Animal { public String type; /** * 重写父类 jump 方法 */ public void jump() { //其实 this 可以不写 System.out.println(this.type+\" \" + this.name + \" jump\"); } /** * 无参构造 */ public Cat() { super(); } /** * 有参构造 * * @param type * @param name */ public Cat(String type, String name) { super(); this.type = type; // 为父类 属性 name 赋值 super.name = name; // 调用父类 jump 方法 super.jump(); // 基类 jump 方法 this.jump(); }} Cat 类重写了父类 jump 方法，我们在 Cat 类 有参构造中演示用 super 和 this 分别调用父类和基类属性和方法。 测试类 Test： 12345678public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Cat cat2 = new Cat(\"狸花猫\", \"花花\"); }} 运行结果： 如果是基类中独有的属性和方法，可以省略 this 。 super() 与 this() 都不能在 static 环境中使用。","link":"/2020/02/23/javabase35-super/"},{"title":"JAVA零基础筑基到修仙（三十六）——多态","text":"多态性是面向对象编程的又一个重要特征，它是指在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，这使得同一个属性或方法在父类及其各个子类中具有不同的含义。 对面向对象来说，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的方法。通过编译之后会变成两个不同的方法，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是大家通常所说的多态性。 Java 实现多态有 3 个必要条件：继承、重写和向上转型。只有满足这 3 个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法（壳子不变，核心重新写）。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。 向上转型是java中类型转换的知识，这里说一下不再做单独解读java对象的类型转换分为向上转和向下转1. 向上转型父类引用指向子类对象为向上转型，语法格式如下：fatherClass obj = new sonClass(); 如 Cat 类继承了 Animal 类，Cat 类向上转型的方式为：Animal animal = new Cat(); 向上转型就是把子类对象直接赋给父类引用，不用强制转换。使用向上转型可以调用父类类型中的所有成员，不能调用子类类型中特有成员，最终运行效果看子类的具体实现。 2.向下转型与向上转型相反，子类对象指向父类引用为向下转型，语法格式如下：sonClass obj = (sonClass) fatherClass; 如通过 Animal 对象创建 Cat 型引用：Animal animal = new Animal();Cat cat = (Cat) animal; 向下转型可以调用子类类型中所有的成员，不过需要注意的是如果父类引用对象指向的是子类对象，那么在向下转型的过程中是安全的，也就是编译是不会出错误。但是如果父类引用对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现我们开始提到的 Java 强制类型转换异常，一般使用 instanceof 运算符来避免出此类错误。 在下面的多态例子中会有用到 instanceof ，这里不再举例 继承很好理解，前面也有举过类似的例子，比如，Cat 类和 Dog 类继承 Animal 类，重写了Animal 的run方法，让Cat具有猫的跑动方式，Dog有了狗的跑动方式。 重写在前面有多次讲解，如构造方法,并且有举重写的例子，在此不再特殊说明。 举一个多态例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Test2 { public static void main(String[] args) { show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat)a; // 向下转型 c.work(); // 调用的是 Cat 的 work } public static void show(Animal a) { a.eat(); // 类型判断 if (a instanceof Cat) { // 猫做的事情 Cat c = (Cat)a; c.work(); } else if (a instanceof Dog) { // 狗做的事情 Dog c = (Dog)a; c.work(); } } }// 抽象类 Animal abstract class Animal { //抽象方法吃 abstract void eat(); } // Cat 类 继承 Animal 并重写抽象方法class Cat extends Animal { public void eat() { System.out.println(\"吃鱼\"); } public void work() { System.out.println(\"抓老鼠\"); } } // Dog 类 继承 Animal 并重写抽象方法class Dog extends Animal { public void eat() { System.out.println(\"吃骨头\"); } public void work() { System.out.println(\"看家\"); } } 运行结果： 多态有三种实现方法：方式一：重写 方式二：接口(Interface,后面详细讲) 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。 方式三：抽象类和抽象方法上面例子中 Animal 就是抽象类 类中 eat() 方法为抽象方法，有 abstract 修饰。 多态的优点： 消除类型之间的耦合关系 可替换性 可扩充性 接口性 灵活性 简化性","link":"/2020/02/23/javabase36-dt/"},{"title":"JAVA零基础筑基到修仙（三十七）—— instanceof 关键字详解","text":"严格来说 instanceof 是 Java 中的一个双目运算符，由于它是由字母组成的，所以也是 Java 的保留关键字。在 Java 中可以使用 instanceof 关键字判断一个对象是否为一个类（或接口、抽象类、父类）的实例。 instanceof 的语法： 1boolean result = obj instanceof Class; obj 代表某个类型的对象，Class 代表某个类或接口，当 obj 是 class 类（或接口）的实例或者子类实例时，结果 result 返回 true，否则返回 false。 instanceof 三种用法： 1. 判断 obj 是否为某个类对象；例： 12345public static void main(String[] args) { // TODO Auto-generated method stub Cat cat = new Cat(); System.out.println(cat instanceof Cat);// true} 2. 判断 obj 是否为接口实现类；例： 1234567public static void main(String[] args) { // TODO Auto-generated method stub List arrlist1 = new ArrayList(); ArrayList arrlist2 = new ArrayList(); System.out.println(arrlist1 instanceof List); //true System.out.println(arrlist2 instanceof List); //true} List 是 java.util 内的一个接口，ArrayList 是 List 的实现类。（到集合时详细讲讲） 3. 判断 obj 是否是某类的子类或者间接子类；例： 123456789101112131415161718192021222324252627282930// Doctor 类 之前用过的直接拿来用了public class Doctor extends Person { private String ks;//科室 /** * 重写了父类 work 医生的工作是救人 */ public void work() { System.out.println(\"healing petients\"); } public String getKs() { return ks; } public void setKs(String ks) { this.ks = ks; } }// 测试类 public static void main(String[] args) { // TODO Auto-generated method stub Person person = new Person(); Doctor doc = new Doctor(); System.out.println(doc instanceof Person);//true System.out.println(doc instanceof Object);//true System.out.println(person instanceof Doctor);//false } Doctor 类继承了 Person 类，Person 是 Object 的子类，Doctor 是 Object 的间接子类。（以上结果都验证过了放心食用。） 要注意的是 obj 必须为引用类型或者 null，不能是基本类型。如： 12345public static void main(String[] args) { // TODO Auto-generated method stub int i = 10; System.out.println(i instanceof Object);//Incompatible conditional operand types int and Object} 基本类型编译不能通过。 当 obj = null 时和任何类比都是 false ，因为 null 不代表任何类型的对象。 123456public static void main(String[] args) { // TODO Auto-generated method stub String str = null; System.out.println(str instanceof Object);//false System.out.println(str instanceof String);//false} instanceof 三目运算符假设有 Dog 类和 Cat 继承了 Animal 类，现在需要判断 obj 对象是否可转型为 Dog 对象，是返回 Dog 对象，否则返回字符串对象，提示不能转型: 1234567891011121314151617181920public class Test{public static void main(String[] args){ Animal c = new Cat();//复习向上转型 Animal d = new Dog(); System.out.println(transform(c)); //不是Dog类型 System.out.println(transform(d)); //pers.mgg.demo.dt.Dog@15db9742}public static Object transform(Animal a){ // true 则向下转型 return a instanceof Dog ? (Dog)a : new String(\"不是Dog类型\");}}class Animal{}class Dog extends Animal{}class Cat extends Animal{} （代码已经验证结果，放心食用） 在类型转换时，食用 instanceof 来做逻辑判断是非常必要的。","link":"/2020/02/23/javabase37-instanceof/"},{"title":"JAVA零基础筑基到修仙（四）——运算符","text":"觉得上篇概念性的东西讲的太多了，参考了别的地方的资料，过了一天看了看感觉没必要将那么多概念，直接上代码加注释效果更佳，这篇讲运算符，分为算术运算符，赋值运算符，关系运算符，逻辑运算符，位逻辑运算符和三目运算符。 一、算数运算符故名思意，就是算数用的，加减乘除，分为一元和二元两种： 一元运算符一元运算符就是一个元素就可以用，有三个 -、++（自增运算符）、--（自减运算符），自增、自减一起带过，不再单独说。++a表示a=a+1,--a表示a=a-1，除了 - 其他两个有运算先后之分，在变量前面先计算,在变量后面则要运行完本条代码后再计算，举例： 1234567891011121314public class Test { public static void main(String[] args) { // TODO Auto-generated method stub int a = 1; System.out.println(-a);//取反 System.out.println(++a);//先运算a=a+1，再输出，输出2; a=2 System.out.println(a++);//先输出a,输出2,再运算a=a+1, a=3 System.out.println(--a);//先运算a=a-1,再输出，输出2; a=2, System.out.println(a--);//先输出a，输出2，再运算a=a-1, a=1; System.out.println(a);//输出a,a=1; }} 二元运算符就是常见的加减乘除等形式，另外还有求模。加减乘除的运算优先级和数学上是一样的，括号内有最高优先级。进行算术运算时应注意以下两点： 求余（％）运算要求参与运算的两个操作数均为整型，不能为其他类型。 两个整数进行除法运算，其结果仍为整数。如果整数与实数进行除法运算，则结果为实数。举个例子：1234567891011public class Test { public static void main(String[] args) { // TODO Auto-generated method stub int i = 2, j = 1; float k = 1f; System.out.println(j/i); System.out.println(k/i); }} 运行结果建议写几个加减乘除综合运算（带上取余），用上不同类型，看看结果是不是和想象中一样，光看或者复制我的代码是效果不会很好。 二、赋值运算符（=）赋值是这种格式 [变量名称=表达式内容] ，不要把 = 想象成数学中的等号，比如 a=b+1 要理解成将b+1的值赋予a,读代码顺序从右往左。赋值运算符可以与算数运算符组合，如 a+=2 等同于 a=a+2 下面列举了常用组合：这样的好处是让代码更简洁，易读，易维护，动手试一下： 12345678910111213141516public class Test { public static void main(String[] args) { // TODO Auto-generated method stub double price = 10.25; // 定义商品的单价，赋值为10.25 double total = 0; // 定义总价初始为0 int count = 2; // 定义购买数量，赋值为2 price -= 1.25; // 减去降价得到当前单价 count *= 5; // 现在需要购买10个，即原来数量的5倍 total = price * count; // 总价=当前单价*数量 System.out.printf(\"商品当前的单价为：%4.2f \\n\", price); // 输出当前单价 System.out.printf(\"购买商品的数量为：%d \\n\", count); // 输出购买数量 System.out.printf(\"总价为：%4.2f \\n\", total); // 输出总价 }} 运行结果 三、逻辑运算符（&amp;&amp;、||、!）逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。包含逻辑与、或、非和短路与、或。逻辑运算符是对布尔型变量进行运算，其结果也是布尔型：短路的意思举个例子解释一下： &amp;&amp; 与 &amp; 区别：如果 a 为 false，则不计算 b（因为不论 b 为何值，结果都为 false） || 与 | 区别：如果 a 为 true，则不计算 b（因为不论 b 为何值，结果都为 true） 在敲代码时基本很少用到逻辑与、或，常用的都是短路与、或，而且提倡多用短路，节省系统资源。 123456789101112131415161718public class Test { public static void main(String[] args) { // TODO Auto-generated method stub boolean a = true; boolean b = false; System.out.println(!a); System.out.println(a&amp;b); System.out.println(a&amp;a); System.out.println(a&amp;&amp;b); System.out.println(a&amp;&amp;a); System.out.println(a|b); System.out.println(a|a); System.out.println(a||b); System.out.println(a||a); }} 看看和自己想象中的结果是否相同。 四、关系运算符（比较运算符）关系运算符也叫比较运算符，一个字”比“。大于、小于、等于、不等于、小于等于、大于等于，相比结果为布尔型：关系运算符的优先级为：&gt;、&lt;、&gt;=、&lt;= 具有相同的优先级，并且高于具有相同优先级的 !=、==。关系运算符的优先级高于赋值运算符而低于算术运算符，结合方向是自左向右。关系表达式通常用于 Java 程序的逻辑判断语句的条件表达式中。使用关系表达式要注意以下几点： 运算符 &gt;=、==、！=、&lt;= 是两个字符构成的一个运算符，用空格从中分开写就会产生语法错误。例如 x&gt; =y; 是错误的，但是可以写成x &gt;= y; 在运算符的两侧增加空格会提高可读性。同样将运算符写反，例如 =&gt;、=&lt;、=! 等形式会产生语法错误。 由于计算机内存放的实数与实际的实数存在着一定的误差，如果对浮点数进行 ==（相等）或 !=（不相等）的比较，容易产生错误结果，应该尽量避免。 不要将“==”写成“=”。（在进行if条件判断时常会写错） 这里补充个以后写测试类经常会用到的类，控制台输入类$\\color{red}{ Scanner }$，打开jdk文档看一下，ctrl+f 搜索 scanner （百度也许更快，不过我觉得自己看文档更有逼格，人生不是为了装逼就毫无意义）：文档中给出了用法示例，以及各种方法接下来做个练习在控制台输入两个数比较大小（输完第一个数按回车输第二个）： 12345678910111213141516171819202122232425262728293031public class Test { public static void main(String[] args) { // TODO Auto-generated method stub int number1, number2; // 定义变量，保存输入的两个数 System.out.print(\"请输入第一个整数(number1)：\"); Scanner input = new Scanner(System.in); number1 = input.nextInt(); // 输入第一个数 System.out.print(\"请输入第二个整数(number2)：\"); input = new Scanner(System.in); number2 = input.nextInt(); // 输入第二个数 System.out.printf(\"number1=%d,number2=%d\\n\", number1, number2); // 输出这两个数 // 判断用户输入的两个数是否相等 if (number1 == number2) { System.out.println(\"number1 和 number2 相等。\"); } // 判断用户输入的两个数据是否相等 if (number1 != number2) { System.out.println(\"number1 和 number2 不相等。\"); // 判断用户输入的数1是否大于数2 if (number1 &gt; number2) { System.out.println(\"number1 大于 number2。\"); } // 判断用户输入的数1是否小于数2 if (number1 &lt; number2) { System.out.println(\"number1 小于 number2。\"); } } }} 运行结果这里面用到了if条件结构，到后面单独说一下吧。 五、位运算符位逻辑运算符位逻辑运算用于二进制数的计算，两个数对位上与、或、非、抑或、即位取反。上图：举个例子，计算5&amp;12，将计算过程画出来：看到对位上都为1该位对应的结果为1否则为零，最终计算结果转为十进制为4，那么或（|）运算是对应位置有1就得1，抑或运算（^）是对位相同为1，不同为0，取反（~）是对应位置直接取反，1变0，0变1，不再一一举例。 移位运算符（&gt;&gt;、&lt;&lt;）移位运算同样对于二进制来说的： &gt;&gt; 右移位 例8 &gt;&gt; 1结果为4 &lt;&lt; 左移位 例9 &lt;&lt; 2结果为36 练习下左移位运算：例如11 &lt;&lt; 1 结果为22发现左移一位结果时原来的二倍，根据二进制转十进制的计算方法，其实就是左移一位就乘二。同理右移一位是除二，不再一一举例。 复合位赋值运算符所有的二进制位运算符都有一种将赋值与位运算组合在一起的简写形式。复合位赋值运算符由赋值运算符与位逻辑运算符和位移运算符组合而成：其实和+=、-=、一样的理解方法，平时很少用到，不再举例了。 六、三目运算符（值=条件?表达式1:表达式2）判断是否符合条件，符合运行表达式1，不符合运行表达式2，得出结果。因为右三个因数，所以叫三目运算符，它相当于一个 if……else 条件结构，相比普通if条件结构代码简洁，执行效率高。 12345678910public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Scanner input = new Scanner(System.in); int i = input.nextInt(); System.out.println(i &gt; 10 ? \"i大于十\" :\"i小于十\"); }} 输入几个数试一下而且三目运算符支持嵌套，比如你可以把“i大于十”换成（ i&gt;15 ? “i大于十五” : “i大于十”），不再举例了。 小尾巴说了这么多运算符，web业务代码中位运算是很少用到的，可能嵌入式那边会更常用一些，不用背，多写代码就行。加油！！！","link":"/2020/02/07/javabase4-ysf/"},{"title":"JAVA零基础筑基到修仙（五）——条件结构","text":"条件结构和后面的循环结构统称为流程控制。条件结构式代码中最频繁使用的代码块，功能简单粗暴，有说去年再steam上大卖的《太吾绘卷》就是用一堆条件代码写的，哈哈哈谁知道是不是真的呢。 一、if……else……为什么需要条件结构，举个例子，过年小明家有邻居来拜年，邻居带着女儿，小姐姐甚是漂亮，小明想要搭话，那该怎么称呼呢，姐姐？还是小姐姐？这就需要来个年龄判断了: 123456789101112131415public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Scanner input = new Scanner(System.in); int mm = input.nextInt(); //小明今年10岁 int xm = 10; if (mm&gt;xm) { System.out.println(\"该叫姐姐\"); }else { System.out.println(\"该叫小姐姐\"); }} 小明10岁，妹妹9岁最简单的条件结构连else都不需要，符合条件就执行内部代码，不符合就直接跳过，当然如果有众多条件判断就要加入 else if 看格式： 1234if( ){ ...}else if( ) {... }.....else { ...} 花括弧中式代码段，如果只有一段代码（一段代码的意思是只有一个“;”）,那就不用加“{}”看：多段代码一定要加括弧，不然编译不通过，语法错误。有括弧就可以为所欲为，我可以在里面再写一个if语句，搞个嵌套，这种形式： 12345678910111213141516171819if(表达式1) { if(表达式2) { 语句块1; } else { 语句块2; }} else { if(表达式3) { 语句块3; } else if(表达式4) { 语句块4; } else { if(表达式n) { 语句块n; } else { 语句块n+1; } }} if条件结构较容易，多写几个练习就掌握了，比如说判断三个数中的最大值，请读者自己写一写，写好了那四个数呢，还有如果是多个条件一起做判断呢（提示多个条件需要用到“&amp;&amp;”、“||”，否定条件开头加“！”）？ 二、switch语句switch…case是多路分支语句，当然用if也可以达到一样的效果，但是当条件判断项众多时，大量的if…else大大降低了程序的可读性，通俗地说 if 是 两个路口的岔路，case是多个路口的岔路。switch语句的一般形式： 123456789101112131415switch(表达式) { case 值1: 语句块1; break; case 值2: 语句块2; break; … case 值n: 语句块n; break; default: 语句块n+1; break;} 其中，switch、case、default、break 都是 Java 的关键字。一一介绍一下： switch表示“开关”，这个开关就是 switch 关键字后面小括号里的值，小括号里要放一个整型变量或字符型变量。表达式必须为 byte，short，int，char类型。Java7 增强了 switch 语句的功能，允许 switch 语句的控制表达式是 java.lang.String 类型的变量或表达式。只能是 java.lang.String 类型，不能是 StringBuffer 或 StringBuilder 这两种字符串的类型。 case表示“情况，情形”，case 标签可以是： 类型为 char、byte、 short 或 int 的常量表达式。 枚举常量。注意：case 值不能重复 从 Java SE 7 开始， case 标签还可以是字符串字面量。 default表示“默认”，即其他情况都不满足。default 后要紧跟冒号，default 块和 case 块的先后顺序可以变动，不会影响程序执行结果。通常，default 块放在末尾，也可以省略不写。 break表示“停止”，即跳出当前结构。如果在 case 分支语句的末尾没有 break 语句，有可能触发多个 case 分支。那么就会接着执行下一个 case 分支语句。这种情况相当危险，常常会引发错误。所以不到非使用不可，咱不用这个。 举两个例子来结束switch的学习，一个正确用法，一个错误用法。小明期末考试结束，成绩90分以上算优秀，他妈说考一个优秀对应奖励一本寒假作业，一个都没有奖励3本，还有一顿打（小明太幸福了），小明这个寒假过的快不快乐呢？用switch语句演示一下。先来正确的： 12345678910111213141516171819202122232425public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"请输入小明获优个数：\"); int best = input.nextInt(); // 我们假设小明一共考三个科目。 if (best &gt; 3 || best &lt; 0) { System.out.println(\"小明：谢谢别乱输入！\"); return; } switch (best) { case 1: System.out.println(\"奖励一本\"); break; case 2: System.out.println(\"奖励两本\"); break; case 3: System.out.println(\"奖励三本\"); break; default: //0个 System.out.println(\"奖励三本，一顿毒打\"); break; } } 控制台输入2，看结果：如果忘了加break会怎样： 123456789101112131415161718192021public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"请输入小明获优个数：\"); int best = input.nextInt(); // 假设小明一共考三个科目。 if (best &gt; 3 || best &lt; 0) { System.out.println(\"小明：谢谢别乱输入！\"); return; } switch (best) { case 1: System.out.println(\"奖励一本\"); case 2: System.out.println(\"奖励两本\"); case 3: System.out.println(\"奖励三本\"); default: //0个 System.out.println(\"奖励三本，一顿毒打\"); } } 继续输入2：小明这下要高兴坏了呢，哈哈哈。忘记break，从匹配那条开始下面的代码都会执行，这是严重的逻辑错误。 另外代码中if判断的地方为要判断多个条件做了实例，用上了“||”短路或，还有花括号内部用了 return 。“return” 在Java中代表结束，在一个方法中，出现return意味着方法的结束，return 可用在任何方法里， return null/true/false/“”/… 则需要用在有返回值的方法里。方法前有“void”关键字 则说明无返回值，否则有返回值，需要返回什么类型的返回值就要把“void” 换成什么类型，简单举个例子： 12345678public static void main(String[] args) { String who = str();//声明变量来获得返回值 System.out.println(who); System.out.println(str());//也可以不用新建对象 }public static String str() { return \"This is kangkang\"; } 运行结果 三、if or switch ?if 和 switch 可以变通，那该怎么选择呢？理论上，条件分支越多，switch 的优势越明显，所以本着物尽其用的原则，在分支少的时候用 if ,分支多的时候用 switch 。 如果没有编程基础，确实不太容易接收，“我们无论遇到什么困难，都不要怕……加油！奥力给！！！”（巨魔吟唱）。随着内容越来越深入，代码越来越复杂，为保证写代码美观、快捷，在此说两个eclipse里常用快捷键，”Alt+/“代码提示，”ctrl+shift+f”代码自动格式化，以及自己设置 key 用 sout 回车打出 System.out.println，注释模板等；感兴趣可以去百度搜一搜，挺好玩的。 小尾巴每天一篇，坚持住，今天自己搭个gitlab+本地nginx看了一堆博客随便点开，内容图片都一样，我承认优秀博客不少，但是又相当多的博客都是整篇抄来抄去，自己都不去操作验证，导致找一个适合自己电脑环境而且方法完整正确好难好难，浪费了大量时间。我的知识也都是网络上学的，知道网络博客一大抄的坑，所以我想让我写的每篇博客的内容都有自己实践过，保证正确性。看csdn的博客真的太难了。","link":"/2020/02/08/javabase5-tjjg/"},{"title":"JAVA零基础筑基到修仙（六）——循环","text":"从这篇内容开始Java核心内容——循环结构的学习，日常生活中的循环很常见，墙上钟表的指针一圈一圈的不停的转是一种循环，人体内的水每时每刻都在循环，再如鲁迅曾经说过“人类的本质是复读机”，复读也是循环。本篇要求做到如下几点：理解循环含义;会用while结构;会用for/foreach结构。 一、while循环while循环的一般形式 123while(循环条件) { 循环操作} 循环条件判断为true他就一直循环直到为false为止，特点是先判断再执行。为了锻炼肾体，我每天都坚持做俯卧撑和深蹲，各做20个，别嘲笑我菜。用while来做20个俯卧撑， 12345678public static void main(String[] args) { // TODO Auto-generated method stub int i = 1; while(i &lt;= 20 ) { System.out.println(\"第\"+i+\"个俯卧撑！\"); i++; } } 运行结果就是这么简单，如果没有循环，我需要20个 System.out.println 改中间的数值烦死了，有没有发现，现在科技的的进步都是”懒“来驱动的，尤其在it行业，哈哈哈。趁热打铁，再做个练习，计算一下5门考试科目的平均成绩，具体哪科就不说了啊，控制台输入五个数求平均值。 1234567891011public static void main(String[] args) { // TODO Auto-generated method stub Scanner input = new Scanner(System.in); int i = 0,score = 0; while(i &lt; 5 ) { score += input.nextInt(); i++; } double avg = score/i; System.out.println(\"五科的平均分是：\"+avg); } 运行结果上面用的是 while 的常见形式，先判断后执行，它还有另一种先执行后判断的形式————“ do……while”形式，不过基本上很少用到。do……while循环的一般形式 1234do {循环操作}while(循环条件) 才做了20个俯卧撑，还有20个深蹲要做，用do……while来做一下 12345678public static void main(String[] args) { // TODO Auto-generated method stub int i = 1; do { System.out.println(\"第\" + i + \"个深蹲！\"); i++; } while (i &lt;= 20); } 有没有发现基本和上面while代码一模一样，还多了个do，所以用do……while多此一举，没必要，但是照顾到有些人善于顺时思维，有些人善于逆时思维，想用那个那个，可以达到一样的效果。 while的代码结构很简单，但是有需要特别注意的问题即使，在写循环条件时一定要谨慎，否则会出现死循环或者不执行循环操作，死循环会导致程序崩溃。 二、for 循环除了while循环，还有for循环，for循环的循环条件可以使用局部变量，也可以使用外部变量，当使用局部变量时，程序最多循环多少次是已知的，而while循环只能使用外部变量，无法判断循环多少次。for循环的一般形式 123for(赋值语句;条件语句;迭代语句){ 循环操作} 用for循环来做俯卧撑20下： 123456public static void main(String[] args) { // TODO Auto-generated method stub for (int i = 1; i &lt;= 20; i++) { System.out.println(\"第\"+i+\"个俯卧撑\"); } } 运行结果不一样的实现方法，和 while 循环对比记忆，效果更佳。另外，for 语句中赋值、循环条件以及迭代部分都可以为空语句（但分号不能省略），三者均为空的时候，相当于一个无限循环。来思考一下当赋值语句，条件语句，迭代语句分别为空时，做20个俯卧撑要怎么写。 赋值语句为空1234567public static void main(String[] args) { // TODO Auto-generated method stub int i = 1;//就是简单的放到外面 for (; i &lt;= 20; i++) { System.out.println(\"第\"+i+\"个俯卧撑\"); } } 条件语句为空（又见 break 关键字）123456789public static void main(String[] args) { // TODO Auto-generated method stub for (int i = 1;; i++) { if (i &gt; 20) break;//这里碰到了昨天在 switch 语句中出现的 break 关键字，在这里的作用是结束循环，如果没有它，没有循环条件限制，循环就会一直下去。 System.out.println(\"第\" + i + \"个俯卧撑\"); } } 迭代语句为空1234567public static void main(String[] args) { // TODO Auto-generated method stub for (int i = 1;i &lt;= 20;) { System.out.println(\"第\" + i + \"个俯卧撑\"); i++;//简单的放到里面就可以了 }} 三个代码都跑过了，没问题，不再上图了。请读者自己用for循环写个计算平均数的小程序，用上Scanner类，控制台输入数据。另外思考一下，空三个条件又该怎么写呢？（从三段代码里找答案） for 嵌套for 也是可以嵌套的，用来解决复杂的循环逻辑，比如冒泡排序，就要用到双层for循环，到后面再说冒泡排序，今天举个输出九九乘法表的例子： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub //外循环，第一个因数取值 for(int i = 1 ;i &lt;= 9 ; i++) { //内循环，第二个因数取值 for(int j = 1 ; j &lt;= i; j++) { //输出算式 System.out.print(i+\"*\"+j+\"=\"+i*j+\"\\t\"); } //换行 System.out.println(); } } 运行结果不仅可以嵌套两套，for可以嵌套任意多套，但是随着层数增加，算法复杂度指数增加，也很少有嵌套多层的算法需求。 三、forEach 循环forEach 循环时for循环的特殊形式，多用于数组、列表等数据结构迭代，非常好用。它的一般结构是： 123for(类型 变量名:集合) { 语句块;} 举个数组迭代的例子，还没讲到数据结构，但是在这里必须找个例子用，遍历一个字符串数组： 1234567public static void main(String[] args) { //举个字符串数组 String[] names = {\"kangkang\",\"tom\",\"john\"}; for(String name : names) { System.out.println(\"i am \"+name); }} 运行结果for绝对可以完成foreach的工作，但是用for遍历数组的话就要通过数组下标循环遍历，还是 foreach 好用，程序员”懒”就是生产力啊！循环结构就这么多内容，到这里，逻辑思考就多了起来，多多练习，祝早日变大佬！！ 小尾巴憋尿博客，部署完赶紧溜了。完整版“巨魔吟唱”：当我们遇到什么困难都不要怕，微笑着面对它，战胜困难的唯一办法就是面对困难，坚持就是胜利，加油！奥力给！！！","link":"/2020/02/09/javabase6-xh/"},{"title":"JAVA零基础筑基到修仙（七）——Debug","text":"人生病了找医生，而且“望闻问切”不再是中医的专利，医生只有对病人身体了解的够清楚，才能找出病灶所在。程序也是一样，随着代码越来越复杂，出了问题很难用眼找出来，特别是逻辑问题相当难找，程序问题称为“bug”，把给程序找毛病的行为叫“Debug”，中文叫调试。 咱们生病了有专门的医生看病，但是程序病了可没有专门帮你调bug的人，所以debug的事在是太重要了，说着我就打开了eclipse。eclipse 上 debug 的操作比较简单，先使用debug来查看一下程序如何运行，变量如何变化，熟悉一下使用到的各个按钮，用一个简单的循环，昨天的俯卧撑：使用调试首先要打断点，在代码行最前双击，举个最简单的例子，看一下循环中，变量 i 如何变化：因为当前代码里没有实例方法调用，直接点下一步就行了step into 用在比如有一行代码是 jump()方法 可以通过into 跳到jump()方法内部查看。这里直接点step over就行了。偶们知道了，i++后，i增加了1。疯狂点完二十下好了本次debug就算完成了，最重要的是要在debug中观察变量的变化是否符合逻辑，通常都会有恍然大悟的感觉。后面我回再补充遇到问题代码如何调试，本篇先告诉读者有这个东西，简单怎么使用。（我实在熬不动了） 小尾巴今天想把博客从github移到服务器上，本来想用gitlab的，但是调了半天搭好gitlab，page页总是配不好，不能用，最后晚上放弃了，采用了git仓库+nginx的方法，也有很多坑要填，熬到现在，熬不动了，特殊时期不敢生病啊。晚安！！","link":"/2020/02/10/javabase7-debug/"},{"title":"JAVA零基础筑基到修仙（八）——字符串处理（1）","text":"在敲第一个Java程序”Helloworld”的时候就用到了字符串，后面程序举例中很多动作直接用字符串模拟，字符串广泛应用于日常编程，Java中无内置字符串类型，提供了 一个专门创建和操作的类 String ，单独拿出来说一说。由于内容较多，需要一点一点讲，本篇内容包括字符串的定义与获取字符串长度，字符串拼接，String 类型与 int 类型转换。 一、字符串的定义字符串有两种定义方式，直接定义和使用 String 类定义，无论是哪种定义方式，它的所有对象都是不可变对象，变量值的每一次改变都会指向一个新的对象，旧的对象还在内存里面（前面提到过引用型数据内存存储方法筑基到修仙（三））。 简单说明一下，Java内存有一块特殊的区域，常量池，在编译时用来存储 final型数据和对象字面量，String类型数据就是对象字面量，常量池专门存储这些在编译时就已经能够确定的数据，防止频繁的创建于销毁对象，影响内存性能。有兴趣就要去详细了解虚拟机内存机制，对后期提升有帮助，我也只是略懂皮毛,下面说一下我对这个不可变对象的理解。 在介绍数据类型时说过，内存内分为堆和栈，而引用型将变量名存放于栈上，使用指针指向位于堆上的对象，结合常量池举个例子比如： 首先有 String str = “abc” ， 新建另一个变量时 Sting str1 = “abc” 会现在常量池中搜索是否有”abc”,如果有就不会创建新的对象，只是添加一个指针引用。当变量重新赋值 str = “def” ，就会修改指针指向（常量池有就直接指向，没有就新建“def”对象），但是内存堆中 “abc” 依然存在，所以现在这个str与原str是两个对象。 用 String str3 = new String(“abc”) 这种方式创建，至少产生了一个对象，编译时会在常量池中查找是否有”abc”,有就指向，没有就创建，在运行时因为有 new 又会重新创建一个“abc”对象，所以说至少创建了一个，可能创建了俩对象。举个例子更清楚： 1234567String str1 = &quot;abc&quot;;String str2 = &quot;abc&quot;;String str3 = new String(&quot;abc&quot;);System.out.println(str1 == str2); //trueSystem.out.println(str1 == str3); //falsestr2 = &quot;bcd&quot;;System.out.println(str1 == str2); //false 这里面又有一个坑就是字符串使用”==”比较其实是比较对象，只比较字符串值得话在后面筑基到修仙（十）再做详细说明。 直接定义字符串直接定义就是使用 “” 号，引号内部是字符串内容，既可以直接声明变量与值，也可以先声明变量再赋值，举例如下： 直接赋值1String str = \"Oh!owesome!\" 先声明变量再赋值12String str;str = \"Oh!owesome!\" 字符串必须经过初始化才可以使用12345public static void main(String[] args) { // TODO Auto-generated method stub String str; System.out.println(str);//The local variable str may not have been initialized} 举一个正常使用的例子：12345678public static void main(String[] args) { // TODO Auto-generated method stub String str; str = \"Oh!awesome!\"; String str1 = \"这是我独享的moment\"; System.out.println(str); System.out.println(str1);} 使用 String 类定义（包含了使用.length 方法获取字符串长度）直接定义的字符串和使用 String 类定义产生的都是 String 类对象，打开jdk API帮助文档来认识一下这个 String 类。首先说明是 String 类的身份信息和初始化示例：然后是构造方法摘要，包含构造方法和众多重载构造方法（重载后面再说，就是和构造方法名相同，参数不同）：方法摘要，包含当前jdk支持的所有方法，jdk版本不同包含的方法不一样，有的会过时，也有会新增，但是不会有特别大的变化，通过 对象.方法（）; 调用。最后是构造详解与方法详解：通过例子学习如何使用 String 类，和 String 类方法，下面代码使用了获取字符串长度的类方法，获取字符串长度在很多地方非常重要，比如数据迭代，数据输入长度限制等： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub String str = new String(); str = \"i am kangkang\"; String str1 = new String(\"i am jhon\");//使用重载构造方法 int long1 = str.length();//调用length方法获取字符串长度 int long2 = str1.length(); System.out.println(str); System.out.println(str1); System.out.println(\"str的长度是：\"+long1); System.out.println(\"str1的长度是：\"+long2);} 运行结果还有其他常用构造方法，比如用字符数组初始化字符串，再此不再举例，读者自己练一下，体会一下如何使用帮助文档（字符数组声明 char[] ch ={‘a’,’a’,’b’} 或者 {56，80} 看一下如果里面不带单引号的数字输出时什么，涉及到ASCII码知识）。 说一下另两个也会用到的字符串类 StringBuffer 和 StringBuilder： 这两个类最常用的是StringBuffer，一句话表述两个的区别是，StringBuffer 为线程安全类，StringBuilder 非线程安全类，因为还没说到线程我们不多做解释，字面意思，两个类功能差不多的化你使用哪个，肯定是安全的那个，所以通常 StringBuilder 很少用到。 因为有文档，不在这里长篇叙述 StringBuffer 类的各种信息，只说什么时候使用，使用时与 String 类有什么不同： StringBuffer 类是需要特别长字符串的时候使用，比如要通过字符串写一段超长的SQL语句（数据库查询语言），由于内存存储机制，使用 String 类对象可能会导致内存性能下降(说是这么说，我到现在还没遇到过出问题)，这时候用 StringBuffer。buffer的意思是缓冲区，就是在创建对象时就创建缓冲区，对内存进行优化。 String 对象可以直接赋值，而且对象不可变（在内存中栈的位置不变，变得是堆中数据得位置），改变对象值就相当于建了一个新的对象。StringBuffer 需要通过构造方法来初始化，而且对象可变，值得改变不会新建对象，不会浪费内存性能，所以当有大量需要拼接得字符串时推荐使用StringBuffer。 最常用得不同点，拼接方法不同，StringBuffer 不能用 “+”拼接，需要append()方法。写个Demo:1234567891011 public static void main(String[] args) { // TODO Auto-generated method stub StringBuffer str = new StringBuffer(\" i am kangkang ,\"); str .append(\"i am a handsome boy\"); //拼接方法也不一样 String str1 = \" i am sicong ,\"; str1 += \"i am rich\"; System.out.println(str); System.out.println(str1); }&gt; 运行结果 二、字符串拼接在开发中字符串拼接的需求太多了，比如说参数传过来人员相关数据，需要拼接各个属性成为一个完整的句子，来实践一下吧。 String 类型字符串使用 “+” 来拼接，这个方法用过很多次了，不举例了。 String 类型字符串使用concat（）方法来拼接，这个还没有提到过，从他开始吧：12345678910public static void main(String[] args) { // TODO Auto-generated method stub String[] person = { \" he was \", \" kangkang,\", \" handsome \", \" and \", \"rich\" }; String boy = \"the boy said that:\"; for (String str : person) { // boy += str ; boy = boy.concat(str);// 与“+”效果一样 } System.out.println(boy);} 结果和 + 效果没有区别这两种方法喜欢哪种用哪种。 StringBuffer 刚才说过了，使用 append（） 方法也不再举例了。 其他类型与字符串拼接，直接拼就行了，其他类型会自动转为字符串类型（隐式转换），有不能拼的编译器会给提示：123456789public static void main(String[] args) { // TODO Auto-generated method stub int i = 100; double d = 0.99; char c = 'A'; boolean b = true ; float f = 9.9999f; System.out.println(\"test is \"+i+d+c+b+f);} 三、String 与 int 类型转换 首先说 String 类型转 int 类型，有两种方法： 使用 Integer 类，Integer 是 int 的封装类，它提供了类型转换的方法，Integer.parseInt(str)； Integer.valueOf(str).intValue()，同样是用到 Integer 类。12345678910public static void main(String[] args) { // TODO Auto-generated method stub String str = \"100\"; int i = Integer.parseInt(str); int j = Integer.valueOf(str).intValue(); ++i; j += 2; System.out.println(\"i = \" + i); System.out.println(\"j = \" + j);} 然后是 int 转 String 有三种方法： 简单粗暴直接使用 String i=i+””, 用字符串拼接; 使用Integer.toString(i); 使用String().valueOf(i);12345678910public static void main(String[] args) { // TODO Auto-generated method stub int i = 100; String str1 = i + \"\"; String str2 = Integer.toString(i); String str3 = String.valueOf(i); System.out.println(\"str1:\"+str1); System.out.println(\"str2:\"+str2); System.out.println(\"str3:\"+str3);} 这些个方法都是Java开发人员慢慢添加上来的，如果愿意你可以 ctrl+左击 点到方法内部去看看，领会一下开发精神，学习一下代码逻辑，之所以现在Java这么好用，完全是因为我们站在巨人的肩膀上啊，那现在Java不足的地方就靠我们了，加油，奥里给！！ 小尾巴全国疫情都在慢慢好转了，这几天我这里小区封门无法出去，加上年前宅了几天我有将近20天没出门了，不过早已习惯，上学时除了上课可以一个月不出宿舍，已经练出来了，但是当我都感觉到有些宅时，其他人应该都有些受不了了吧，哈哈哈！","link":"/2020/02/11/javabase8-zfccl1/"},{"title":"JAVA零基础筑基到修仙（九）——字符串处理（2）","text":"接着上篇字符串处理继续,本篇内容包括字符串的大小写转换、除去空格、子字符串提取、分割和替换。讲这些方法的目的不是记住这个方法如何使用，而是在于看过后心里能有个印象，有这个方法可以用，下次有用到时直接去查文档就行了，由于不想篇幅过长，还剩字符串比较和查找，下一篇再说。 一、字符串大小写转换Java 提供 toLowerCase() 和 toUpperCase() 两个方法分别用来转小写与转大写，转换时其他字符串不会受到影响： 大写转小写 toLowerCase()使用方法： 1str.toLowerCase(); 例如 12345 public static void main(String[] args) { // TODO Auto-generated method stub String str = \"Oh!Awesome!!\"; System.out.println(str.toLowerCase());} 运行结果: 小写转大写 toUpperCase()1str.toUpperCase(); 例如： 12345public static void main(String[] args) { // TODO Auto-generated method stub String str = \"Oh!Awesome!!\"; System.out.println(str.toUpperCase());} 运行结果: 二、字符串除去空格这种需求通常再数据要标准化的时候用到，如果传了头尾有空格的数据放入有长度限制数据库，会导致数据库报异常，然而用眼看不出来（我曾经被这样的数据害惨了，一个bug调半天），Java提供 trim() 方法除去空格（我门说的空格在字符串的头尾）。 1str.trim(); 例如： 1234567public static void main(String[] args) { // TODO Auto-generated method stub String str = \" Oh!Awesome!! \"; //借用长度表现 System.out.println(str.length()); System.out.println(str.trim().length());} 运行结果： 三、提取子字符串比如你需要从一个身份证号截取到籍贯、出生日期等信息,Java提供了 substring() 方法来解决这个问题。 1234//范围有前有后str.substring(int beginIndex,int endIndex);//范围只有开始str.substring(int beginIndex); 需要注意的是，substring()方法 beginIndex 从 0 开始，而 endIndex 从 1 开始，使用时要特别注意。然后还要注意其他语言也有substr方法，参数可能不一样别搞混。 例如从身份证提取信息： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub String personId = \"130523202001012233\"; String city = \"\"; String birth = personId.substring(6, 14);// 20200101 // 预习一下这个字符串比较方法equals（），后面专门说一下 if (personId.substring(0, 6).equals(\"130523\")) { city = \"河北省邢台市\"; } System.out.println(\"这个人的籍贯是：\" + city); System.out.println( \"这个人的出生日期是：\" + birth.substring(0, 4) + \"年\" + birth.substring(4, 6) + \"月\" + birth.substring(6) + \"日\");} 运行结果 四、字符串分割字符串中包含几个人名用逗号隔开了，现在需要分割开，Java提供了 split() 方法。 1234//需要数组来接收很好理解String[] strs = str.split(String sign);//limit 可以限制个数String[] strs = str.split(String sign , int limit); 例如： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub String str = \"kangkang,john,jan\"; String[] names = str.split(\",\"); String[] names1 = str.split(\",\",2); for(String name : names) { System.out.println(name); } System.out.println(\"~~~~~~~~~~~~~~~~~~~~~~~~~~\"); for(String name : names1) { System.out.println(name); }} 运行结果可以看到如果限制个数的话，最后一个元素是切割剩下的所有字符串。 如果字符串是用 “.”或“|” 来分割的，以为他俩都是转义字符，需要在加上“\\\\”,如“\\\\.”、“\\\\|”,如果 str.split(“”) ,得到的是一个一个单个字符。 五、字符串的替换Java为字符串替换提供了三个方法，分别是 replace()、replaceFirst() 和 replaceAll()。 replace()1str.replace(String oldChar, String newChar); 例如一个经过简单加密的密码 “1$2$3$4$5$6$7$8$9”,需要转换为正常密码 “123456789” ： 123456public static void main(String[] args) { // TODO Auto-generated method stub String str = \"1$2$3$4$5$6$7$8$9\"; String pwd = str.replace(\"$\", \"\"); System.out.println(pwd);} 运行结果 replaceFirst()replaceFirst() 方法用于将目标字符串中匹配某正则表达式的第一个子字符串替换成新的字符串，其语法形式如下： 1str.replaceFirst(String regex, String replacement); 其中，regex 表示正则表达式；replacement 表示用于替换的字符串。例如： 123456public static void main(String[] args) { // TODO Auto-generated method stub String words = \"i am kangkang,i am rich ,kangkang is rich\"; String newStr = words.replaceFirst(\"rich\", \"poverty\"); System.out.println(newStr);} 运行结果 ： replaceAll()看方法名就知道，相对 replaceFirst 这是个完全替换的方法： 1str.replaceAll(String regex, String replacement); 继续使用上面的例子： 123456public static void main(String[] args) { // TODO Auto-generated method stub String words = \"i am kangkang,i am rich ,kangkang is rich\"; String newStr = words.replaceFirst(\"rich\", \"poverty\"); System.out.println(newStr);} 运行结果： 小尾巴看新闻新冠肺炎确诊数已经连续7天下降了，感谢广大医疗工作者的付出，我在家啥也帮不上真是惭愧！","link":"/2020/02/12/javabase9-zfccl2/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Java字符串处理","slug":"Java字符串处理","link":"/tags/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"name":"Java数字处理","slug":"Java数字处理","link":"/tags/Java%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86/"},{"name":"Java内置包装类","slug":"Java内置包装类","link":"/tags/Java%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB/"},{"name":"Java时间日期处理","slug":"Java时间日期处理","link":"/tags/Java%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"},{"name":"Java数组","slug":"Java数组","link":"/tags/Java%E6%95%B0%E7%BB%84/"},{"name":"Java面向对象","slug":"Java面向对象","link":"/tags/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"Java继承多态","slug":"Java继承多态","link":"/tags/Java%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81/"}],"categories":[{"name":"Java基础学习","slug":"Java基础学习","link":"/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]}