{"pages":[{"title":"关于Mgg","text":"大家好，我是Mgg，一个工作一年多的本科JAVA程序猿，资质平平没什么可吹嘘的。做这个博客的目的是整理与复习自己的知识，相对于看书写云笔记，自己搭个博客效果肯定更好(在不懂的朋友面前装逼哈哈哈)，如果无意中帮助到您，那可真是幸会幸会。这个博客现在用的是github的代理，后续我会把它搭到自己的服务器，然后争取也搞个微信公众号。博客内容基本自己写，不过难免有引用，如有侵权请及时邮箱联系（邮箱地址首页小信封）。 我的微信公众号我的其他站点","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"分类","text":"","link":"/categories/index.html"}],"posts":[{"title":"JAVA零基础筑基到修仙（一）——JAVA简介","text":"虽然是复习Java知识，可能过于基础的前几个博客都没有必要写，但是本着善始善终原则，以及本身是强迫症患者，所以力求做到尽善尽美，还是写出来吧。书回正传，本篇博客将简单介绍关于JAVA的基础知识，用处不大，我尽量缩短篇幅，减少不必要的时间浪费。 了解JAVA语言一句话介绍：Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。Java为什么叫”Java“,上图解释更为直观，我们只说些有趣的，百度百科几万字大概很少有人全看完：远古图片看起来辣眼睛？你们说这爪洼岛它大吗？它不是大不大，它是那种很……打住，先上一张图这是Java的logo，他看上去是一杯热气腾腾的咖啡，所以这和爪洼岛有什么关系？爪洼岛属于印尼，印尼是世界几大咖啡产地之一，爪哇岛上生产的少量Arabica原种咖啡豆，曾是世界级的优良品种。那为什么就要用”Java“来命名这门语言呢？大概Java缔造者们钟情与这种咖啡吧。听起来像那么回事哈，其实就是这么回事，只是他们原本要注册为“Ock”橡树，但是这个商标被注册了，这才有了Java。 Java诞生之初也是Internet兴起之时，在Java出现以前，几乎没有工具可以在Internet上执行动态交互程序，因此Java对Internet的发展产生了巨大的影响，Internet使Java成为网络上最流行的编程语言（确信）。（我们通常也说Java长于web）下面我们说说Java的相关知识（想到什么写什么）： Java是一种面向对象的语言（相对于C语言，C语言是面向过程的语言）； Java程序的类型是Application，即可以运行在控制台，也可以运行在图形界面； Java运行在虚拟机（JVM）中，让它成为跨平台语言，即：编写一次，随处运行；（虚拟机很吊，一定要单独学学，技术大佬必备） Java语言编写的Applet程序可以对用户的输入和操作作出响应； Applet是用Java编写，在Internet上运行的程序，可以在任何客户端系统上下载，在浏览器中运行； Java不仅适用于单机应用程序和基于网络的程序，也可用于创建消费类设备的附件程序，如移动电话、掌上设备等； 开发和运行Java程序，必须依赖和使用由Sun公司提供的Java开发工具包（Java Development Kit，我们常说的JDK）； 为适应不同的用途，又将其细分为三个版本：JavaSE（标准版，适用于普通应用程序的开发）、JavaEE（企业版，适用于大型企业级应用程序的开发）、JavaME（微型版，适用于移动设备或嵌入式设备的程序开发）。 能想到的基础点就这些，上面罗列这些每一条都有很多文章，我还是个弟弟程序猿，不能把这些牛逼的东西一一详细描述，还是要多学习啊（叹气）。 Java从1995年正式发布到现在已经过了25年了，它凭借自身的通用性、高效性、平台移植性以及安全性站在了编程语言排行榜的顶峰（2018、2019年排行数据，其实已经蝉联好几年了），Java是世界上最好的编程语言（确信233），所以为什么不学Java？ 小尾巴这是我第一篇博客，理科生也没有那么多华丽的辞藻，内容肯定也不能谈得上好，写博客这些开源框架还都是现学现卖，事实上看我博客也就图一乐，真要学习还是要找菜鸟教程，可是谁没有第一次呢，是吧（试着给自己打气）。接下来会带来环境安装与第一个Java程序”Hello world“（学习语言传统艺能）以及后续开发IDE工具介绍，待续……","link":"/2020/02/04/javabase1-jj/"},{"title":"JAVA零基础筑基到修仙（十）——字符串处理（3）","text":"本篇内容：字符串的比较和查找。字符串比较在代码中非常常见，多用于判断和验证，如根据字符串内容执行不同的代码，验证是否符合逻辑规则否则抛出异常等等，下面我们根据实际方法来说一下。 字符串比较字符串比较是否相等，比较大小，比较前缀后缀，非常常见，Java为我们提供了三个字符串比较方法，分别是equals() 方法、equalsIgnoreCase() 方法、 compareTo() 方法，方法的返回值都是布尔类型（boolean），下面我们分开介绍。 equals()只比较两个字符串的值是否相等，用法： 1str1.equals(str2); 比如小羊们需要验证是谁在敲门： 12345678910public static void main(String[] args) { // TODO Auto-generated method stub Scanner input = new Scanner(System.in); String str = input.nextLine(); if(\"mother\".equals(str)) { System.out.println(\"open the door\"); }else { System.out.println(\"call 110\"); }} 运行结果 这里我们说一下 equals() 与 “ == “的区别，equals() 比较的是字符串的内容，而” == “比较的是对象实例，使用” == “比较两个对象即使字符串相同，返回结果也会是 false，简言之基础类型用==，String 类型用 equals()。举个例子： 1234567891011public static void main(String[] args) {// TODO Auto-generated method stubString str1 = \"abc\";String str2 = new String(\"abc\");//基础类型数据使用 == 比较int i = 10;int j = 10;System.out.println(str1.equals(str2)); //trueSystem.out.println(str1 == str2); //falseSystem.out.println(i == j); //true} equalsIgnoreCase()本方法与 equals() 用法形式相同，用法区别于笨方法不区分大小写，我想不需要举例解释了吧。 compareTo()比较两个字符串谁大谁小，形式： 1str.compareTo(String otherstr); str 值在参数 otherstr 值前 结果为负，否则为正，两个字符串相等结果为零，举例： 123456public static void main(String[] args) { // TODO Auto-generated method stub String str1 = \"abc\"; System.out.println(str1.compareTo(\"bcd\")); System.out.println(str1.compareTo(\"abc\"));} 运行结果 字符串查找String 类的 indexOf() 方法和 lastlndexOf() 方法用于在字符串中获取匹配字符（串）的索引值。 indexOf()indexOf() 方法用于返回字符（串）在指定字符串中首次出现的索引位置，如果能找到，则返回索引值，否则返回 -1。该方法主要有两种重载形式： 12str.indexOf(value);str.indexOf(value,int fromIndex); 其中，str 表示指定字符串；value 表示待查找的字符（串）；fromIndex 表示查找时的起始索引，如果不指定 fromIndex，则默认从指定字符串中的开始位置（即 fromIndex 默认为 0）开始查找。举个例子： 12345678public static void main(String[] args) { // TODO Auto-generated method stub String str = \"hello world\"; int i = str.indexOf(\"o\"); int j = str.indexOf(\"o\",5); System.out.println(i); System.out.println(j);} lastlndexOf()lastIndexOf() 方法用于返回字符（串）在指定字符串中最后一次出现的索引位置，如果能找到则返回索引值，否则返回 -1。该方法也有两种重载形式： 12str.lastIndexOf(value)str.lastlndexOf(value, int fromIndex) lastIndexOf() 方法的查找策略是从右往左查找，如果不指定起始索引，则默认从字符串的末尾开始查找。举例： 12345678public static void main(String[] args) { // TODO Auto-generated method stub String str = \"hello world\"; int i = str.lastIndexOf(\"o\"); int j = str.lastIndexOf(\"o\",5); System.out.println(i); System.out.println(j);} 补充：根据索引查找String 类的 charAt() 方法可以在字符串内根据指定的索引查找字符，形式： 1str.charAt(int index); 例如： 123456public static void main(String[] args) { // TODO Auto-generated method stub String str = \"hello world\"; char c = str.charAt(6); System.out.println(c);} 小尾巴字符串处理写完了，方法众多不可能说全部记下来，多练的意义在于加深印象，遇到相关需求的时候知道有这么个方法可以解决问题，不要到时候发出“这可咋办的呼喊”，又到深夜了，加油！奥利给！！！","link":"/2020/02/12/javabase10-zfccl3/"},{"title":"JAVA零基础筑基到修仙（十三）——时间日期处理（Date、Calendar、时间格式化）","text":"在开发中做数据持久化时常常需要统一的时间格式，统一查询口径，方便查询，Java提供了日期处理类 Date 和 Calendar ，Date类封装了系统时间，Calendar 根据系统日历解释 Date 对象，两个类处理时间的思路不一样。本篇内容包括：Date 类与 Calendar 类使用介绍，日期格式化 Date 类类 Date 表示特定的瞬间，精确到毫秒(Java中还有一个 Date 类，全称为java.sql.Date,这个类是sql相关时间类，我们平时用到的是java.util.Date,导包的时候注意别导错了)。它表示时间的顺序是星期、月、日、小时、分、秒、年。打开jdk帮助文档，我们发现 Date 类未过时的构造方法有两个，分别是： Date() 分配 Date 对象并初始化此对象，以表示分配它的时间（精确到毫秒）。 Date(long date) 分配 Date 对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即 1970 年 1 月 1 日 00:00:00 GMT）以来的指定毫秒数。举个例子：123456public static void main(String[] args) { Date d1 = new Date(); Date d2 = new Date(80000000); System.out.println(d1); System.out.println(d2);} 同样我们看到文档中大量方法已经过时，我在下面整理出来可以正常用的： 方法 说明 boolean after(Date when) 判断此日期是否在指定日期之后 boolean before(Date when) 判断此日期是否在指定日期之前 int compareTo(Date anotherDate) 比较两个日期的顺序 boolean equals(Object obj) 比较两个日期的相等性 long getTime() 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来，此 Date 对象表示的毫秒数 String toString() 把此 Date 对象转换为以下形式的 String: dow mon dd hh:mm:ss zzz yyyy。其中 dow 是一周中的某一天(Sun、Mon、Tue、Wed、Thu、Fri 及 Sat) 做个练习： 12345678910public static void main(String[] args) { Date d1 = new Date(); Date d2 = new Date(80000000); System.out.println(d1.after(d2)); System.out.println(d1.before(d2)); System.out.println(d1.compareTo(d2));// 相等返回 0 大于返回1 小于返回-1 System.out.println(d1.equals(d2)); System.out.println(d1.getTime()); System.out.println(d1.toString());} 运行结果 Calendar 类Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等 日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间 1970 年 1 月 1 日的 00:00:00.000，格里高利历）的偏移量。 因为 Calendar 是一个抽象类，无法像普通类一样 new 一个对象出来，它提供了 getInstance() 方法来完成对象创建： 1Calendar c = Calendar.getInstance(); Calendar 提供了众多时间处理方法，我们有个大致了解： 方法 说明 void add(int field, int amount) 根据日历的规则，为给定的日历字段 field 添加或减去指定的时间量 amount boolean after(Object when) 判断此 Calendar 表示的时间是否在指定时间 when 之后，并返回判断结果 boolean before(Object when) 判断此 Calendar 表示的时间是否在指定时间 when 之前，并返回判断结果 void clear() 清空 Calendar 中的日期时间值 int compareTo(Calendar anotherCalendar) 比较两个 Calendar 对象表示的时间值（从格林威治时间 1970 年 01 月 01 日00 时 00 分 00 秒至现在的毫秒偏移量），大则返回 1，小则返回 -1，相等返回 0 int get(int field) 返回指定日历字段的值 int getActualMaximum(int field) 返回指定日历字段可能拥有的最大值 int getActualMinimum(int field) 返回指定日历字段可能拥有的最小值 int getFirstDayOfWeek() 获取一星期的第一天。根据不同的国家地区，返回不同的值 static Calendar getInstance() 使用默认时区和语言坏境获得一个日历 static Calendar getInstance(TimeZone zone) 使用指定时区和默认语言环境获得一个日历 static Calendar getInstance(TimeZone zone,Locale aLocale) 使用指定时区和语言环境获得一个日历 Date getTime() 返回一个表示此 Calendar 时间值（从格林威治时间 1970 年 01 月 01 日 00 时00 分 00 秒至现在的毫秒偏移量）的 Date 对象 long getTimeInMillis() 返回此 Calendar 的时间值，以毫秒为单位 void set(int field, int value) 为指定的日历字段设置给定值 void set(int year, int month, int date) 设置日历字段 YEAR、MONTH 和 DAY_OF_MONTH 的值 void set(int year, int month, int date, int hourOfDay,int minute, int second) 设置字段 YEAR、MONTH、DAY_OF_MONTH、HOUR、 MINUTE 和 SECOND 的值 void setFirstDayOfWeek(int value) 设置一星期的第一天是哪一天 void setTimeInMillis(long millis) 用给定的 long 值设置此 Calendar 的当前时间值 Calendar 对象可以调用 set() 方法将日历翻到任何一个时间，当参数 year 取负数时表示公元前。Calendar 对象调用 get() 方法可以获取有关年、月、日等时间信息，参数 field 的有效值由 Calendar 静态常量指定。 Calendar 类中定义了许多常量，分别表示不同的意义。 Calendar.YEAR：年份。 Calendar.MONTH：月份。 Calendar.DATE：日期。 Calendar.DAY_OF_MONTH：日期，和上面的字段意义完全相同。 Calendar.HOUR：12小时制的小时。 Calendar.HOUR_OF_DAY：24 小时制的小时。 Calendar.MINUTE：分钟。 Calendar.SECOND：秒。 Calendar.DAY_OF_WEEK：星期几。 例如我们要获取当前月份： 1int month = Calendar.getInstance().get(Calendar.MONTH); 方法都用用： 123456789101112131415161718192021222324252627282930public static void main(String[] args) { Calendar calendar = Calendar.getInstance(); // 如果不设置时间，则默认为当前时间 calendar.setTime(new Date()); // 将系统当前时间赋值给 Calendar 对象 System.out.println(\"现在时刻：\" + calendar.getTime()); // 获取当前时间 int year = calendar.get(Calendar.YEAR); // 获取当前年份 System.out.println(\"现在是\" + year + \"年\"); int month = calendar.get(Calendar.MONTH) + 1; // 获取当前月份（月份从 0 开始，所以加 1） System.out.print(month + \"月\"); int day = calendar.get(Calendar.DATE); // 获取日 System.out.print(day + \"日\"); int week = calendar.get(Calendar.DAY_OF_WEEK) - 1; // 获取今天星期几（以星期日为第一天） System.out.print(\"星期\" + week); int hour = calendar.get(Calendar.HOUR_OF_DAY); // 获取当前小时数（24 小时制） System.out.print(hour + \"时\"); int minute = calendar.get(Calendar.MINUTE); // 获取当前分钟 System.out.print(minute + \"分\"); int second = calendar.get(Calendar.SECOND); // 获取当前秒数 System.out.print(second + \"秒\"); int millisecond = calendar.get(Calendar.MILLISECOND); // 获取毫秒数 System.out.print(millisecond + \"毫秒\"); int dayOfMonth = calendar.get(Calendar.DAY_OF_MONTH); // 获取今天是本月第几天 System.out.println(\"今天是本月的第 \" + dayOfMonth + \" 天\"); int dayOfWeekInMonth = calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH); // 获取今天是本月第几周 System.out.println(\"今天是本月第 \" + dayOfWeekInMonth + \" 周\"); int many = calendar.get(Calendar.DAY_OF_YEAR); // 获取今天是今年第几天 System.out.println(\"今天是今年第 \" + many + \" 天\"); Calendar c = Calendar.getInstance(); c.set(2008, 8, 8); // 设置年月日，时分秒将默认采用当前值 System.out.println(\"设置日期为 2008-8-8 后的时间：\" + c.getTime()); // 输出时间} 运行结果： 到后面我们专门写个日历的博客，以现在的进度放在这里写有点不合适（先挖个坑）。 日期格式化大多数时候我们不能直接使用 Date 类提供的时间格式，Date 原时间格式用的最多的时候应该是写系统日志，这是专门给人看的，只要可以分辨就可以了。但是大多数业务逻辑下，时间都是要存入数据库，要通过时间来查询，如果直接存时间戳进去，数据库sql写着比较麻烦，还要转格式，比如我把日期用String格式存起来（20200214000000），写查询sql的时候就可以直接用了。 Java为我们提供了 DateFormat 类和它的子类 SimpleDateFormat 类来完成日期格式化，下面我们一起来看一看。 DateFormat 类DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。将日期表示为 Date 对象，或者表示为从 GMT（格林尼治标准时间）1970 年 1 月 1 日 00:00:00 这一刻开始的毫秒数。 因为是抽象类，所以也不能使用 new 来创建实例对象，使用静态类方法 getDateInstance() : 1DateFormat df = DateFormat.getDatelnstance(); 创建完对象，我们来看一下它的类方法： 方法 说明 String format(Date date) 将 Date 格式化日期/时间字符串 Calendar getCalendar() 获取与此日期/时间格式相关联的日历 static DateFormat getDateInstance() 获取具有默认格式化风格和默认语言环境的日期格式 static DateFormat getDateInstance(int style) 获取具有指定格式化风格和默认语言环境的日期格式 static DateFormat getDateInstance(int style,Locale locale) 获取具有指定格式化风格和指定语言环境的日期格式 static DateFormat getDateTimeInstance() 获取具有默认格式化风格和默认语言环境的日期/时间格式 static DateFormat getDateTimeInstance(int dateStyle,int timeStyle) 获取具有指定日期/时间格式化风格和默认语言环境的日期/时间格式 static DateFormat getDateTimeInstance(int dateStyle,int timeStyle,Locale locale) 获取具有指定日期/时间格式化风格和指定语言环境的日期/时间格式 static DateFormat getTimeInstance() 获取具有默认格式化风格和默认语言环境的时间格式 static DateFormat getTimeInstance(int style) 获取具有指定格式化风格和默认语言环境的时间格式 static DateFormat getTimeInstance(int style,Locale locale) 获取具有指定格式化风格和指定语言环境的时间格式 void setCalendar(Calendar newCalendar) 为此格式设置日历 Date parse(String source) 将给定的字符串解析成日期/时间 格式化样式主要通过 DateFormat 常量设置。将不同的常量传入到表 1 所示的方法中，以控制结果的长度。DateFormat 类的常量如下。 SHORT：完全为数字，如 12.5.10 或 5:30pm。 MEDIUM：较长，如 May 10，2016。 LONG：更长，如 May 12，2016 或 11:15:32am。 FULL：是完全指定，如 Tuesday、May 10、2012 AD 或 11:l5:42am CST。 123456789101112131415161718192021222324252627public static void main(String[] args) { // 获取不同格式化风格和中国环境的日期 DateFormat df1 = DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA); DateFormat df2 = DateFormat.getDateInstance(DateFormat.FULL, Locale.CHINA); DateFormat df3 = DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.CHINA); DateFormat df4 = DateFormat.getDateInstance(DateFormat.LONG, Locale.CHINA); // 获取不同格式化风格和中国环境的时间 DateFormat df5 = DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA); DateFormat df6 = DateFormat.getTimeInstance(DateFormat.FULL, Locale.CHINA); DateFormat df7 = DateFormat.getTimeInstance(DateFormat.MEDIUM, Locale.CHINA); DateFormat df8 = DateFormat.getTimeInstance(DateFormat.LONG, Locale.CHINA); // 将不同格式化风格的日期格式化为日期字符串 String date1 = df1.format(new Date()); String date2 = df2.format(new Date()); String date3 = df3.format(new Date()); String date4 = df4.format(new Date()); // 将不同格式化风格的时间格式化为时间字符串 String time1 = df5.format(new Date()); String time2 = df6.format(new Date()); String time3 = df7.format(new Date()); String time4 = df8.format(new Date()); // 输出日期 System.out.println(\"SHORT：\" + date1 + \" \" + time1); System.out.println(\"FULL：\" + date2 + \" \" + time2); System.out.println(\"MEDIUM：\" + date3 + \" \" + time3); System.out.println(\"LONG：\" + date4 + \" \" + time4);} 运行结果： 虽然输出的时间更容易理解了，但是并不能达到要求，我们还需要更加定制化的时间格式，这时候就要有请 Calendar的儿子 SimpleDateFormat 类上场了。 SimpleDateFormat 类SimpleDateFormat 是一个以与语言环境有关的方式来格式化和解析日期的具体类。它允许进行格式化（日期 -&gt; 文本）、解析（文本 -&gt; 日期）和规范化。 这个类是最常用的类了，至少我在格式化时间的时候都用它，功能强大，随心所欲。SimpleDateFormat 有四个构造方法，使用方法： 123456//以下三种构造依赖语言环境，可能无法适应特定的语言环境SimpleDateFormat sdf = SimpleDateFormat();SimpleDateFormat sdf = SimpleDateFormat(String pattern);SimpleDateFormat sdf = SimpleDateFormat(String pattern,Locale locale);//用给定的模式和日期符号构造 SimpleDateFormat。SimpleDateFormat sdf = SimpleDateFormat(String pattern,DateFormatSymbols formatSymbols); 要用文本解析时间或者时间解析文本就要有文本规范，不能随便写，SimpleDateFormat 解析文本通过字母符号组成的文本，字母文本都比较好记： 以及解析字符串的例子，以美国时间模式为例（这就是上面说的语言环境）： 我们举一个最常用到方法的例子， 按2020-02-14 12:00:00 形式输出当前时间： 123456public static void main(String[] args) { Date d = new Date(); DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String time = df.format(d); System.out.print(time);} 只要记住大小写字母代表的意义就可以了，记不住差文档也可以，反正这种时间格式化的代码不会天天写，而且现在有专门时间格式化的开源包，比如我用过的 JodaTime ,感兴趣可以了解一下，虽然自己不用处理时间，但是我还是感觉 时间统一用 “ yyyyMMddHHmmss “这种格式简单粗暴，省了好多事。 小尾巴时间处理知道这些足够了，忘了就翻文档，搜博客，还有一种需求是求特定的哪一天是周几啊，距离现在几天啊这种。这就是思想延伸的东西了，这里就不介绍了。","link":"/2020/02/14/javabase13-szcl/"},{"title":"JAVA零基础筑基到修仙（十二）——数字处理类（Math，Random，BigInteger，BigDecimal）","text":"只用四则运算符无法完成三角、对数、指数等复杂运算，以及非常大的数字运算，Java提供Math等类解决问题，本篇内容有：Math类常用方法，随机数生成，数字格式化，大数字运算。 Math类常用方法挑一些经常用到的，有静态常量（自然数e，圆周率π）、求最大最小值和绝对值、求整、三角函数、指数运算，其实最常用的就是最大最小值和求整了。 静态常量自然数e和圆周率π： 1234//eMath.E;//πMath.PI; 我们控制台输出看看： 12System.out.println(\"e=\"+Math.E);System.out.println(\"π=\"+Math.PI); 求最大最小值和绝对值最常用功能，几个函数搞定，使用方法： 1Math.方法名; 函数与说明： 函数 说明 static int abs(int a) 返回 a 的绝对值 static long abs(long a) 返回 a 的绝对值 static float abs(float a) 返回 a 的绝对值 static double abs(double a) 返回 a 的绝对值 static int max(int x,int y) 返回 x 和 y 中的最大值 static double max(double x,double y) 返回 x 和 y 中的最大值 static long max(long x,long y) 返回 x 和 y 中的最大值 static float max(float x,float y) 返回 x 和 y 中的最大值 static int min(int x,int y) 返回 x 和 y 中的最小值 static long min(long x,long y) 返回 x 和 y 中的最小值 static double min(double x,double y) 返回 x 和 y 中的最小值 static float min(float x,float y) 返回 x 和 y 中的最小值 实践一下，分别求一下最大值最小值与绝对值： 123456789public static void main(String[] args) { // TODO Auto-generated method stub int i = 29; int j = 98; int k = -200; System.out.println(Math.max(i, j)); System.out.println(Math.min(i, j)); System.out.println(Math.abs(k));} 求整运算多用在需要不要求高精度数据展示的时候，使用方法： 1Math.方法名; 函数与说明： 函数 说明 static double ceil(double a) 返回大于或等于 a 的最小整数 static double floor(double a) 返回小于或等于 a 的最大整数 static double rint(double a) 返回最接近 a 的整数值，如果有两个同样接近的整数，则结果取偶数 static int round(float a) 将参数加上 1/2 后返回与参数最近的整数 static long round(double a) 将参数加上 1/2 后返回与参数最近的整数，然后强制转换为长整型 实践一下： 123456789public static void main(String[] args) { // TODO Auto-generated method stub Scanner input = new Scanner(System.in); double num = input.nextDouble(); System.out.println(\"大于或等于 \"+ num +\" 的最小整数：\" + Math.ceil(num)); System.out.println(\"小于或等于 \"+ num +\" 的最大整数：\" + Math.floor(num)); System.out.println(\"将 \"+ num +\" 加上 0.5 之后最接近的整数：\" + Math.round(num)); System.out.println(\"最接近 \"+num+\" 的整数：\" + Math.rint(num));} 三角函数运算大概要做加密，或者数学运算软件才会用到： 1Math.方法名; 函数与说明： 函数 说明 static double sin(double a) 返回角的三角正弦值，参数以孤度为单位 static double cos(double a) 返回角的三角余弦值，参数以孤度为单位 static double asin(double a) 返回一个值的反正弦值，参数域在 [-1,1]，值域在 [-PI/2,PI/2] static double acos(double a) 返回一个值的反余弦值，参数域在 [-1,1]，值域在 [0.0,PI] static double tan(double a) 返回角的三角正切值，参数以弧度为单位 static double atan(double a) 返回一个值的反正切值，值域在 [-PI/2,PI/2] static double toDegrees(double angrad) 将用孤度表示的角转换为近似相等的用角度表示的角 staticdouble toRadians(double angdeg) 将用角度表示的角转换为近似相等的用弧度表示的角 来实践一下： 1234567public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(\"90 度的正弦值：\" + Math.sin(Math.PI/2)); System.out.println(\"0 度的余弦值：\" + Math.cos(0)); System.out.println(\"0.5 的反正切值：\" + Math.atan(0.5)); System.out.println(\"120 度的弧度值：\" + Math.toRadians(120.0));} 指数与对数运算也是很少用到。 1Math.方法名; 方法 说明 static double exp(double a) 返回 e 的 a 次幂 static double pow(double a,double b) 返回以 a 为底数，以 b 为指数的幂值 static double sqrt(double a) 返回 a 的平方根 static double cbrt(double a) 返回 a 的立方根 static double log(double a) 返回 a 的自然对数，即 lna 的值 static double log10(double a) 返回以 10 为底 a 的对数 实践一下： 123456public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(\"2 的立方值：\" + Math.pow(2, 3)); System.out.println(\"10 的平方根：\" + Math.sqrt(10)); System.out.println(\"10 为底 2 的对数：\" + Math.log10(2));} 观察发现Java并没有提供log a（b）的方法，因为Java提供的两个对数方法已经足够计算机算对数用了，如果需要计算普通对数，我们可以变通一下，利用高中数学里用到的换底公式，log a (b) = log n (b) / log n (a) ,我们把 n 代为自然数 e 就可以了,当然log10()也是可以的。 1234 public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(&quot;8 为底 2 的对数：&quot; + (Math.log(8) / Math.log(2))); // 3.0} 随机数生成随机数也是非常常用的功能，比如需要从数据库随机抓取数据，Java中的 Random 类提供众多生成随机数的方法，另外 Math 类也提供了一个生成随机数的方法 Math.random()，还有一种野路子，使用 currentTimeMillis（时间处理会用到，可以先了解一下） 获取毫秒值 取模生成随机数。一般情况下生成整数随机数的需求比较多一点。 Math.random()如果只是随便生成一个 float 随机数，那用这个是非常合适的选择，因为 Math 是静态类，不用new 来新建对象。这个方法返回带正号的 double 值，该值大于等于 0.0 且小于 1.0，但是我们可以通过乘法来扩大数值，然后通过加减运算再取整函数来获得一个符合预期的随机数。 12345678public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(Math.random()); //0.24037287785722083 //比如我想要一个100 以内的随机数 System.out.println((int)(Math.random()*100)); //39 //想得到一个50-100的随机数 System.out.println((int)(50+(Math.random()*(100-50)))); //68} 无论是这个方法取随机还是用 Random类 生成特定范围内的随机数，算法都是一样的 ( int )(min + ( 方法 *( max - main ))) 。用 currentTimeMillis() 略有不同 把中间乘号改为取模( % )。 Random 类方法Random 类为我们提供了整套的随机数生成方案，足够日常业务需求使用。我们打开JDK帮助文档看看吧（变懒了不想手写表格了），首先是用法： 123456//首先需要新建 Random 对象Random rd = newRandom();//重载构造 带种子的对象Random rd = newRandom(long seed);//然后调用方法类型 变量名 = rd.方法; 看图： 方法我们不做详细说明等会直接写个demo，我们说一下这个种子是什么鬼。种子在这里可能是翻译问题，用标识说更贴切，如 new Random(1) 当运行的时候用 1 的标识生成的随机数，即使再运行也不会变；如果是 new Random() 同个方法每次运行生成的随机数都会不一样。 我们把这段代码运行两次： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub Random rd1 = new Random(1); Random rd2 = new Random(); for (int i = 5; i &gt; 0; i--) { System.out.print(rd1.nextInt(100)+\" \"); } System.out.println(\"\\n~~~~~~~~~~~~~~\"); for (int i = 5; i &gt; 0; i--) { System.out.print(rd2.nextInt(100)+\" \"); }} 运行第一次运行第二次 我们看到使用种子创建对象的类方法产生的随机数是一样的，在实际使用的时候还是不带种子的多一些。 把其他方法都跑一下， 1234567891011121314151617181920212223public static void main(String[] args) { // TODO Auto-generated method stub Random r = new Random(); double d1 = r.nextDouble(); // 生成[0,1.0]区间的小数 double d2 = r.nextDouble() * 7; // 生成[0,7.0]区间的小数 int i1 = r.nextInt(10); // 生成[0,10]区间的整数 int i2 = r.nextInt(18) - 3; // 生成[-3,15]区间的整数 long l1 = r.nextLong(); // 生成一个随机长整型值 boolean b1 = r.nextBoolean(); // 生成一个随机布尔型值 float f1 = r.nextFloat(); // 生成一个随机浮点型值 System.out.println(\"生成的[0,1.0]区间的小数是：\" + d1); System.out.println(\"生成的[0,7.0]区间的小数是：\" + d2); System.out.println(\"生成的[0,10]区间的整数是：\" + i1); System.out.println(\"生成的[-3,15]区间的整数是：\" + i2); System.out.println(\"生成一个随机长整型值：\" + l1); System.out.println(\"生成一个随机布尔型值：\" + b1); System.out.println(\"生成一个随机浮点型值：\" + f1); System.out.print(\"下期七星彩开奖号码预测：\"); for (int i = 1; i &lt; 8; i++) { int num = r.nextInt(9); // 生成[0,9]区间的整数 System.out.print(num); }} currentTimeMillis()这是个牛逼的野路子，大佬的思路我们不懂，一般我们也不会用这个，不详细说了，举个例子带过吧。 方法返回从1970年1月1日0时0分0秒（这与UNIX系统有关）到现在的一个long型的毫秒数，取模之后即可得到所需范围内的随机数。 123456public static void main(String[] args) { int max = 100, min = 1; long randomNum = System.currentTimeMillis(); int ran3 = (int) (randomNum % (max - min) + min); System.out.println(ran3);// 60} 数字格式化数字的格式在解决实际问题时使用非常普遍，这时可以使用 DecimalFormat 类对结果进行格式化处理。例如，将小数位统一成 2 位，不足 2 位的以 0 补齐。DecimalFormat 是 NumberFormat 的一个子类，用于格式化十进制数字。DecimalFormat 类包含一个模式和一组符号，常用符号看图举个例子： 123456789101112131415public static void main(String[] args) { // 实例化DecimalFormat类的对象，并指定格式 DecimalFormat df1 = new DecimalFormat(\"0.0\"); DecimalFormat df2 = new DecimalFormat(\"#.#\"); DecimalFormat df3 = new DecimalFormat(\"000.000\"); DecimalFormat df4 = new DecimalFormat(\"###.###\"); Scanner scan = new Scanner(System.in); System.out.print(\"请输入一个float类型的数字：\"); float f = scan.nextFloat(); // 对输入的数字应用格式，并输出结果 System.out.println(\"0.0 格式：\" + df1.format(f)); System.out.println(\"#.# 格式：\" + df2.format(f)); System.out.println(\"000.000 格式：\" + df3.format(f)); System.out.println(\"###.### 格式：\" + df4.format(f));} 大数字运算Java提供两个类进行大数字处理，BigInteger 类和 BigDecimal 类，解决 int 范围问题（任何数字数据类型都有范围 Java中 int 是-2147483648 ~ 2147483647 这和计算机二进制补码计算有关，感兴趣可以了解一下，用2147483647+1看看会得到什么结果）。 BigInteger使用方法： 12//创建对象 val 是十进制数字 但是注意参数格式是字符串BigInteger bi = BigInteger(String val) 文档里方法太多了我挑些常用的方法（和 int不同的地方在于不能使用运算符计算，要用方法计算）： 12345public static void main(String[] args) { BigInteger bi = new BigInteger(\"999999999999999\"); // 加一 System.out.println(\"加1结果：\" + bi.add(new BigInteger(\"1\")));} BigDecimalBigDecimal 多用于算钱，在数量较大时又能保证高精度（支持任何精度），比 BigInteger 更为实用，用法和 BigInteger 基本一样，先建对象，再使用方法计算。 12//创建对象 val 是十进制数字 但是注意参数格式是字符串BigDecimal bd = new BigDecimal(String val) 计算方法(文档里太难看了我放到excel)：其中，divide() 方法的 3 个参数分别表示除数、商的小数点后的位数和近似值处理模式。 BigDecimal 还提供了计算模式，各种模式满足你算钱的需求（看了文档才知道这么厉害，我以前也就用它加加减减）： 举个例子描述结束今天的学习： 12345public static void main(String[] args) { BigDecimal bi = new BigDecimal(\"999999999999999.345678\"); // 加法 System.out.println(\"加法结果：\" + bi.add(new BigDecimal(\"1.3465\")));} 小尾巴这些内容可以分俩博客讲的，但是我觉得东西不多，就直接塞一块儿了，夜深了，睡觉了。","link":"/2020/02/13/javabase12-math/"},{"title":"JAVA零基础筑基到修仙（十一）——Java正则表达式","text":"Java正则表达式也是字符串处理的内容，但是并不几个方法就能说清楚的，所以单独拿出来说一说。正则表达式多用于数据筛选，数据验证等，重要且用途广泛。但是Java正则表达式内容很多，以我的三脚猫功夫怕是讲不出个所以然，在我看博客学正则时看到一个几万字的博客，虽然他也是转载的吧，正则表达式详解,作为初学者我们只需要记住几个常见的正则写法：电话，邮箱，用户名，密码，等真的需要考虑特别复杂情况的正则时再翻书学习，因为并不是天天写正则，现在学个大概，到用时差不多也忘光了。本篇大量引用了c语言中文网-Java正则表达式,同时推荐去看一下菜鸟教程。 正则表达式（regex）由普通字符与特殊字符组成，用来匹配一个或多个字符，如：”^\\d+(.\\d+)?”,可以匹配带小数点的数。 String 类提供了几个特殊的字符串匹配方法，这些方法依赖于Java对正则表达式的支持： boolean matches(String regex)：判断该字符串是否匹配指定的正则表达式。 String replaceAll(String regex, String replacement)：将该字符串中所有匹配 regex 的子串替换成 replacement。 String replaceFirst(String regex, String replacement)：将该字符串中第一个匹配 regex 的子串替换成 replacement。 String[] split(String regex)：以 regex 作为分隔符，把该字符串分割成多个子串。 上面举的匹配小数的正则表达式例子看上去很复杂，其实并不复杂，随便一个字符串就是一个正则表达式，如”abc”，只是它只能匹配”abc”而已，功能强大的正则表达式，只是一个特殊的字符串，那我们应该如何创建正则表达式呢？ 正则表达式的构成 组成正则表达式的合法字符 字符 描述 X 字符x（x 可代表任何合法的字符) \\0mnn 八进制数 0mnn 所表示的字符 \\xhh 十六进制值 0xhh 所表示的字符 \\uhhhh 十六进制值 0xhhhh 所表示的 Unicode 字符 \\t 制表符（“\\u0009”） \\n 新行（换行）符（‘\\u000A’） \\r 回车符（‘\\u000D’) \\f 换页符（‘\\u000C’） \\a 报警（bell）符（‘\\u0007’） \\e Escape 符（‘\\u001B’） \\cx x 对应的的控制符。例如，\\cM匹配 Ctrl-M。x 值必须为 A~Z 或 a~z 之一。 特殊字符，使用特殊字符时要加转义字符“\\” 字符 描述 $ 匹配一行的结尾。要匹配 $ 字符本身，请使用\\$ ^ 匹配一行的开头。要匹配 ^ 字符本身，请使用\\^ () 标记子表达式的开始和结束位置。要匹配这些字符，请使用\\(和\\) [] 用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用\\[和\\] {} 用于标记前面子表达式的出现频度。要匹配这些字符，请使用\\{和\\} * 指定前面子表达式可以出现零次或多次。要匹配 * 字符本身，请使用\\* + 指定前面子表达式可以出现一次或多次。要匹配 + 字符本身，请使用\\+ ? 指定前面子表达式可以出现零次或一次。要匹配 ？字符本身，请使用\\? . 匹配除换行符\\n之外的任何单字符。要匹配.字符本身，请使用. \\ 用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配\\字符，请用\\\\ | 指定两项之间任选一项。如果要匹配丨字符本身，请使用\\| 上面所说的只能匹配单个字符，通配符让正则表达式真正的强大起来。 字符 描述 \\. 可以匹配任何字符 \\d 匹配 0~9 的所有数字 \\D 匹配非数字 \\s 匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等 \\S 匹配所有的非空白字符 \\w 匹配所有的单词字符，包括 0~9 所有数字、26 个英文字母和下画线_ \\W 匹配所有的非单词字符 上面的 7 个预定义字符其实很容易记忆，其中： d 是 digit 的意思，代表数字。 s 是 space 的意思，代表空白。 w 是 word 的意思，代表单词。 d、s、w 的大写形式恰好匹配与之相反的字符。我们举个例子：12c\\\\wt // 可以匹配cat、cbt、cct、cOt、c9t等一批字符串\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d // 匹配如 000-000-0000 形式的电话号码 在一些特殊情况下，例如，若只想匹配 a~f 的字母，或者匹配除 ab 之外的所有小写字母，或者匹配中文字符，上面这些预定义字符就无能为力了，此时就需要使用方括号表达式，方括号表达式有几种形式。 方括号表达式 说明 表示枚举 例如[abc]表示 a、b、c 其中任意一个字符；[gz]表示 g、z 其中任意一个字符 表示范围：- 例如[a-f]表示 a~f 范围内的任意字符；[\\u0041-\\u0056]表示十六进制字符 \\u0041 到 \\u0056 范围的字符。范围可以和枚举结合使用，如[a-cx-z]，表示 a~c、x~z 范围内的任意字符 表示求否：^ 例如[^abc]表示非 a、b、c 的任意字符；[^a-f]表示不是 a~f 范围内的任意字符 表示“与”运算：&amp;&amp; 例如 [a-z&amp;&amp;[def]]是 a~z 和 [def] 的交集，表示 d、e f[a-z&amp;&amp;^bc]]是 a~z 范围内的所有字符，除 b 和 c 之外 [ad-z] [a-z&amp;&amp;[m-p]]是 a~z 范围内的所有字符，除 m~p 范围之外的字符 表示“并”运算 并运算与前面的枚举类似。例如[a-d[m-p]]表示 [a-dm-p] 方括号表达式比前面的预定义字符灵活多了，几乎可以匹配任何字符。例如，若需要匹配所有的中文字符，就可以利用 [\\u0041-\\u0056] 形式——因为所有中文字符的 Unicode 值是连续的，只要找出所有中文字符中最小、最大的 Unicode 值，就可以利用上面形式来匹配所有的中文字符。 正则表达式还支持圆括号，用于将多个表达式组成一个子表达式，圆括号中可以使用或运算符|。例如，正则表达式“((public)|(protected)|(private))”用于匹配 Java 的三个访问控制符其中之一。 除此之外，Java 正则表达式还支持几个边界匹配符: 边界匹配符 说明 ^ 行的开头 $ 行的结尾 \\b 单词的边界 \\B 非单词的边界 \\A 输入的开头 \\G 前一个匹配的结尾 \\Z 输入的结尾，仅用于最后的结束符 \\z 输入的结尾 前面例子中需要建立一个匹配 000-000-0000 形式的电话号码时，使用了 \\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d 正则表达式，这看起来比较烦琐。实际上，正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。 Greedy（贪婪模式）：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。 Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。 Possessive（占有模式）：用加号后缀（+）表示，目前只有 Java 支持占有模式，通常比较少用。 如图： 12345String str = \"hello,java!\";// 贪婪模式的正则表达式System.out.println(str.replaceFirst(\"\\\\w*\" , \"■\")); //输出■,java!// 勉强模式的正则表达式System.out.println(str.replaceFirst(\"\\\\w*?\" , \"■\")); //输出■hello, java! 当从“hello java!”字符串中查找匹配\\w子串时，因为\\w使用了贪婪模式，数量表示符会一直匹配下去，所以该字符串前面的所有单词字符都被它匹配到，直到遇到空格，所以替换后的效果是“■，Java!”；如果使用勉强模式，数量表示符会尽量匹配最少字符，即匹配 0 个字符，所以替换后的结果是“■hello，java!”。 小尾巴这正则表达式文章让我自己写，我还很菜，写不出来，所以参考了其他博客的文章，毕竟我写代码一年多，还没用到过比较复杂的正则表达式，而且一般正则表达式可以在百度搜出来，但是又不能不写这内容，我自己这段时间学一学，学成回来补充或者重写本篇。","link":"/2020/02/13/javabase11-zzbds/"},{"title":"JAVA零基础筑基到修仙（十三）——包装类、装箱拆箱","text":"Java提倡一切皆对象，Java是面向对象的语言，但是从数据类型来看，引用型数据有对应的对象类，如String，而基本型数据无法被称为对象，为解决这个尴尬问题，Java为每个基本型数据类提供了对应的类，称为包装类，顾名思义就是给它们外面裹一层。本篇内容：装箱拆箱，包装类应用。 首先我们要对每个基本类型的包装类是什么有所了解，Java提供的包装类除了 int 和 char 的包装类分别为 Integer 和 Character 外，其他包装类都是首字母变大写，还是比较好记的，如下表。 类型 包装类 byte Byte short Short int Integer long Long char Character float Float double Double boolean Boolean 这些包装类为对应的数据类型提供了丰富的类方法，比如我们在 String 与 int 类型互转用到的 toString 方法，这么多类型不在一一举例，详情可以查看jdk帮助文档。 装箱与拆箱顾名思义，装箱是将东西装进去，拆箱是将东西拿出来，对应到包装类操作就分别是：基本型→包装类和包装类→基本型，从jdk1.5版本以来提供了自动装箱拆箱支持，下面来看看如何操作。 123456789public static void main(String[] args) { int i = 100; Integer integer = i; //自动装箱 int j = integer; //自动拆箱 System.out.println(\"拆箱后j=\"+j); Integer integer2 = new Integer(j);//手动装箱 int k = integer2.intValue(); //手动拆箱 System.out.println(\"拆箱后k=\"+k);} 包装类应用手动自动拆装都试过了，装箱为的是使用箱子给提供的方法，最常用就是类型转换，在这里用 int String 互转举例，后面我们在详细说各个包装类： int 类型数据 转为 String ,我们以后都用自动装箱。要用到 Integer 类中 toString(); 123456public static void main(String[] args) { int i = 100; Integer integer = i; // 自动装箱 String str = integer.toString(); System.out.println(\"装换后字符串：\" + str);} String 转 int ，使用 Integer.parseInt 123456public static void main(String[] args) { String str = \"100\"; int i = Integer.parseInt(str);// 自动拆箱，不拆也没关系 System.out.println(\"str*2=\"+i*2); } 拆箱装箱的目的就是要使用类方法达到一定目的，到后面封装方法也是一样的目的。 小尾巴这篇内容比较少，主要做个介绍，虽然两个概念词听起来很高大上，其实我们前面已经用到过了，后面的各个包装类，我打算分两次弄完。","link":"/2020/02/14/javabase14-bz-zxcx/"},{"title":"JAVA零基础筑基到修仙（三）——标识符与关键字、常量与变量、作用域、数据类型和类型转换","text":"本篇内容包括Java语言中标识符、关键字、常量、变量和数据类型的讲解，学任何一门语言，这些内容都是最基础也是最重要的，就像盖房子，不同的材料有不同的用处，让材料物尽其用才能盖好房子。实践是检验真理的唯一标准，学知识就要多实践，学计算机语言就要多敲代码，只有这样知识才能学得会，记得牢，技巧也用的熟。 标识符与关键字标识符标识符分为两类，分别为关键字和用户自定义标识符。 关键字是有特殊含义的标识符，如 true、false 表示逻辑的真假。 用户自定义标识符是由用户按标识符构成规则生成的非保留字的标识符，如 abc 就是一个标识符。提个醒：使用标识符时一定要注意，或者使用关键字，或者使用自定义的非关键字标识符。此外，标识符可以包含关键字，但不能与关键字重名。Java中标识符用来定义方法、变量或者其他用户自定义的名称，它可以是一个字符，也可以是一个字符串。构成规则如下： 标识符由数字（0-9）和字母（A-Z 和 a-z）、美元符号（$）、下划线（_）以及 Unicode 字符集中符号大于 0xC0 的所有符号组合构成（各符号之间没有空格）。 标识符的第一个符号为字母、下划线和美元符号，后面可以是任何字母、数字、美元符号或下划线，不可以用数字开头。 Java语言中区分大小写，例如boy与Boy是两个不同的字符串提个醒：标识符是变量、类名、方法名的命名，命名提倡给予标识符正确含义，如定义两个男孩可以用boy_1与boy_2，不提倡用a、b定义（要养成好习惯，初学C语言深受老谭毒害）关键字关键字是说这个标识符有特定的用处，不能随便拿来用，如上图不能用“true”做变量名。每个jdk版本里关键字的数量是一定的，不同的jdk中关键字的数量可能不同。下面列举常见关键字： 数据类型：boolean、int、long、short、byte、float、double、char、class、interface。 流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。 修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。 动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。 保留字：true、false、null、goto、const。提个醒：虽然有区分大小写，但是也尽量不要用“Public”、“True”等类似标识符，容易产生歧义。 常量与变量常量和常量值常量就是不变的量，常量值是常量的值（解释的很蠢，但是就是这个意思）。代码中可以使用定义过的常量，也可以直接使用常量值。定义常量的方法就是在类型前面加关键字“final”。下面练习定义常量和认识常量值。 整型常量值，按进制分八进制、十进制、十六进制定义方法直接上图：整型（int）常量默认在内存中占 32 位，是具有整数类型的值，当运算过程中所需值超过 32 位长度时，可以把它表示为长整型（long）数值。长整型类型则要在数字后面加L或1，如697L表示一个长整型数，它在内存中占 64 位。 实型常量值，两种形式，十进制型小数点形式如9.9，科学计数法如1.1e5或10&amp;E3,其中 e 之前必须有数字，且 e 之后的数字必须为整数。注意：小数定义有单精度和双精度只分，单精度在末尾要加上 f 。 布尔类型常量值，true or false ，只有这两个值。 字符型和字符串型常量值，字符型如“A，a”,字符串型如“boy,girl”,还有一种转义字符，比如换行符“\\n”：下面列举出常用转移符：变量Java中变量的使用有特定规则，必须先声明后使用，指定类型的变量只能接收该类型的值。声明变量的方法为 [数据类型 变量名 = 值]（例如 String boy = “kangkang”，也可以是 [数据类型 变量名],如 String boy; ）。在上面说各类型常量值的时候已经用到了变量声明；声明变量要依据声明类型的类方法，比如String类型就有多种声明方法，这就需要查Java API文档点开对应类，去研究研究这个类究竟有多少使用方法，Java提供了官方文档，有在线也有离线版，使用方法很简单，即使不懂，百度很容易就解决了。举个栗子：以后碰到不懂得类，可以翻翻api文档，知识学的很快的，变大佬必备。变量标识符的命名规范如下： 首字符必须是字母、下划线（―）、美元符号（$）或者人民币符号（¥）。 标识符由数字（0-9）、大写字母（A-Z）、小写字母（a-z）、下划线（―）、美元符号（$）、人民币符号（¥）以及所有在十六进制 0xc0 前的 ASCII 码组成。 不能把关键字、保留字作为标识符。 标识符的长度没有限制。 标识符区分大小写。Java 中初始化变量时需要注意以下事项： 变量是类或者结构中的字段，如果没有显式地初始化，默认状态下创建变量并默认初始值为 0。 方法中的变量必须显式地初始化，否则在使用该变量时就会出错。 作用域作用域界定了声明变量的使用范围，在Java中认准花括弧”{}”就行。在括弧内声明的变量只能在括弧内使用。根据作用域的不同，把变量分为成员变量和局部变量（当然这都是概念知识，敲多了自然懂）。 成员变量成员变量包含全局变量和静态变量：撸个代码看一下如何调用两种变量 1234567public class Boy { /*以下都是Boy类里的成员变量*/ public String name;//boy 姓名 （实例变量） public int age;//年龄 （实例变量） public final static String home = \"Hebei\";//家庭住址 静态常量（类变量） public static String tel = \"8888-6666666\";//电话 静态变量（类变量）} 编个测试类看一下 1234567891011121314151617public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Boy boy1 = new Boy();//将Boy类实例化为boy1 //实例变量必须用实例调用(全局变量) System.out.println(boy1.name); System.out.println(boy1.age); //实例.变量名 调用类变量(类变量) System.out.println(boy1.home); System.out.println(boy1.tel); //类变量不用实例化对象也可以直接 类.变量(类变量) System.out.println(Boy.home); System.out.println(Boy.tel); }} 运行结果全局变量有默认初始值，static final修饰的变量必须赋予初始值，类变量的方便之处就是不用实例化对象，直接用[类.变量名]调用。 局部变量局部变量是指在方法或者方法代码块中定义的变量，其作用域是其所在的代码块。可分为以下三种： 方法参数变量（形参）：在整个方法内有效。 方法局部变量（方法内定义）： 从定义这个变量开始到方法结束这一段时间内有效。 代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。 局部变量在使用前必须被程序员主动初始化值。 方法局部变量1234567891011121314public class Test { public static void main(String[] args) { // TODO Auto-generated method stub int i = 3,j = 4; if (i &gt; 2) { System.out.println(\"i=\"+i); System.out.println(\"j=\"+j); } System.out.println(\"i=\"+i); System.out.println(\"j=\"+j); }} 方法参数变量123456789101112131415public class Test { public static void main(String[] args) { // TODO Auto-generated method stub //调用方法 Test.add(1); } public static void add(int i)//方法参数变量 { int j = 10;//方法局部变量 System.out.println(\"i+j=\"+i+j); }} 代码块局部变量123456789101112131415161718public class Test { public static void main(String[] args) { // TODO Auto-generated method stub // 调用方法 Test.test(1); } public static void test(int i) {// 方法参数变量 try {// 使用try catch 代码块 异常处理代码块，后面异常篇再详细说 int j = 10;代码块 局部变量 System.out.println(\"i+j=\" + i + j); } catch (Exception e) {// 异常处理块，参数为 Exception 类型 e.printStackTrace(); } }} 作用域讲完了，是不是很简单，看准”{}”，多练比看概念要好得多。 数据类型Java中数据类型分为基本型和引用型我们用几张图就能搞定了，多用就能记住，不要死记硬背： 基本型与引用型数据内存存储原理 基本数据类型的存储原理：所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的内存栈上的，数据本身的值就是存储在栈空间里面，Java语言里面八种数据类型是这种存储模型； 引用类型的存储原理：引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”(存储对象在内存堆上的地址)是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的； 无论基本数据类型还是引用类型，他们都会先在栈中分配一块内存，对于基本类型来说，这块区域包含的是基本类型的内容；而对于引用类型来说，这块区域包含的是指向真正内容的指针，真正的内容被手动的分配在堆上。（最直观的例子是基本型和引用型值的比较不同，基本型用“ == ”，引用型用需要用类方法，我们将在后面筑基与修仙（十）详细说明） 基本型基本数据类型可分为 4 大类，即整数类型（包括 byte、short，int 和 long）、浮点类型（包括 float 和 double）、布尔类型和字符类型（char）：Java 定义了 4 种整数类型变量：字节型（byte）、短整型（short）、整型（int）和长整型（long）。这些都是有符号的值，正数或负数。具体说明看图：根据要求使用合适的类型，严格按照变量声明方式，Java中没有无类型变量，不再举例，上面的变量声明练习足够了，可以试着自己把所有类型敲一下。 引用型引用数据类型建立在基本数据类型的基础上，包括数组、类和接口。引用数据类型是由用户自定义，用来限制其他数据的类型。另外，Java 语言中不支持 C++ 中的指针类型、结构类型、联合类型和枚举类型。引用类型还有一种特殊的 null 类型。所谓引用数据类型就是对一个对象的引用，对象包括实例和数组两种。实际上，引用类型变量就是一个指针，只是 Java 语言里不再使用指针这个说法。空类型（null type）就是 null 值的类型，这种类型没有名称。因为 null 类型没有名称，所以不可能声明一个 null 类型的变量或者转换到 null 类型。空引用（null）是 null 类型变量唯一的值。空引用（null）可以转换为任何引用类型。在实际开发中，程序员可以忽略 null 类型，假定 null 只是引用类型的一个特殊直接量（不听不听和尚念经……）。注意：空引用（null）只能被转换成引用类型，不能转换成基本类型，因此不要把一个 null 值赋给基本数据类型的变量。 数据类型转换分隐式转换与显示转换两种。 隐式转换如果以下 2 个条件都满足，那么将一种类型的数据赋给另外一种类型变量的时，将执行自动类型转换： 两种数据类型彼此兼容 目标类型的取值范围大于源数据类型（低级类型数据转换成高级类型数据）例如 byte 类型向 short 类型转换时，由于 short 类型的取值范围较大，会自动将 byte 转换为 short 类型。在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。自动转换的规则是从低级类型数据转换成高级类型数据。转换规则如下： 数值型数据的转换：byte→short→int→long→float→double。 字符型转换为整型：char→int。以上数据类型的转换遵循从左到右的转换顺序，最终转换成表达式中表示范围最大的变量的数据类型，举个栗子。123456789public static void main(String[] args) { // TODO Auto-generated method stub float price1 = 10.5f; // 定义牙膏的价格 double price2 = 3.5; // 定义面巾纸的价格 int num1 = 4; // 定义牙膏的数量 int num2 = 5; // 定义面巾纸的数量 double res = price1 * num1 + price2 * num2; // 计算总价 System.out.println(\"一共付了\" + res + \"元\"); // 输出总价 } 看起来很高级，但并不是所有类型都这么好用：那么现在就用到显示转换了。显式转换当两种数据类型不兼容，或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行强制类型转换。我们把上面没转好的转一下：再举个例子，我们上面去买牙膏用的浮点型算的钱，现在我们只关心花了多少块，不关心几毛钱了。123456789public static void main(String[] args) { // TODO Auto-generated method stub float price1 = 10.5f; // 定义牙膏的价格 double price2 = 3.5; // 定义面巾纸的价格 int num1 = 4; // 定义牙膏的数量 int num2 = 5; // 定义面巾纸的数量 int res = (int)(price1 * num1 + price2 * num2); // 计算总价 System.out.println(\"一共付了\" + res + \"元\"); // 输出总价 } 小尾巴腰好疼，一坐就是三个小时，还是要多锻炼肾体啊。","link":"/2020/02/06/javabase3-bsfgjzclbltj/"},{"title":"JAVA零基础筑基到修仙（二）——Hello world!","text":"上一篇博客介绍了Java基本知识，接下来我们以在Windows上开发为例（不同的系统环境只是配置环境变量的方法不一样），正式开始Java的学习。本篇内容包含：Java开发环境配置，年轻人的第一个Java程序和Java集成开发环境（IDE）的使用。 安装Java开发和运行环境想要运行Java程序，系统需要具备Java运行环境，也就是Java Runtime Environment,简称JRE。但是如果要开发Java程序，需要的是Java Development Kit,Java程序开发工具包，也就是我们常说的JDK。一半只有服务器才会安装单独的JRE环境，开发人员需要两个都有，我们只需要去甲骨文官网下载JDK就可以，安装文件中包含了JDK和JRE。百度直接搜索“jdk”，找到甲骨文官网jdk下载页，我习惯使用jdk8,我们以jdk8的安装为例（jdk并不是越新越好，现在还有相当多的企业项目用的是jdk6,新的jdk含有新的Java规范，不同的jdk环境编译出的class文件不一样，如果开发人员jdk需要升级，服务器上的jre也要跟着升级，否则旧的环境无法运行新的规范，造成宕机，如果是重要应用，就是生产事故了。所以很多企业级应用开发人员出于稳定考虑，在当前环境满处生产需要时，不会去冒然去升级jdk版本）：然后找到版本信息，我是Win10 64位系统选择x64版本，32位系统选择i586版本（虽然64位系统可以安装32位版本，但是为了防止出现各种莫名其妙的错误，最好版本对应）下载时可能会让你登录，否者下载不开始，用邮箱注册个账号就行了（现在网络快多了，前几年下载那叫一个慢）。下载好了，开始安装（我安装的是8u181版本，小版本不一样安装没有差别）：一直点下一步就可以了（当然推荐你改一下安装位置，只要知道装在哪里就行了，后面配置环境要用）如果安装完找不到了咋办，卸载重新装，很快的这次记好了。安装完成打开Windows控制台，win+r调出运行输入cmd回车（也可以使用Win10快速检索win+q,输入cmd，需要管理员权限的控制台时这个方式更好用）输入java -version说明安装成功了，接下来我们配置环境变量，右击此电脑选择属性，选择高级系统设置，点击环境变量，在下面系统变量里新建”JAVA_HOME”和”CLASSPATH”两个变量，JAVA_HOME中的值为刚才安装Java选定的位置，我的位置是”C:\\Program Files\\Java\\jdk1.8.0_181”,复制进去保存。在CLASSPATH中输入”.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;”（复制时别复制冒号，注意开头分号前面有”.”）然后找到”Path”，点击编辑添加依次输入”%JAVA_HOME%\\bin”和”%JAVA_HOME%\\jre\\bin”保存（不同系统可能页面显示的不一样不是这种的话需要用分号隔开，这样”%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;”）修改成功后保存完成关闭面板，打开新的控制台输入”javac”回车，如果成功出现下图内容，则说明环境配置成功，接下来就可以进行开发学习了，如果不成功，请仔细检查环境变量配置步骤中的内容是否正确。 Hello world!终于可以开始敲代码了，接下来有请年轻人的第一个Java程序”Hello world!”闪亮登场（传统艺能，传统艺能……）！在本地磁盘D新建”Demo”文件夹,打开文件夹新建Hello.txt记事本文件（”.txt”是文件扩展名，如果新建记事本不显示扩展名，请百度”如何显示文件扩展名”，比较简单，这里没有截图），在记事本中输入如下代码： Hello.java12345public class Hello{ public static void main(String[] args){ System.out.println(\"Hello world!\"); }} 保存记事本然后修改扩展名为”.java”，提示可能无法使用点确定（文件名字可以不叫”Hello”,但是一定要与代码中”public class”后面的名字一模一样，注意区分大小写,代码中符号都是英文符号）。然后打开控制台进入Demo,我的在D盘，打开cmd后直接输入”d:”回车，然后”cd demo”进入demo文件夹（Windows里文件名是不区分大小写的）。输入”javac Hello.java”回车，如果代码没有错误就什么都不显示，否则会报出异常。如下图：然后我们通过”java”命令运行文件（注意不用带文件扩展名）：如图，我们成功打印出了设定内容”Hello world!”,我们第一个Java程序完成（呱唧呱唧~）。那么我们来稍微了解一下代码是怎么回事吧：有间隔的每个字段意义都不同，我来一一说明： 关键字class用来定义一个类，Hello是类的名称； 在Java程序中，所有的语句都必须放在某个类中； 整个类及其所有成员都包含在一对花括号中（即{和}之间），它们标志着类定义块的开始和结束。 定义类的一般语法：Hello.java123class 类名{ ……} 程序必须从main函数开始执行； 关键字public是访问修饰符，用来控制类成员的可见范围及作用域； 关键字static允许在不创建类的实例的情况下，调用main函数； 关键字void用来说明main函数是没有返回值的； args是字符串数组，用来从命令行接收参数； main函数的一般形式如下：Hello.java123public static void main(String[] args){ …… } String[]是字符串类型的数组； 在Java中，类名称一般首字母大写； 使用System.out.println()将信息输出到控制台上，即打印出来。解析完代码，你是否对Java代码规范有了一知半解了呢，试着修改代码按照刚才的步骤在控制台打出更多内容吧。这次我们使用上注释，注释不会被编译，有两种形式一种为“// ……”,可以注释掉同行的代码，一种是代码段注释“/……/”，注释掉一段代码（注意使用英文，当前开发环境简陋，使用中文可能导致编码异常）：Hello.java12345678910111213141516/*** This class mean to print \"Hello world!\"*/public class Hello{ public static void main(String[] args){ // print Hello world! System.out.println(\"Hello world!\"); System.out.println(\"I am Zhangsan\"); /*System .out .println(\"I am a girl\");*/ //System.out.println(\"I am a boy\"); System.out.println(\"I am a boy\"); System.out.println(\"I am 10 years old \"); }} 编译运行！通过”javadoc”命令可以将注释内容提取，生成一个文件方便查阅，来试试看：生成了一堆文件打开index.html到此为止，对Java初体验结束，初学者是不是感觉收货满满，这是是Java的冰山一角，她的众多优秀特性我们到后面再慢慢了解。集成开发环境（IDE）Java开发人员常用的开发软件有三个，分别是Eclipse、Myeclipse、Idea（剩下的都是些小众的，我也不了解）我说一说我对这三个软件的理解：EclipseEclipse轻量，简洁，操作简便，对电脑配置要求较低，并且开源免费，更适合Java初学者。缺点是简洁到几乎没有插件，后面很多开发必须插件都需要自己安装，好在eclipse提供插件支持，可以再软件里一键安装。Myeclipse它是Eclipse的定制版本，对电脑配置要求较高，而且收费，集众多生产插件于一身，免除了自己装插件的烦恼，相比eclipse功能更完善（毕竟花了钱的）。IDEA相对于先前两个，IDEA是重量级的集成开发工具，对电脑配置要求高，支持多种语言开发，拥有丰富的开源插件生态，功能相当完善，是众多开发者的首选工具，大佬必备（意义简单粗暴），这么优秀的工具肯定是需要掏钱的，官方推出了完整版和社区版（阉割版），社区版是免费的。但是在我们国内网络现在的大环境下，搜索破解方法还是相当简单的（我们这么喜欢你你竟然要收我们钱？哈哈哈……），不过在国人版权意识逐渐苏醒的今天，我呼吁有能力的开发者尽量使用正版软件（哎吆我插会儿腰……嘿嘿嘿）。开发工具介绍完毕，作为Java初学者建议使用eclipse，虽然一步到位使用IDEA更好，但是IDEA相对来说对电脑配置要求高，如果配置跟不上会卡顿，严重影响开发体验，撇去性能不谈，IDEA自动保存，但是没有自动编译，需要手动编译（虽然可以自己设置自动编译，但我劝你别），eclipse点击保存的时候自动编译。所以等以后碰到语言多了，比如学习Spring boot或者开发项目需要同时操作好几门语言，这时候一个IDEA就可以完全搞定了。好了开发工具搞定，我们顺便在eclipse上撸个”Hello world!”吧。 在eclipse上运行Hello world安装eclipse需要验证环境变量，如果环境变量没安装好，eclipse无法正常安装，下载地址。安装过程（这种种边下载边安装的形式，耐心等待安装完成，也可以点击下载页下载按钮地下的 Download Packages 整包下载）：安装完成首次打开会让你选择工作空间，也就是你的项目要放的目录,默认或自己设都行。进入界面点击工具栏File&gt;new&gt;java project(如果没有选择project然后搜索java project)&gt;填写项目信息&gt;完成，如图：若遇到弹窗提示点Ok就可以了。点开工程&gt;右击src&gt;new&gt;class&gt;填写类信息&gt;finish打开Demo类在光标处敲入System.out.println(“Hello world!”); 保存，代码正确会自动编译，代码错误会有提示，没有错误点运行。运行成功 以上是这篇博客的全部内容，从环境变量配置到集成环境运行代码都很顺利，初学者如果哪里有不懂，欢迎邮件交流，感谢您的阅读。 小尾巴写博客是真的累，坐了一下午，不过程序员就要坐的住，哈哈，前期工作都已完成，接下来开始学习Java正经内容，待续……","link":"/2020/02/05/javabase2-helloworld/"},{"title":"JAVA零基础筑基到修仙（四）——运算符","text":"觉得上篇概念性的东西讲的太多了，参考了别的地方的资料，过了一天看了看感觉没必要将那么多概念，直接上代码加注释效果更佳，这篇我们讲运算符，分为算术运算符，赋值运算符，关系运算符，逻辑运算符，位逻辑运算符和三目运算符。 算数运算符故名思意，就是算数用的，加减乘除，分为一元和二元两种： 一元运算符一元运算符就是一个元素就可以用，有三个 -、++（自增运算符）、--（自减运算符），自增、自减我们一起带过，不再单独说。++a表示a=a+1,--a表示a=a-1，除了 - 其他两个有运算先后之分，在变量前面先计算,在变量后面则要运行完本条代码后再计算，举例： 1234567891011121314public class Test { public static void main(String[] args) { // TODO Auto-generated method stub int a = 1; System.out.println(-a);//取反 System.out.println(++a);//先运算a=a+1，再输出，输出2; a=2 System.out.println(a++);//先输出a,输出2,再运算a=a+1, a=3 System.out.println(--a);//先运算a=a-1,再输出，输出2; a=2, System.out.println(a--);//先输出a，输出2，再运算a=a-1, a=1; System.out.println(a);//输出a,a=1; }} 二元运算符就是常见的加减乘除等形式，另外还有求模。加减乘除的运算优先级和数学上是一样的，括号内有最高优先级。进行算术运算时应注意以下两点： 求余（％）运算要求参与运算的两个操作数均为整型，不能为其他类型。 两个整数进行除法运算，其结果仍为整数。如果整数与实数进行除法运算，则结果为实数。举个例子：1234567891011public class Test { public static void main(String[] args) { // TODO Auto-generated method stub int i = 2, j = 1; float k = 1f; System.out.println(j/i); System.out.println(k/i); }} 运行结果建议写几个加减乘除综合运算（带上取余），用上不同类型，看看结果是不是和想象中一样，光看或者复制我的代码是效果不会很好。 赋值运算符（=）赋值是这种格式 [变量名称=表达式内容] ，不要把 = 想象成数学中的等号，比如 a=b+1 要理解成将b+1的值赋予a,读代码顺序从右往左。赋值运算符可以与算数运算符组合，如 a+=2 等同于 a=a+2 下面列举了常用组合：这样的好处是让代码更简洁，易读，易维护，我们动手试一下： 12345678910111213141516public class Test { public static void main(String[] args) { // TODO Auto-generated method stub double price = 10.25; // 定义商品的单价，赋值为10.25 double total = 0; // 定义总价初始为0 int count = 2; // 定义购买数量，赋值为2 price -= 1.25; // 减去降价得到当前单价 count *= 5; // 现在需要购买10个，即原来数量的5倍 total = price * count; // 总价=当前单价*数量 System.out.printf(\"商品当前的单价为：%4.2f \\n\", price); // 输出当前单价 System.out.printf(\"购买商品的数量为：%d \\n\", count); // 输出购买数量 System.out.printf(\"总价为：%4.2f \\n\", total); // 输出总价 }} 运行结果 逻辑运算符（&amp;&amp;、||、!）逻辑运算符把各个运算的关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。包含逻辑与、或、非和短路与、或。逻辑运算符是对布尔型变量进行运算，其结果也是布尔型：短路的意思我们举个例子解释一下： &amp;&amp; 与 &amp; 区别：如果 a 为 false，则不计算 b（因为不论 b 为何值，结果都为 false） || 与 | 区别：如果 a 为 true，则不计算 b（因为不论 b 为何值，结果都为 true）我们在敲代码时基本很少用到逻辑与、或，常用的都是短路与、或，而且提倡多用短路，节省系统资源。123456789101112131415161718public class Test { public static void main(String[] args) { // TODO Auto-generated method stub boolean a = true; boolean b = false; System.out.println(!a); System.out.println(a&amp;b); System.out.println(a&amp;a); System.out.println(a&amp;&amp;b); System.out.println(a&amp;&amp;a); System.out.println(a|b); System.out.println(a|a); System.out.println(a||b); System.out.println(a||a); }} 看看和自己想象中的结果是否相同。 关系运算符（比较运算符）关系运算符也叫比较运算符，一个字”比“。大于、小于、等于、不等于、小于等于、大于等于，相比结果为布尔型：关系运算符的优先级为：&gt;、&lt;、&gt;=、&lt;= 具有相同的优先级，并且高于具有相同优先级的 !=、==。关系运算符的优先级高于赋值运算符而低于算术运算符，结合方向是自左向右。关系表达式通常用于 Java 程序的逻辑判断语句的条件表达式中。使用关系表达式要注意以下几点： 运算符 &gt;=、==、！=、&lt;= 是两个字符构成的一个运算符，用空格从中分开写就会产生语法错误。例如 x&gt; =y; 是错误的，但是可以写成x &gt;= y; 在运算符的两侧增加空格会提高可读性。同样将运算符写反，例如 =&gt;、=&lt;、=! 等形式会产生语法错误。 由于计算机内存放的实数与实际的实数存在着一定的误差，如果对浮点数进行 ==（相等）或 !=（不相等）的比较，容易产生错误结果，应该尽量避免。 不要将“==”写成“=”。（在进行if条件判断时常会写错） 这里我们补充个以后写测试类经常会用到的类，控制台输入类$\\color{red}{ Scanner }$，我们打开jdk文档看一下，ctrl+f 搜索 scanner （百度也许更快，不过我觉得自己看文档更有逼格，人生不是为了装逼就毫无意义）：文档中给出了用法示例，以及各种方法接下来做个练习在控制台输入两个数比较大小（输完第一个数按回车输第二个）： 12345678910111213141516171819202122232425262728293031public class Test { public static void main(String[] args) { // TODO Auto-generated method stub int number1, number2; // 定义变量，保存输入的两个数 System.out.print(\"请输入第一个整数(number1)：\"); Scanner input = new Scanner(System.in); number1 = input.nextInt(); // 输入第一个数 System.out.print(\"请输入第二个整数(number2)：\"); input = new Scanner(System.in); number2 = input.nextInt(); // 输入第二个数 System.out.printf(\"number1=%d,number2=%d\\n\", number1, number2); // 输出这两个数 // 判断用户输入的两个数是否相等 if (number1 == number2) { System.out.println(\"number1 和 number2 相等。\"); } // 判断用户输入的两个数据是否相等 if (number1 != number2) { System.out.println(\"number1 和 number2 不相等。\"); // 判断用户输入的数1是否大于数2 if (number1 &gt; number2) { System.out.println(\"number1 大于 number2。\"); } // 判断用户输入的数1是否小于数2 if (number1 &lt; number2) { System.out.println(\"number1 小于 number2。\"); } } }} 运行结果这里面我们用到了if条件结构，到后面单独说一下吧。 位运算符位逻辑运算符位逻辑运算用于二进制数的计算，两个数对位上与、或、非、抑或、即位取反。上图：举个例子，计算5&amp;12，我们将计算过程画出来：我们看到对位上都为1该位对应的结果为1否则为零，最终计算结果转为十进制为4，那么或（|）运算是对应位置有1就得1，抑或运算（^）是对位相同为1，不同为0，取反（~）是对应位置直接取反，1变0，0变1，我们不再一一举例。 移位运算符（&gt;&gt;、&lt;&lt;）移位运算同样对于二进制来说的： &gt;&gt; 右移位 例8 &gt;&gt; 1结果为4 &lt;&lt; 左移位 例9 &lt;&lt; 2结果为36我们联系下左移位运算：例如11 &lt;&lt; 1 结果为22我们发现左移一位结果时原来的二倍，根据二进制转十进制的计算方法，其实就是左移一位就乘二。同理右移一位是除二，我们不再一一举例。 复合位赋值运算符所有的二进制位运算符都有一种将赋值与位运算组合在一起的简写形式。复合位赋值运算符由赋值运算符与位逻辑运算符和位移运算符组合而成：其实和+=、-=、一样的理解方法，平时很少用到，不再举例了。 三目运算符（值=条件?表达式1:表达式2）判断是否符合条件，符合运行表达式1，不符合运行表达式2，得出结果。因为右三个因数，所以叫三目运算符，它相当于一个 if……else 条件结构，相比普通if条件结构代码简洁，执行效率高。 12345678910public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Scanner input = new Scanner(System.in); int i = input.nextInt(); System.out.println(i &gt; 10 ? \"i大于十\" :\"i小于十\"); }} 输入几个数试一下而且三目运算符支持嵌套，比如你可以把“i大于十”换成（ i&gt;15 ? “i大于十五” : “i大于十”），不再举例了。 小尾巴说了这么多运算符，web业务代码中位运算是很少用到的，可能嵌入式那边会更常用一些，不用背，多写代码就行。加油！！！","link":"/2020/02/07/javabase4-ysf/"},{"title":"JAVA零基础筑基到修仙（五）——条件结构","text":"条件结构和后面的循环结构我们统称为流程控制。条件结构式代码中最频繁使用的代码块，功能简单粗暴，有说去年再steam上大卖的《太吾绘卷》就是用一堆条件代码写的，哈哈哈谁知道是不是真的呢。 if……else……为什么需要条件结构，举个例子，过年小明家有邻居来拜年，邻居带着女儿，小姐姐甚是漂亮，小明想要搭话，那该怎么称呼呢，姐姐？还是小姐姐？这就需要来个年龄判断了: 123456789101112131415public class Test { public static void main(String[] args) { // TODO Auto-generated method stub Scanner input = new Scanner(System.in); int mm = input.nextInt(); //小明今年10岁 int xm = 10; if (mm&gt;xm) { System.out.println(\"该叫姐姐\"); }else { System.out.println(\"该叫小姐姐\"); }} 小明10岁，妹妹9岁最简单的条件结构连else都不需要，符合条件就执行内部代码，不符合就直接跳过，当然如果有众多条件判断就要加入 else if 看格式： 1234if( ){ ...}else if( ) {... }.....else { ...} 花括弧中式代码段，如果只有一段代码（一段代码的意思是只有一个“;”）,那就不用加“{}”看：多段代码一定要加括弧，不然编译不通过，语法错误。有括弧就可以为所欲为，我可以在里面再写一个if语句，搞个嵌套，这种形式： 12345678910111213141516171819if(表达式1) { if(表达式2) { 语句块1; } else { 语句块2; }} else { if(表达式3) { 语句块3; } else if(表达式4) { 语句块4; } else { if(表达式n) { 语句块n; } else { 语句块n+1; } }} if条件结构较容易，多写几个练习就掌握了，比如说判断三个数中的最大值，请读者自己写一写，写好了那四个数呢，还有如果是多个条件一起做判断呢（提示多个条件需要用到“&amp;&amp;”、“||”，否定条件开头加“！”）？ switch语句switch…case是多路分支语句，当然用if也可以达到一样的效果，但是当条件判断项众多时，大量的if…else大大降低了程序的可读性，通俗地说 if 是 两个路口的岔路，case是多个路口的岔路。switch语句的一般形式： 123456789101112131415switch(表达式) { case 值1: 语句块1; break; case 值2: 语句块2; break; … case 值n: 语句块n; break; default: 语句块n+1; break;} 其中，switch、case、default、break 都是 Java 的关键字。一一介绍一下： switch表示“开关”，这个开关就是 switch 关键字后面小括号里的值，小括号里要放一个整型变量或字符型变量。表达式必须为 byte，short，int，char类型。Java7 增强了 switch 语句的功能，允许 switch 语句的控制表达式是 java.lang.String 类型的变量或表达式。只能是 java.lang.String 类型，不能是 StringBuffer 或 StringBuilder 这两种字符串的类型。 case表示“情况，情形”，case 标签可以是： 类型为 char、byte、 short 或 int 的常量表达式。 枚举常量。注意：case 值不能重复 从 Java SE 7 开始， case 标签还可以是字符串字面量。 default表示“默认”，即其他情况都不满足。default 后要紧跟冒号，default 块和 case 块的先后顺序可以变动，不会影响程序执行结果。通常，default 块放在末尾，也可以省略不写。 break表示“停止”，即跳出当前结构。如果在 case 分支语句的末尾没有 break 语句，有可能触发多个 case 分支。那么就会接着执行下一个 case 分支语句。这种情况相当危险，常常会引发错误。所以不到非使用不可，咱不用这个。 我们举两个例子来结束switch的学习，一个正确用法，一个错误用法。小明期末考试结束，成绩90分以上算优秀，他妈说考一个优秀对应奖励一本寒假作业，一个都没有奖励3本，还有一顿打（小明太幸福了），小明这个寒假过的快不快乐呢？我们用switch语句演示一下。先来正确的： 12345678910111213141516171819202122232425public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"请输入小明获优个数：\"); int best = input.nextInt(); // 我们假设小明一共考三个科目。 if (best &gt; 3 || best &lt; 0) { System.out.println(\"小明：谢谢别乱输入！\"); return; } switch (best) { case 1: System.out.println(\"奖励一本\"); break; case 2: System.out.println(\"奖励两本\"); break; case 3: System.out.println(\"奖励三本\"); break; default: //0个 System.out.println(\"奖励三本，一顿毒打\"); break; } } 控制台输入2，看结果：如果我们忘了加break会怎样： 123456789101112131415161718192021public static void main(String[] args) { Scanner input = new Scanner(System.in); System.out.print(\"请输入小明获优个数：\"); int best = input.nextInt(); // 我们假设小明一共考三个科目。 if (best &gt; 3 || best &lt; 0) { System.out.println(\"小明：谢谢别乱输入！\"); return; } switch (best) { case 1: System.out.println(\"奖励一本\"); case 2: System.out.println(\"奖励两本\"); case 3: System.out.println(\"奖励三本\"); default: //0个 System.out.println(\"奖励三本，一顿毒打\"); } } 我们继续输入2：小明这下要高兴坏了呢，哈哈哈。忘记break，从匹配那条开始下面的代码都会执行，这是严重的逻辑错误。 另外代码中if判断的地方为要判断多个条件做了实例，用上了“||”短路或，还有花括号内部用了 return 。“return” 在Java中代表结束，在一个方法中，出现return意味着方法的结束，return 可用在任何方法里， return null/true/false/“”/… 则需要用在有返回值的方法里。方法前有“void”关键字 则说明无返回值，否则有返回值，需要返回什么类型的返回值就要把“void” 换成什么类型，简单举个例子： 12345678public static void main(String[] args) { String who = str();//声明变量来获得返回值 System.out.println(who); System.out.println(str());//也可以不用新建对象 }public static String str() { return \"This is kangkang\"; } 运行结果 if or switch ?if 和 switch 可以变通，那该怎么选择呢？理论上，条件分支越多，switch 的优势越明显，所以本着物尽其用的原则，在分支少的时候用 if ,分支多的时候用 switch 。 如果没有编程基础，确实不太容易接收，“无论遇到什么困难我们都不要怕……加油！奥力给！！！”（巨魔吟唱）。随着内容越来越深入，代码越来越复杂，为保证写代码美观、快捷，在此说两个eclipse里常用快捷键，”Alt+/“代码提示，”ctrl+shift+f”代码自动格式化，以及自己设置额key 用 sout 回车打出 System.out.println，注释模板等；感兴趣可以去百度搜一搜，挺好玩的。 小尾巴每天一篇，坚持住，今天自己搭个gitlab+本地nginx看了一堆博客随便点开，内容图片都一样，我承认优秀博客不少，但是又相当多的博客都是整篇抄来抄去，自己都不去操作验证，导致找一个适合自己电脑环境而且方法完整正确好难好难，浪费了大量时间。我的知识也都是网络上学的，知道网络博客一大抄的坑，所以我想让我写的每篇博客的内容都有自己实践过，保证正确性。看csdn的博客真的太难了。","link":"/2020/02/08/javabase5-tjjg/"},{"title":"JAVA零基础筑基到修仙（六）——循环","text":"从这篇内容开始Java核心内容——循环结构的学习，日常生活中的循环很常见，墙上钟表的指针一圈一圈的不停的转是一种循环，人体内的水每时每刻都在循环，再如鲁迅曾经说过“人类的本质是复读机”，复读也是循环。本篇要求做到如下几点：理解循环含义;会用while结构;会用for/foreach结构。 while循环while循环的一般形式 123while(循环条件) { 循环操作} 循环条件判断为true他就一直循环直到为false为止，特点是先判断再执行。为了锻炼肾体，我每天都坚持做俯卧撑和深蹲，各做20个，别嘲笑我菜。我们用while来做20个俯卧撑， 12345678public static void main(String[] args) { // TODO Auto-generated method stub int i = 1; while(i &lt;= 20 ) { System.out.println(\"第\"+i+\"个俯卧撑！\"); i++; } } 运行结果就是这么简单，如果没有循环，我需要20个 System.out.println 改中间的数值烦死了，有没有发现，现在科技的的进步都是”懒“来驱动的，尤其在it行业，哈哈哈。趁热打铁，再做个练习，计算一下5门考试科目的平均成绩，具体哪科就不说了啊，我们控制台输入五个数求平均值。 1234567891011public static void main(String[] args) { // TODO Auto-generated method stub Scanner input = new Scanner(System.in); int i = 0,score = 0; while(i &lt; 5 ) { score += input.nextInt(); i++; } double avg = score/i; System.out.println(\"五科的平均分是：\"+avg); } 运行结果我们上面用的是 while 的常见形式，先判断后执行，它还有另一种先执行后判断的形式————“ do……while”形式，不过基本上很少用到。do……while循环的一般形式 1234do {循环操作}while(循环条件) 才做了20个俯卧撑，还有20个深蹲要做，我们用do……while来做一下 12345678public static void main(String[] args) { // TODO Auto-generated method stub int i = 1; do { System.out.println(\"第\" + i + \"个深蹲！\"); i++; } while (i &lt;= 20); } 有没有发现基本和上面while代码一模一样，还多了个do，所以用do……while多此一举，没必要，但是照顾到有些人善于顺时思维，有些人善于逆时思维，想用那个那个，可以达到一样的效果。 while的代码结构很简单，但是有需要特别注意的问题即使，在写循环条件时一定要谨慎，否则会出现死循环或者不执行循环操作，死循环会导致程序崩溃。 for 循环除了while循环，还有for循环，for循环的循环条件可以使用局部变量，也可以使用外部变量，当使用局部变量时，程序最多循环多少次是已知的，而while循环只能使用外部变量，无法判断循环多少次。for循环的一般形式 123for(赋值语句;条件语句;迭代语句){ 循环操作} 我们用for循环来做俯卧撑20下： 123456public static void main(String[] args) { // TODO Auto-generated method stub for (int i = 1; i &lt;= 20; i++) { System.out.println(\"第\"+i+\"个俯卧撑\"); } } 运行结果不一样的实现方法，和 while 循环对比记忆，效果更佳。另外，for 语句中赋值、循环条件以及迭代部分都可以为空语句（但分号不能省略），三者均为空的时候，相当于一个无限循环。我们来思考一下当赋值语句，条件语句，迭代语句分别为空时，做20个俯卧撑要怎么写。 赋值语句为空1234567public static void main(String[] args) { // TODO Auto-generated method stub int i = 1;//就是简单的放到外面 for (; i &lt;= 20; i++) { System.out.println(\"第\"+i+\"个俯卧撑\"); } } 条件语句为空（又见 break 关键字）123456789public static void main(String[] args) { // TODO Auto-generated method stub for (int i = 1;; i++) { if (i &gt; 20) break;//这里我们碰到了昨天在 switch 语句中出现的 break 关键字，在这里的作用是结束循环，如果没有它，没有循环条件限制，循环就会一直下去。 System.out.println(\"第\" + i + \"个俯卧撑\"); } } 迭代语句为空1234567public static void main(String[] args) { // TODO Auto-generated method stub for (int i = 1;i &lt;= 20;) { System.out.println(\"第\" + i + \"个俯卧撑\"); i++;//简单的放到里面就可以了 }} 三个代码都跑过了，没问题，不再上图了。请读者自己用for循环写个计算平均数的小程序，用上Scanner类，控制台输入数据。另外思考一下，空三个条件又该怎么写呢？（从三段代码里找答案） for 嵌套for 也是可以嵌套的，用来解决复杂的循环逻辑，比如冒泡排序，就要用到双层for循环，我们到后面再说冒泡排序，我们今天举个输出九九乘法表的例子： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub //外循环，第一个因数取值 for(int i = 1 ;i &lt;= 9 ; i++) { //内循环，第二个因数取值 for(int j = 1 ; j &lt;= i; j++) { //输出算式 System.out.print(i+\"*\"+j+\"=\"+i*j+\"\\t\"); } //换行 System.out.println(); } } 运行结果不仅可以嵌套两套，for可以嵌套任意多套，但是随着层数增加，算法复杂度指数增加，也很少有嵌套多层的算法需求。 forEach 循环forEach 循环时for循环的特殊形式，多用于数组、列表等数据结构迭代，非常好用。它的一般结构是： 123for(类型 变量名:集合) { 语句块;} 我们举个数组迭代的例子，还没讲到数据结构，但是在这里必须找个例子用，遍历一个字符串数组： 1234567public static void main(String[] args) { //举个字符串数组 String[] names = {\"kangkang\",\"tom\",\"john\"}; for(String name : names) { System.out.println(\"i am \"+name); }} 运行结果for绝对可以完成foreach的工作，但是用for遍历数组的话就要通过数组下标循环遍历，还是 foreach 好用，程序员”懒”就是生产力啊！循环结构就这么多内容，到这里，逻辑思考就多了起来，多多练习，祝早日变大佬！！ 小尾巴憋尿博客，部署完赶紧溜了。完整版“巨魔吟唱”：当我们遇到什么困难都不要怕，微笑着面对它，战胜困难的唯一办法就是面对困难，坚持就是胜利，加油！奥力给！！！","link":"/2020/02/09/javabase6-xh/"},{"title":"JAVA零基础筑基到修仙（七）——Debug","text":"人生病了找医生，而且“望闻问切”不再是中医的专利，医生只有对病人身体了解的够清楚，才能找出病灶所在。程序也是一样，随着代码越来越复杂，出了问题很难用眼找出来，特别是逻辑问题相当难找，程序问题称为“bug”我们把给程序找毛病的行为叫“Debug”，中文叫调试。 咱们生病了有专门的医生看病，但是程序病了可没有专门帮你调bug的人，所以debug的事在是太重要了，说着我就打开了eclipse。eclipse 上 debug 的操作比较简单我们先使用debug来查看一下程序如何运行，变量如何变化，熟悉一下使用到的各个按钮，我们用一个简单的循环，昨天的俯卧撑：使用调试首先要打断点，在代码行最前双击，举个最简单的例子，我们看一下循环中，变量 i 如何变化：因为当前代码里没有实例方法调用，直接点下一步就行了step into 用在比如有一行代码是 jump()方法 可以通过into 跳到jump()方法内部查看。这里我们直接点step over就行了。偶们知道了，i++后，i增加了1。疯狂点完二十下好了本次debug就算完成了，最重要的是要在debug中观察变量的变化是否符合逻辑，通常都会有恍然大悟的感觉。后面我回再补充遇到问题代码如何调试，本篇先告诉读者有这个东西，简单怎么使用。（我实在熬不动了） 小尾巴今天想把博客从github移到服务器上，本来想用gitlab的，但是调了半天搭好gitlab，page页总是配不好，不能用，最后晚上放弃了，采用了git仓库+nginx的方法，也有很多坑要填，熬到现在，熬不动了，特殊时期不敢生病啊。晚安！！","link":"/2020/02/10/javabase7-debug/"},{"title":"JAVA零基础筑基到修仙（八）——字符串处理（1）","text":"我们在敲第一个Java程序”Helloworld”的时候就用到了字符串，后面程序举例中很多动作直接用字符串模拟，字符串广泛应用于日常编程，Java中无内置字符串类型，提供了 一个专门创建和操作的类 String ，我们单独拿出来说一说。由于内容较多，需要一点一点讲，本篇内容包括字符串的定义与获取字符串长度，字符串拼接，String 类型与 int 类型转换。 字符串的定义字符串有两种定义方式，直接定义和使用 String 类定义，无论是哪种定义方式，它的所有对象都是不可变对象，变量值的每一次改变都会指向一个新的对象，旧的对象还在内存里面（前面提到过引用型数据内存存储方法筑基到修仙（三））。 简单说明一下，Java内存有一块特殊的区域，常量池，在编译时用来存储 final型数据和对象字面量，String类型数据就是对象字面量，常量池专门存储这些在编译时就已经能够确定的数据，防止频繁的创建于销毁对象，影响内存性能。有兴趣就要去详细了解虚拟机内存机制，对后期提升有帮助，我也只是略懂皮毛,下面说一下我对这个不可变对象的理解。 在介绍数据类型时我们说过，内存内分为堆和栈，而引用型将变量名存放于栈上，使用指针指向位于堆上的对象，结合常量池我们举个例子比如： 首先有 String str = “abc” ， 新建另一个变量时 Sting str1 = “abc” 会现在常量池中搜索是否有”abc”,如果有就不会创建新的对象，只是添加一个指针引用。当变量重新赋值 str = “def” ，就会修改指针指向（常量池有就直接指向，没有就新建“def”对象），但是内存堆中 “abc” 依然存在，所以现在这个str与原str是两个对象。 用 String str3 = new String(“abc”) 这种方式创建，至少产生了一个对象，编译时会在常量池中查找是否有”abc”,有就指向，没有就创建，在运行时因为有 new 又会重新创建一个“abc”对象，所以说至少创建了一个，可能创建了俩对象。举个例子更清楚： 1234567String str1 = &quot;abc&quot;;String str2 = &quot;abc&quot;;String str3 = new String(&quot;abc&quot;);System.out.println(str1 == str2); //trueSystem.out.println(str1 == str3); //falsestr2 = &quot;bcd&quot;;System.out.println(str1 == str2); //false 这里面又有一个坑就是字符串使用”==”比较其实是比较对象，只比较字符串值得话我们在后面筑基到修仙（十）再做详细说明。 直接定义字符串直接定义就是使用 “” 号，引号内部是字符串内容，既可以直接声明变量与值，也可以先声明变量再赋值，举例如下： 直接赋值1String str = \"Oh!owesome!\" 先声明变量再赋值12String str;str = \"Oh!owesome!\" 字符串必须经过初始化才可以使用12345public static void main(String[] args) { // TODO Auto-generated method stub String str; System.out.println(str);//The local variable str may not have been initialized} 举一个正常使用的例子：12345678public static void main(String[] args) { // TODO Auto-generated method stub String str; str = \"Oh!awesome!\"; String str1 = \"这是我独享的moment\"; System.out.println(str); System.out.println(str1);} 使用 String 类定义（包含了使用.length 方法获取字符串长度）直接定义的字符串和使用 String 类定义产生的都是 String 类对象，我们打开jdk API帮助文档来认识一下这个 String 类。首先说明是 String 类的身份信息和初始化示例：然后是构造方法摘要，包含构造方法和众多重载构造方法（重载我们后面再说，就是和构造方法名相同，参数不同）：方法摘要，包含当前jdk支持的所有方法，jdk版本不同包含的方法不一样，有的会过时，也有会新增，但是不会有特别大的变化，通过 对象.方法（）; 调用。最后是构造详解与方法详解：我们通过例子学习如何使用 String 类，和 String 类方法，下面代码使用了获取字符串长度的类方法，获取字符串长度在很多地方非常重要，比如数据迭代，数据输入长度限制等： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub String str = new String(); str = \"i am kangkang\"; String str1 = new String(\"i am jhon\");//使用重载构造方法 int long1 = str.length();//调用length方法获取字符串长度 int long2 = str1.length(); System.out.println(str); System.out.println(str1); System.out.println(\"str的长度是：\"+long1); System.out.println(\"str1的长度是：\"+long2);} 运行结果还有其他常用构造方法，比如用字符数组初始化字符串，再此不再举例，读者自己练一下，体会一下如何使用帮助文档（字符数组声明 char[] ch ={‘a’,’a’,’b’} 或者 {56，80} 看一下如果里面不带单引号的数字输出时什么，涉及到ASCII码知识）。 我们说一下另两个也会用到的字符串类 StringBuffer 和 StringBuilder： 这两个类最常用的是StringBuffer，一句话表述两个的区别是，StringBuffer 为线程安全类，StringBuilder 非线程安全类，因为还没说到线程我们不多做解释，字面意思，两个类功能差不多的化你使用哪个，肯定是安全的那个，所以通常 StringBuilder 很少用到。 因为有文档，我们不在这里长篇叙述 StringBuffer 类的各种信息，只说什么时候使用，使用时与 String 类有什么不同： StringBuffer 类是我们需要特别长字符串的时候使用，比如要通过字符串写一段超长的SQL语句（数据库查询语言），由于内存存储机制，使用 String 类对象可能会导致内存性能下降(说是这么说，我到现在还没遇到过出问题)，这时候我们用 StringBuffer。buffer的意思是缓冲区，就是在创建对象时就创建缓冲区，对内存进行优化。 String 对象可以直接赋值，而且对象不可变（在内存中栈的位置不变，变得是堆中数据得位置），改变对象值就相当于建了一个新的对象。StringBuffer 需要通过构造方法来初始化，而且对象可变，值得改变不会新建对象，不会浪费内存性能，所以当有大量需要拼接得字符串时推荐使用StringBuffer。 最常用得不同点，拼接方法不同，StringBuffer 不能用 “+”拼接，需要append()方法。写个Demo:1234567891011 public static void main(String[] args) { // TODO Auto-generated method stub StringBuffer str = new StringBuffer(\" i am kangkang ,\"); str .append(\"i am a handsome boy\"); //拼接方法也不一样 String str1 = \" i am sicong ,\"; str1 += \"i am rich\"; System.out.println(str); System.out.println(str1); }&gt; 运行结果 字符串拼接在开发中字符串拼接的需求太多了，比如说参数传过来人员相关数据，需要拼接各个属性成为一个完整的句子，那我们来实践一下吧。 String 类型字符串使用 “+” 来拼接，这个方法我们用过很多次了，不举例了。 String 类型字符串使用concat（）方法来拼接，这个我们还没有提到过，从他开始吧：12345678910public static void main(String[] args) { // TODO Auto-generated method stub String[] person = { \" he was \", \" kangkang,\", \" handsome \", \" and \", \"rich\" }; String boy = \"the boy said that:\"; for (String str : person) { // boy += str ; boy = boy.concat(str);// 与“+”效果一样 } System.out.println(boy);} 结果和 + 效果没有区别这两种方法喜欢哪种用哪种。 StringBuffer 刚才我们说过了，使用 append（） 方法也不再举例了。 其他类型与字符串拼接，直接拼就行了，其他类型会自动转为字符串类型（隐式转换），有不能拼的编译器会给提示：123456789public static void main(String[] args) { // TODO Auto-generated method stub int i = 100; double d = 0.99; char c = 'A'; boolean b = true ; float f = 9.9999f; System.out.println(\"test is \"+i+d+c+b+f);} String 与 int 类型转换 首先说 String 类型转 int 类型，有两种方法： 使用 Integer 类，Integer 是 int 的封装类，它提供了类型转换的方法，Integer.parseInt(str)； Integer.valueOf(str).intValue()，同样是用到 Integer 类。12345678910public static void main(String[] args) { // TODO Auto-generated method stub String str = \"100\"; int i = Integer.parseInt(str); int j = Integer.valueOf(str).intValue(); ++i; j += 2; System.out.println(\"i = \" + i); System.out.println(\"j = \" + j);} 然后是 int 转 String 有三种方法： 简单粗暴直接使用 String i=i+””, 用字符串拼接; 使用Integer.toString(i); 使用String().valueOf(i);12345678910public static void main(String[] args) { // TODO Auto-generated method stub int i = 100; String str1 = i + \"\"; String str2 = Integer.toString(i); String str3 = String.valueOf(i); System.out.println(\"str1:\"+str1); System.out.println(\"str2:\"+str2); System.out.println(\"str3:\"+str3);} 这些个方法都是Java开发人员慢慢添加上来的，如果愿意你可以 ctrl+左击 点到方法内部去看看，领会一下开发精神，学习一下代码逻辑，之所以现在Java这么好用，完全是因为我们站在巨人的肩膀上啊，那现在Java不足的地方就靠我们了，加油，奥里给！！ 小尾巴全国疫情都在慢慢好转了，这几天我这里小区封门无法出去，加上年前宅了几天我有将近20天没出门了，不过早已习惯，上学时除了上课可以一个月不出宿舍，已经练出来了，但是当我都感觉到有些宅时，其他人应该都有些受不了了吧，哈哈哈！","link":"/2020/02/11/javabase8-zfccl1/"},{"title":"JAVA零基础筑基到修仙（九）——字符串处理（2）","text":"接着上篇字符串处理继续,本篇内容包括字符串的大小写转换、除去空格、子字符串提取、分割和替换。我们说这些方法的目的不是记住这个方法如何使用，而是在于看过后心里能有个印象，有这个方法可以用，下次有用到时直接去查文档就行了，由于不想篇幅过长，还剩字符串比较和查找，下一篇再说。 字符串大小写转换Java 提供 toLowerCase() 和 toUpperCase() 两个方法分别用来转小写与转大写，转换时其他字符串不会受到影响： 大写转小写 toLowerCase()使用方法： 1str.toLowerCase(); 例如 12345 public static void main(String[] args) { // TODO Auto-generated method stub String str = \"Oh!Awesome!!\"; System.out.println(str.toLowerCase());} 运行结果: 小写转大写 toUpperCase()1str.toUpperCase(); 例如： 12345public static void main(String[] args) { // TODO Auto-generated method stub String str = \"Oh!Awesome!!\"; System.out.println(str.toUpperCase());} 运行结果: 字符串除去空格这种需求通常再数据要标准化的时候用到，如果传了头尾有空格的数据放入有长度限制数据库，会导致数据库报异常，然而用眼看不出来（我曾经被这样的数据害惨了，一个bug调半天），Java提供 trim() 方法除去空格（我门说的空格在字符串的头尾）。 1str.trim(); 例如： 1234567public static void main(String[] args) { // TODO Auto-generated method stub String str = \" Oh!Awesome!! \"; //我们借用长度表现 System.out.println(str.length()); System.out.println(str.trim().length());} 运行结果： 提取子字符串比如你需要从一个身份证号截取到籍贯、出生日期等信息,Java提供了 substring() 方法来解决这个问题。 1234//范围有前有后str.substring(int beginIndex,int endIndex);//范围只有开始str.substring(int beginIndex); 需要注意的是，substring()方法 beginIndex 从 0 开始，而 endIndex 从 1 开始，使用时要特别注意。然后还要注意其他语言也有substr方法，参数可能不一样别搞混。 例如从身份证提取信息： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub String personId = \"130523202001012233\"; String city = \"\"; String birth = personId.substring(6, 14);// 20200101 // 预习一下这个字符串比较方法equals（），后面专门说一下 if (personId.substring(0, 6).equals(\"130523\")) { city = \"河北省邢台市\"; } System.out.println(\"这个人的籍贯是：\" + city); System.out.println( \"这个人的出生日期是：\" + birth.substring(0, 4) + \"年\" + birth.substring(4, 6) + \"月\" + birth.substring(6) + \"日\");} 运行结果 字符串分割字符串中包含几个人名用逗号隔开了，现在需要分割开，Java提供了 split() 方法。 1234//需要数组来接收很好理解String[] strs = str.split(String sign);//limit 可以限制个数String[] strs = str.split(String sign , int limit); 例如： 12345678910111213public static void main(String[] args) { // TODO Auto-generated method stub String str = \"kangkang,john,jan\"; String[] names = str.split(\",\"); String[] names1 = str.split(\",\",2); for(String name : names) { System.out.println(name); } System.out.println(\"~~~~~~~~~~~~~~~~~~~~~~~~~~\"); for(String name : names1) { System.out.println(name); }} 运行结果可以看到如果限制个数的话，最后一个元素是切割剩下的所有字符串。 如果字符串是用 “.”或“|” 来分割的，以为他俩都是转义字符，需要在加上“\\\\”,如“\\\\.”、“\\\\|”,如果 str.split(“”) ,得到的是一个一个单个字符。 字符串的替换Java为字符串替换提供了三个方法，分别是 replace()、replaceFirst() 和 replaceAll()。 replace()1str.replace(String oldChar, String newChar); 例如一个经过简单加密的密码 “1$2$3$4$5$6$7$8$9”,需要转换为正常密码 “123456789” ： 123456public static void main(String[] args) { // TODO Auto-generated method stub String str = \"1$2$3$4$5$6$7$8$9\"; String pwd = str.replace(\"$\", \"\"); System.out.println(pwd);} 运行结果 replaceFirst()replaceFirst() 方法用于将目标字符串中匹配某正则表达式的第一个子字符串替换成新的字符串，其语法形式如下： 1str.replaceFirst(String regex, String replacement); 其中，regex 表示正则表达式；replacement 表示用于替换的字符串。例如： 123456public static void main(String[] args) { // TODO Auto-generated method stub String words = \"i am kangkang,i am rich ,kangkang is rich\"; String newStr = words.replaceFirst(\"rich\", \"poverty\"); System.out.println(newStr);} 运行结果 ： replaceAll()看方法名就知道，相对 replaceFirst 这是个完全替换的方法： 1str.replaceAll(String regex, String replacement); 我们继续使用上面的例子： 123456public static void main(String[] args) { // TODO Auto-generated method stub String words = \"i am kangkang,i am rich ,kangkang is rich\"; String newStr = words.replaceFirst(\"rich\", \"poverty\"); System.out.println(newStr);} 运行结果： 小尾巴看新闻新冠肺炎确诊数已经连续7天下降了，感谢广大医疗工作者的付出，我在家啥也帮不上真是惭愧！","link":"/2020/02/12/javabase9-zfccl2/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Java字符串处理","slug":"Java字符串处理","link":"/tags/Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"},{"name":"Java时间日期处理","slug":"Java时间日期处理","link":"/tags/Java%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"},{"name":"Java数字处理","slug":"Java数字处理","link":"/tags/Java%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86/"},{"name":"Java内置包装类","slug":"Java内置包装类","link":"/tags/Java%E5%86%85%E7%BD%AE%E5%8C%85%E8%A3%85%E7%B1%BB/"}],"categories":[{"name":"Java基础学习","slug":"Java基础学习","link":"/categories/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"}]}